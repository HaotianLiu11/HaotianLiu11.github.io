{"meta":{"title":"福江 の いえ","subtitle":"富江江江江","description":"一只孜孜不倦的程序猿，立志把分享变成一种习惯！","author":"Fu JANG","url":"http://liuhaotian.top","root":"/"},"pages":[{"title":"关于我","date":"2020-05-27T09:20:50.000Z","updated":"2020-05-29T16:19:14.544Z","comments":true,"path":"about/index.html","permalink":"http://liuhaotian.top/about/index.html","excerpt":"","text":"征婚启事我是个普普通通的大一学生，来自普普通通的大学，有着普普通通的生活，不知不觉已经19了，最大的梦想是找个女朋友！ 不过要实现找个妞陪我的梦想好难好难，所以我退而求其次，希望自己未来可以过一个好生活，然后再找个妞，曲线救国哈哈哈。 不过未来想活的好就得有money呀，虽然俗气了一些。但是毕竟贫贱夫妻百事哀嘛，所以为了给将来的老婆买包，我要努力努力努力努力努力努力！！！ 最近想努力奋斗，然后在ACM或者蓝桥杯中拿个好名次，and now自己同时在学习编程知识(后端开发)，不过学业荒废了好久emmmmm… 联系方式热烈欢迎女同学来找我玩儿！！五大三粗并且要请教问题的汉子就不要加了emmmm我怕入坑… QQ： 2235749416 微信： a13019949398 日常热爱超喜欢你的名字、天气之子、大鱼海棠，因为女主都好温柔啊~ 还喜欢听音乐，温柔中带一点点忧郁那种类型，emmmm,当然也喜欢敲代码…还有我超级老实，一个本分的孩子就是我啦! 个人性格也很多愁善感，超级善变，泪点超低。就叨咕这么多啦~ 附图一张"},{"title":"留言板","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-29T12:23:57.525Z","comments":true,"path":"comments/index.html","permalink":"http://liuhaotian.top/comments/index.html","excerpt":"","text":"欢迎大家留言给我鸭，我都会看到的~"},{"title":"分类","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T04:57:46.858Z","comments":false,"path":"categories/index.html","permalink":"http://liuhaotian.top/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T13:39:16.948Z","comments":true,"path":"link/index.html","permalink":"http://liuhaotian.top/link/index.html","excerpt":"","text":"想分享友情链接的小伙伴留言即可~"},{"title":"音乐","date":"2020-05-27T11:17:35.000Z","updated":"2020-05-27T12:07:16.641Z","comments":false,"path":"music/index.html","permalink":"http://liuhaotian.top/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T04:58:17.182Z","comments":false,"path":"tags/index.html","permalink":"http://liuhaotian.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ACWING算法基础课总结","slug":"ACWING算法基础课总结","date":"2020-06-26T16:16:59.000Z","updated":"2020-06-28T07:11:34.026Z","comments":true,"path":"2020/06/27/ACWING算法基础课总结/","link":"","permalink":"http://liuhaotian.top/2020/06/27/ACWING%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"数学知识基础知识 所有小于等于1的数既不是质数也不是合数，在大于1的整数中，如果只包含1和本身这两个约数则为质数（素数） 质数的判定：试除法，时间复杂度一定是O(N^1/2)866.试除法判定质数123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;bool is_prime(int x) &#123; if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i++) if (x % i == 0) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; while (n--) &#123; int x; cin &gt;&gt; x; if (is_prime(x)) puts(\"Yes\"); else puts(\"No\"); &#125; return 0;&#125; 分解质因数：试除法（从小到大尝试N的所有因数，N中最多只包含一个大于N^1/2的质因子）时间复杂度最坏是O(N^1/2)，最好是O(logN)867.分解质因数12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;void divide(int x) &#123; for (int i = 2; i &lt;= x / i; i++) &#123; if (x % i == 0) &#123; int s = 0; while (x % i == 0) x /= i, s++; cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; s &lt;&lt; endl; &#125; &#125; if (x &gt; 1) cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; 1 &lt;&lt; endl; cout &lt;&lt; endl;&#125;int main() &#123; int n; cin &gt;&gt; n; while (n--) &#123; int x; cin &gt;&gt; x; divide(x); &#125; return 0;&#125; 筛质数： 埃氏筛法：时间复杂度O(NloglogN) 线性筛法：每个数N只会被它的最小质因子筛掉（当i%primes[j]==0时，primes[j]一定是i的最小质因子，所以primes[j]一定是i*primes[j]的最小质因子；当i%primes[j]!=0时，所以primes[j]一定小于i的最小质因子，primes[j]一定是i*primes[j]的最小质因子。任何一个合数X一定存在一个最小质因子J，当i枚举到X/J时，此合数一定会被筛，因此每个合数只会被筛一次，所以时间复杂度为线性的。）时间复杂度O(N)868.筛质数12345678910111213141516171819202122232425// 埃氏筛法#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int primes[N], cnt;bool st[N];void get_primes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (st[i]) continue; primes[cnt++] = i; for (int j = i + i; j &lt;= n; j += i) st[j] = true; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526// 线性筛法#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;int primes[N], cnt;bool st[N];void get_primes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; 试除法求约数：时间复杂度一定是O(N^1/2)869.试除法求约数1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; get_divisors(int x) &#123; vector&lt;int&gt; res; for (int i = 1; i &lt;= x / i; i++) if (x % i == 0) &#123; res.push_back(i); if (i != x / i) res.push_back(x / i); &#125; sort(res.begin(), res.end()); return res;&#125;int main() &#123; int n; cin &gt;&gt; n; while (n--) &#123; int x; cin &gt;&gt; x; auto res = get_divisors(x); for (auto x : res) cout &lt;&lt; x &lt;&lt; \" \"; puts(\"\"); &#125; return 0;&#125; 约数个数：N=P1^A1+P2^A2+P3^A3+...+PK^AK，约数个数为(A1+1)(A2+1)(A3+1)...(AK+1)，每一个P都有对应的A+1种选法，每个不同的选法，都能凑成一个不同的约数870.约数个数123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110, mod = 1e9 + 7;int main() &#123; int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n--) &#123; int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i++) while (x % i == 0) &#123; x /= i; primes[i]++; &#125; if (x &gt; 1) primes[x]++; &#125; long long res = 1; for (auto p : primes) res = res * (p.second + 1) % mod; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 约数之和：N=P1^A1+P2^A2+P3^A3+...+PK^AK，约数之和为``(P1^0+P1^1+…+P1^A1)(P2^0+P2^1+…+P2^A1)(P3^0+P3^1+…+P3^A1)…(PK^0+PK^1+…+PK^A1)，每个像选一个，凑成一个约数，累加871. 约数之和12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 110, mod = 1e9 + 7;int main() &#123; int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n--) &#123; int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i++) while (x % i == 0) &#123; x /= i; primes[i]++; &#125; if (x &gt; 1) primes[x]++; &#125; long long res = 1; for (auto p : primes) &#123; long long a = p.first, b = p.second; long long t = 1; while (b--) t = (t * a + 1) % mod; res = res * t % mod; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 欧几里得算法（辗转相除法）872.最大公约数1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;int main() &#123; int n; cin &gt;&gt; n; while (n--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; gcd(a, b) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"ACWING算法基础课总结","slug":"ACWING算法基础课总结","permalink":"http://liuhaotian.top/tags/ACWING%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E6%80%BB%E7%BB%93/"}]},{"title":"张一鸣：我的大学四年收获及工作感悟","slug":"张一鸣：我的大学四年收获及工作感悟","date":"2020-06-21T15:28:28.000Z","updated":"2020-06-21T15:36:21.081Z","comments":true,"path":"2020/06/21/张一鸣：我的大学四年收获及工作感悟/","link":"","permalink":"http://liuhaotian.top/2020/06/21/%E5%BC%A0%E4%B8%80%E9%B8%A3%EF%BC%9A%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E6%94%B6%E8%8E%B7%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/","excerpt":"","text":"YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS. 张一鸣：我的大学四年收获及工作感悟 张一鸣，男，1983年出生，福建永定人，北京字节跳动科技有限公司创始人、CEO，今日头条创始人、原CEO。张一鸣2005年毕业于南开大学软件工程专业，曾参与创建酷讯、九九房等多家互联网公司，历任酷讯技术委员会主席、九九房创始人兼CEO。2012年，张一鸣创办字节跳动。2013年，他先后入选《福布斯》“中国30位30岁以下的创业者”和《财富》“中国40位40岁以下的商业精英”，是中国国内互联网行业最受关注的青年领袖之一。2020年4月6日，张一鸣以950亿元人民币财富名列《胡润全球百强企业家》第89位。2020年5月12日，张一鸣以785.3亿元人民币财富名列《2020新财富500富人榜》第19位。 大学里的三点收获2001年我考入了南开大学，起初大学的生活是让人有点失落的，但慢慢地从安静朴素的校园和踏实努力的氛围中，我还是找到了自己的节奏。大学期间我主要在做三件事情 ，一是写代码，因为我是搞技术的；二是看书，看了很多很多书；三是修电脑。基于此自己也有三点收获：耐心，知识，伙伴。 第一点收获：耐心。有耐心，能独处，并基于长期思考做判断，而不为短期因素所干扰，耐心地等待你设想和努力的事情逐步发生，这对创业来说是非常重要的事情。事实上，你经常想象的很美好，设计的也很完整，你也很努力，但你所期待的事情，经常需要很长时间才能发生。这种耐心，绝对是在南开磨练出来的。 大学的时候我是怎么面对枯燥的生活？人物传记是非常好的心灵鸡汤。我读了很多人物传记，如果说有收获，就是发现那些伟大的人，在没有成为伟大的人之前，也是过着看起来枯燥的生活，每天都在做一些微不足道的事情，但这些事情最后从点连成线，成就了他们。 我毕业后参与创立了酷讯、饭否、99房、到现在的今日头条，每一段创业经历，都挺寂寞的。现在回想，耐心非常重要，不仅是等待的耐心，还要有耐心做深入思考，还要有耐心地找到更多更好的合作伙伴。 第二点收获：看书。寂寞的大学生活，给了我人生最安静的阅读时光。我用别人打游戏、打牌的时间，阅读了各种各样的书，或者说乱七八糟的书，包括各个专业的书，包括人物传记，也有各种境内外的报刊杂志。 当然，那时候，我也有困惑，觉得看的这些东西和思考的问题都很有意思，但在生活中没什么用。直到后来我进入互联网行业并开始创业，各种各样的知识才连成线，帮我理解行业、理解管理，更快地掌握不熟悉的领域，包括如何让信息得到更有效率的组织和分发，从而改变各行各业的效率。 2011年，我观察到一个现象，地铁上读报的人、卖报的人越来越少，年初还有，年底几乎没有了， 同时，2011年是智能手机出货量的高峰，是2008年、2009年、2010年三年智能手机出货量的总和。我想，这是信息传播介质的变革，手机很可能会取代纸媒成为信息传播的最主要载体，又因为人和手机的对应关系，手机随身携带，个性化推荐的需求一定会增加，于是我创办了今日头条。 第三点收获：结交了很多的伙伴。我在读大学的时候结识了很多优秀的同伴。作为一个不怎么参与集体活动的理工男，怎么保持社交呢？主要靠修电脑和编程建网站……后来，同学聚会，打招呼的方式基本是：hi，你的电脑还是我装的。我装过的电脑有几十台，当然大部分是女同学……不但要帮忙装电脑还要经常保修。没错，就像你们想象的那样，修电脑为我带来了人生重大的收获——当时的女朋友，现在的太太。 在校园里，我接了不少外包的项目。包括我太太她们系的网站(当然是免费的)。因为这门手艺加上兼职，大四的时候，我每月能有超过两三千的收入，在当时，绝对是土豪。那时候，和同学一起泡实验室，熬到半夜一两点，会请大家集体去烤串。一周能吃2-3次。 当时和我吃烧烤的人很多是对编程感兴趣，而且志趣相投的同学朋友，有我同一级的，微电子专业的，软件工程专业的，还有师兄师弟，后来也相继加入我创办的公司，成为了我们公司的技术骨干，也是创业伙伴。 我的工作感悟2005 年，我从南开大学毕业，加入一家叫酷讯的公司。我是最早期加入的员工之一，一开始只是一个普通工程师，但在工作第二年，我在公司管了四五十个人的团队，负责所有后端技术，同时也负责很多产品相关的工作。 有人问我：为什么你在第一份工作中就成长很快？是不是你在那个公司表现特别突出？其实不是。当时公司招聘标准很高，跟我同期入职的就有两个清华计算机系的博士。那我是不是技术最好？是不是最有经验？都不是。后来我想了想，当时自己有哪些特质。 首先，我工作时，从不分哪些工作是我该做的，哪些不是我该做的。我做完自己的工作后，对于大部分同事的问题，只要我能帮助解决，我都去做。当时，Code Base中大部分代码我都看过。新人入职时，只要我有时间，我都给他讲解一遍。通过讲解，我自己也能得到成长。 工作的前两年，我基本上每天都是十二点、一点回家，回家后也编程到挺晚。确实是因为有兴趣，而不是公司有要求。所以我很快从负责一个抽取爬虫的模块，到负责整个后端系统，开始带一个小组，后来带一个小部门，再后来带一个大部门。 当时我负责技术，但遇到产品上有问题，也会积极地参与讨论，想产品的方案。很多人说这个不是我该做的事情。但我想说：你的责任心，希望把事情做好的动力，会驱动你做更多事情，让你得到很大的锻炼。 我当时是工程师，但参与产品的经历，对我后来转型做产品有很大帮助。我参与商业的部分，对我现在的工作也有很大帮助。记得在2007年底，我跟公司的销售总监一起去见客户。这段经历让我知道，怎样的销售才是好的销售。当我组建今日头条招人时，这些可供参考的案例，让我在这个领域不会一无所知。 我的创业初心我很尊敬Elon Mask ，他不仅创办了TESLA ，而且还创办了一家叫Space X的公司，目标是革新太空科技，终极目标是人类能够在其他星球生活。 Space X现在是全世界第一家私人向太空发射火箭并实现回收的公司，尽管在前沿领域里不断探索的过程非常艰难，身后甚至连跟随者都没有，但Elon Mask一直相信：只要理论上能够成立，理论上可以做到最好，那就应该去努力实现它。 我特别欣赏这种追求卓越和领先的勇气。年轻人创业，就是要去创造新的技术，做那些理论上存在但还没有实现的东西，给世界带来根本性的进步。创业，有人想的是要赚笔钱，有人想的则是要做件事，我觉得自己是后者。 如果你偶然发现青霉素能消炎，你是先考虑用它去救人还是赚钱呢？应该都是先想到救人。我也是一样。到了这个时代，有个性化的方式来推荐信息，我就想把它做出来。 如果我想卖掉这家公司，现在就可以拿到一大笔钱。但我奋斗的目标不是赚钱和享乐，支撑我的是自我实现，希望有更多的创造体验，更丰富的人生经历，希望遇到更多优秀的人。 现在的创业环境和以前相比已经非常好了，创业能取得多大的成果，最重要的是，你到底愿意做多大的事情。年轻人关键是立志高远，享受拼的过程，不自满，不懈怠。要把成功的目标，设定的尽可能远。 优秀年轻人的五个特点后来，我陆续加入到各种创业团队。在这个过程中，我跟很多毕业生共处过，现在还和他们很多人保持联系。跟你分享一下，我看到的一些好和不好的情况。总结一下，这些优秀年轻人有哪些特点呢？ 第一个特点：有好奇心，能够主动学习新事物、新知识和新技能。我有个前同事，理论基础挺好，但每次都是把自己的工作做完就下班了。 他在这家公司呆了一年多，但对网上的新技术、新工具都不去了解，非常依赖别人，当他想要实现一个功能，就需要有人帮他做后半部分，因为他自己只能做前半部分。如果是有好奇心的人，前端、后端、算法都去掌握，至少有所了解的话，那么很多调试分析，自己一个人就可以做。 第二个特点：对不确定性保持乐观。比方说，今日头条刚开始时，我跟大家讲：我们要做1亿的日启动次数，很多人觉得，你这家小公司怎么可能做得到呢？如果对此持怀疑态度，就不敢努力去尝试。只有乐观的人会相信，会愿意去尝试。 其实我加入酷讯时也是这样，那家公司当时想做下一代搜索引擎（最后也没有做成，只做了旅游的垂直搜索）。我不知道其他人怎么想的，我自己觉得很兴奋。我确实没有把握，也不知道怎么做，但当时就去学，就去看所有相关的东西。我觉得最后也许不一定做成，或者没有完全做到，但这个过程也会很有帮助——只要对事情的不确定性保持乐观，你会更愿意去尝试。 第三个特点：不甘于平庸。走入社会后的年轻人，应该设定更高的标准。大学期间的同学、一起共事的同事中，有很多非常不错的人才，技术、成绩都比我好，但10年过去了，很多人没有达到我当初的预期。 很多人毕业后，目标设定就不高。我回顾了一下，发现有同事加入银行IT部门：有的是毕业后就加入，有的是工作一段时间后加入。为什么我把这个跟「不甘于平庸」挂在一起呢？因为他们很多人加入，是为了快点解决北京户口，或者得到买经济适用房的机会。 如果一个人一毕业，就把目标定在这儿：在北京五环内买一个小两居、小三居，把精力都花在这上面，那么工作就会受到很大影响，他的行为会发生变化，不愿意冒风险。 如果不甘于平庸，希望做得非常好的话，其实不会为这些东西担心，这很重要。我说不平庸，并不是专指薪酬要很高或者技术很好，而是你对自己的标准一定要高。也许你前两年变化得慢，但10年后再看，肯定会非常不一样。 第四个特点：不傲娇，要能延迟满足感。在这里举个反例：两个我印象比较深刻的年轻人，素质、技术都蛮不错，也都挺有特点。我当时是他们的主管，发现他们在工作中deliver（传递）的感觉始终不好。 他们觉得其他同事做得不如他们，其实不是：他们确实可以算作在当时招的同事里面 TOP20% ，但他们觉得自己是 TOP1% 。所以很多基础一点的工作，比如要做一个调试工具，他就不愿意做，或者需要跟同事配合的工作，他就配合得不好。 本来都是资质非常好的人才，人非常聪明、动手能力也强，但没有控制好自己的傲娇情绪。我觉得这和「不甘于平庸」不矛盾。「不甘于平庸」是你目标要设得很高，「不傲娇」是你对现状要踏实。 另一个例子是，当时我们有个做产品的同事，也是应届生招进来，当时大家都觉得他不算特别聪明，就让他做一些辅助性的工作，统计一下数据，做一下用户反弹之类，但现在他已经是一家十亿美金公司的副总裁。 后来我想想，他的特点就是肯去做，负责任，从不推诿，只要有机会承担的事情，他总尽可能地做好。每次也不算做得特别好，但我们总是给他反馈。他去了那家公司后，把一个用户量不足 10 万的边缘频道负责起来，越做越好。由于是边缘频道，没有配备完整的团队，所以他一个人承担了很多职责，也得到了很多锻炼。 第五个特点：对重要的选择要有判断力。选什么专业、选什么公司、选什么职业、选什么发展路径，自己要有判断力，不要被短期选择所左右。比如，原先有很多人愿意去外企，不愿意去新兴公司。 2006 年、2007年的时候，很多师弟、师妹问我职业选择，我都建议他们去百度，不要去IBM、微软。但实际上，很多人都是出于短期考虑：外企可能名气大、薪酬高一点。 虽然这个道理，大家都听过很多遍。刚毕业时薪酬差三五千块，真的可以忽略不计。短期薪酬差别并不重要。但实际上，能摆脱这个、能有判断力的人，也不是特别多。","categories":[{"name":"大佬经历","slug":"大佬经历","permalink":"http://liuhaotian.top/categories/%E5%A4%A7%E4%BD%AC%E7%BB%8F%E5%8E%86/"}],"tags":[{"name":"大佬经历","slug":"大佬经历","permalink":"http://liuhaotian.top/tags/%E5%A4%A7%E4%BD%AC%E7%BB%8F%E5%8E%86/"}]},{"title":"黄峥：我的人生经历和创业理念","slug":"黄峥：我的人生经历和创业理念","date":"2020-06-21T15:23:40.000Z","updated":"2020-06-21T15:39:14.332Z","comments":true,"path":"2020/06/21/黄峥：我的人生经历和创业理念/","link":"","permalink":"http://liuhaotian.top/2020/06/21/%E9%BB%84%E5%B3%A5%EF%BC%9A%E6%88%91%E7%9A%84%E4%BA%BA%E7%94%9F%E7%BB%8F%E5%8E%86%E5%92%8C%E5%88%9B%E4%B8%9A%E7%90%86%E5%BF%B5/","excerpt":"","text":"YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS. 黄峥，浙江杭州人。拼多多创始人、董事长兼首席执行官。2002年，本科毕业于浙江大学，2004年获得美国威斯康星大学麦迪逊分校计算机硕士学位，随后加入美国谷歌。2006年回国，参与谷歌中国办公室的创立。2007年，从谷歌离职创业，先后创立电商代运营公司和游戏公司。2015年4月，创立拼好货，开创社交电商新模式。2016年9月，拼好货、拼多多宣布合并，黄峥担任新公司的董事长兼首席执行官。2020年4月6日，黄峥以1280亿元人民币财富名列《胡润全球百强企业家》第53位 。2020年5月12日，黄峥以1368.4亿元人民币财富名列《2020新财富500富人榜》第8位。 黄峥：我的人生经历和创业理念分享一篇黄峥故事，有点长，耐心读 人生经历篇上学小时候谈不上贫穷，但比较拮据，小时候经常要穿妈妈同事或者是亲戚家小孩的衣服。很多消费习惯和前期的家庭环境有很大关系，跟现在拥有的财富没太大关联。比如我妈到现在都舍不得打车，她会觉得时间又不值钱，太浪费了。这个对我一直有很大影响，包括影响我思考做商业，我脑子里一直都记着我爸妈这样的普通家庭，他们是怎么思考的，他们是怎么生活的。 我的小学很一般，但考上了杭州最好的中学之一，杭州外国语学校。相比于其他中学，接受西方文化影响更早，程度也更深。杭外毕业后被保送到浙大混合班，也就是浙大竺可桢学院的前身。 我在上学时就意识到几个事。一是寒门出贵子是小概率事件，大部分富二代，尤其是官二代非常优秀。二是田忌赛马，在整体资源劣势的情况下可以创造出局部优势，进而有机会获得整个战役的胜利。基于此，平凡人可以成就平凡事。第三是钱是工具，不是目的。 我在上学时有一个较大的遗憾，就是自己目标导向太明确，在追求第一、努力做个好学生上浪费了过多时间，损失了逆反、捣蛋的青春时光，后来才慢慢悟到“60分万岁是个好哲学”。 工作我第一个实习的公司是微软，但毕业时没有留在微软。一是觉得自己留在微软能看到自己十年后的样子。另外，“人生导师”介绍我去当时还不成熟的Google。所以我就在Google做程序员和产品经理，后来还成为Google第一批回国员工参与Google中国的初创阶段。 我对Google有一些个人的观察。 一是Google非常重意识形态，当意识形态发生冲突时，反应超出一般商业公司。 二是Google鼓励基层创新，但核心权力高度集中，有集中办大事的制度优势。 三是Google的“不作恶”深入到了基因，把使命、价值观放在了利润之前，而利润只是随着做正确的事带来的副产品。 四是Google的大部分收购很成功，这些收购案例大多是收购了拥有很好团队的小公司，这些小公司融入到Google的文化逐渐变大。不过也有很多事是Google无力改变的，比如Google没有逃脱层层职业经理人的管理模式，Google在社交上的尝试也不成功。 投资2002年我去美国读研究生认识了段永平，毕业后在Google工作时又离他家很近，所以开始帮他做一些投资。 创业我最早创业做的是电商代运营和游戏公司，对于商业来说，只有赚钱才是道德的，应该按照商业的逻辑去做一个本分的商人。 我为什么要再次创业？一是我还喜欢当前的事和团队，我很喜欢深度的和一帮自己喜欢的小伙伴披荆斩棘的创造一些东西。第二是自己还有一些野心，还有一些能力和能量没有释放，隐约觉得当前的机会能让自己做出一个影响面更大、成就感更强的事。 创业理念篇 拼多多 核心理念消费升级不是让上海人去过巴黎人的生活，而是让安徽安庆的人有厨纸用，有好水果吃。 只有北京五环内的人才会说移动互联网第三波人口带来的是下沉人群，拼多多关注的是中国最广大的老百姓。移动互联网未必是用户的下沉，而是用户拉平了，它让最广大的中国老百姓拥有了和一线城市一样信息获取的能力和交易能力，这是PC时代做不到的。 拼多多吸引的是追求高性价比的人群，他会买一个爱马仕的包，也会用9.9元买一箱芒果，这跟消费能力没关系。实惠这件事，是一个普适性的需求。比如我妈已经算是一个有钱的妈妈，但她出去买菜、买纸巾，还是会在乎一两块钱的差异，但她同时也买高配的iPhone。传统公司采用一二三线来划分人，拼多多满足的是一个人的很多面。 低价只是拼多多阶段性获取用户的方式，拼多多对性价比的理解是“始终在消费者的期待之外”，拼多多的核心不是便宜，而是满足用户占便宜的感觉。 拼多多试图做消费和娱乐的融合，拼多多的使命就是多实惠多乐趣，让消费者买到更多更实惠的东西，然后在这个过程中更快乐。 拼多多的核心竞争力就是五环内的人群理解不了。 运营情况现阶段拼多多对整个商品和服务的品质管控都很初级，拼多多正在通过升级供应链和打击假货来提高商品质量。 部分员工对公司的理解依然是流量至上，这些员工在流量思维环境里受了多年教育，拼多多成立不久，和员工的统一思想还没做得很好，得从上往下贯彻。现在的情况是我在这一头，整个社会和媒体在流量的那一头，员工可能在中间。 拼多多对运营员工的考核是留存、复购第一，GMV第二。（gmv即Gross Merchandise Volume，主要是指网站的成交金额，而这里的成交金额包括：付款金额和未付款。） 未来发展拼多多不会做采销，也不会做物流和配送，对供应链升级是拼多多长期的战略重点。拼多多的最终模式是使得上游能做批量定制化生产。 全品类扩张依然是传统的流量逻辑，品牌升级也是一个五环内人群俯视的视角。拼多多不一定要品牌升级、要全品类，拼多多要做的事情永远是匹配，让合适的人在合适的场景下买到合适的东西。 拼多多目前没想做服务电商，因为实物电商已经足够大。服务电商是流量思维，即流量灌进来，用不同的服务去消耗这个流量。拼多多的出现就是因为不用旧思维，在以人为先的思维下，先想这个人需要什么。 与竞争对手拼多多与淘宝的模式有本质的不同。淘宝是流量逻辑，主体是搜索，用户要自己去找商品，所以需要海量SKU来满足长尾需求。拼多多代表的是匹配，推荐商品给消费者，SKU有限，但要满足结构性丰富。淘宝一直倡导C2B但做不起来，就是因为淘宝的千人千面相当于个性化搜索，但搜索本身是长尾的，很难做反向定制。而拼多多是把海量流量集中到有限商品里，有了规模之后再反向定制，极大降低成本。这也就是沃尔玛和Costco的差别，拼多多的终级定位就是针对不同的人群做不同的Costco。 拼多多和淘宝是错位竞争，争夺的是同一批用户的不同场景，错位才会成长的更快。拼多多并不想做第二个阿里，拼多多的存在本身就是一种模式，你可以说我low，说我低级，但你无法忽视我。 京东、唯品会和蘑菇街都试验过类似拼多多的模式，但对它们来说，拼团只是一个创造GMV增长工具，拼多多是人的逻辑，通过拼团了解人，通过人推荐物，后期会过渡到机器推荐物。拼多多在APP里几乎没有搜索，也不设购物车，可以想象把今日头条下的信息流换成商品流就是拼多多。 与腾讯的关系我认为腾讯并没有扶持拼多多，因为拼多多也被封了很多次。京东和蘑菇街可以在微信的入口做微选，但是拼多多没法做。2018年前拼多多和腾讯签署了一份互不挖猎协议，拼多多要挖腾讯的人，只有腾讯同意才可以。腾讯更像是一个普通的财务投资人，不会有特殊的好与不好，我不认为拼多多是腾讯系。 当出现谣言说拼多多诈骗，并在微信群广泛传播时，我寻求微信的帮助被拒绝，微信说如果是阿里来找就能处理。我认为微信帮拼多多，群众会说因为腾讯是拼多多的股东，微信帮阿里辟谣就叫格局高。 腾讯的儿子太多，即便拼多多死了腾讯依然不会死。腾讯投资拼多多的逻辑不是为了和阿里强竞争，更多的是商人逻辑，因为投资拼多多有回报，竞争只是商业ROI计算的副产品。 阿里和腾讯对线下零售的占比都很低，当抛开流量思维，聚焦场景时空间依然很大。 腾讯做电商失败的原因是它们认为电商是流量*转换率=GMV，流量逻辑在今天无法成功。 投资和创业巴菲特说买股票就是买part of the company，要有长期持有的心态去寻找好的生意和合伙人。这和创业很像，一方面要关注生意的模式，选择正确的生意模式，要花大量时间去研究这个生意模式的细节。另一方面要挑好的“合伙人”，在投资时要把创始人和CEO当成自己未来的合伙人，看自己是不是愿意和他们长期做事。 投资除了关注好生意，好团队，还需要在乎是否是好价钱，这和创业也很相似，查理芒格让巴菲特意识到该用一个合理的价钱去买好公司，而不是花时间去捡烟蒂（价格便宜，有些残余价值的、但往往不那么好的公司）。同样，一个好的公司应该花力气去解决/克服那些正确又难的问题，而不是四处捡一大堆芝麻。 投资另一个和价钱相关的点是看这个deal in loss是否整体可以承受，从创业的角度看就是投入一个事业的时候要看会不会把自己搞死，活着是创业的第一要务。同时又要用另一个角度来评估，即能不能赢，有没有足够的力量去赢。 和投资特别要关注商业模型一样，创业本身对行业及生意模式的选择也往往决定了很大一部分结果，也就是要花大量时间去研究什么是正确的事，然后再想如何把事做正确。在正确的方向上逐步前进远比在不正确的方向狂奔要好。创业很多时候和投资一样，选择比努力重要。在正确的道路上前行哪怕慢一点，但像投资中复利的连续回报也是很厉害的。 巴菲特在谈到投资标的时候，经常会提到生意的护城河。如果把创业过程中的各种决策都当做是投资决策，那我们得分辨我们用时间和钱换来的东西哪些是资产，哪些是费用。那些随着时间流逝，对加深生意护城河有利的往往是“资产”，那些时间越久对自己越不利的可以看成是费用。在资产的购置上，错误的浪费其实是不太会的，最多只是买贵了一些。而在费用的浪费上则非常可恶，往往还有负作用。 思维方式篇认知能力对于未知领域，我通常会采取比较原始的办法，就是自己去体验和感受，用常识来判断。大部分知识是没用的，遇到问题再解决问题。我不会去规划未来五年、十年，我会想一个很远的目标和很近的目标。 绝大多数人在绝大多数方面都比我强，我只在很少的方面比很少的人强。比如隔绝外部压力，回归本源理性思考的能力，有时候有点逆向思考的能力。以前做二级市场发现自己好像天生不太容易在很多人恐惧的时候恐惧，而容易在大众热情的时候悲观。 对电影院现象的思考劣币驱逐良币侧面描述的是自私不团结的个体无法对抗管理者的强制力的现象。另一个角度来说，也描述了通过利用个体自私的力量来进行财富重新分配降低公共服务成本的一种现象。电影院现象和劣币驱逐良币类似，但其实它描述的是一个没有组织，又缺乏外部强制力的自私个体的群体，可能出现的一种集体自我伤害的现象。如果电影院前排人站起来，后排的人也会站起来，结果就破坏了大家本可以坐着看的秩序。也就是说，“劣币驱逐良币”是一股力量战胜另一股力量推动劣币的普及，而电影院现象是一个群体自我伤害的现象，谁都没有真正获益，更加值得研究和应对。 电影院先站起来的那部分人，就像是掉进汤里的一粒屎，很快整锅汤就只能倒掉，这是指出的是一个比例问题。汤其实有自我净化能力，如果比例低没问题，但这个比例只要上升到一个临界点，原有的净化能力就崩溃了。坏一锅汤的一粒屎的大小的临界点是很低的，也许是百分之一和百分之五的区别。百分之一能净化，百分之五就只能全部扔掉了。很多时候，质变就是在这1%到5%之间。在商业上，Amazon在图书份额远低过50%就实质决定了图书的定价进而颠覆了图书零售业。 为什么有的东西贵了反而好卖？比如空调这种产品既需要有人安装，又需要有人推荐。有可能类似小米的互联网直销，把价格打到最低点还不如格力给安装者、渠道以足够利润。虽然看起来渠道的做法抬高了商品的价钱，但在实践中，渠道和服务成本也许是维护某种公共认识最节省、良性的做法。这种渠道和服务成本是必须的，它把维护某种秩序的代价体现在明处，而忽略了这种代价的体系可能会走向“劣币驱逐良币”。 对供给侧需求侧的思考要从根本上变革供给侧，得先变革需求侧。 第一类供给侧的变革是满足了一直存在却未被完全满足的需求，比如有人想飞，就诞生了飞机满足飞的需求。 第二类供给侧的变革源于新的应用场景的出现。比如在世界大战这种突发场景下，衣服以及很多其他生活用品被成批量、大规模、标准化的需要，推动了供给侧生产组织、管理和交付流通上的极大变革。 第三种供给侧的变革源发于信息收集成本大幅变化，比如Uber的出现大幅降低了收集路线、位置以及打车需求的归集成本。 第三类变革存在着大量的可能性拿时间和空间的统一来换取整体效率更高，成本更低。抽象来说，存在一个通过推动需求流通侧更多的采用计划，以此来推动供给侧打破滞后的大规模生产实现中小规模批量的“定制”的半市场经济的可能，即用需求流通侧的半“计划经济”来推动实现供给侧的半“市场经济”。 线上电子商业解决了把义乌小商品市场搬到网上的问题，流通侧的信息高度透明化，加速了各商贩之间的竞争，但对传统制造业的工厂改变不多，工厂生产还是要一些计划，主体的工厂主要还是依赖于线下商超的批量订单，按几个月甚至半年一年的周期在排计划。线上的商贩竞争越激烈，越市场化，和线下生产计划的脱节和对比也越厉害，国际需求的批量外贸订单的计划和线上零售卖的订单之间的脱节也越厉害。这种情况下，主体的工厂主要还是依赖于沃尔玛、家乐福，线上纯流通侧的极度市场化也不改变生产侧计划的滞后性和高度计划性。 存不存在一种模型能改变生产侧的滞后性和高度的刚性计划性？假设我们能让前端消费者多一点耐心及和其他人协调的愿望，放弃一部分所见即所得、现在马上要的冲动，那么我们就有机会利用人和人推荐、人和人之间关系、兴趣的相似点，做人以群分的归并，把每个人人性化的需求归集成有一定时间富裕度的计划性需求。这种需求的归集程度也许没有像沃尔玛这种半年期的批量订单那么大，但也够让工厂一条产线经济的运转。如果能这样做，流通侧线上高度市场化和生产侧刚性计划的矛盾也就能缓解。更多计划性的需求和更多市场的供给侧相融合，前后端信息会更全面的打通，消除需求和生产的错配，帮助我们摆脱对传统类沃尔玛商超的依赖，实现从滞后的计划走向与需求同步的半市场化。 对财富转移的思考保险这种产品进一步促进了财富从没钱人向有钱人的转移，进一步放大了资本的力量。如此下去，如果市场是高度有效不受干扰的，法律是保障资本及其复利的合法性的，那么很可能会使得富的人越富，穷的人越穷。 巴菲特之所以能让人敬佩。主要在于他除了能把资本的游戏玩到极致，更加清楚钱不是目的。他一方面享受着资本游戏的快乐，另一方面把绝大多数钱捐给了比尔盖茨基金会，完成财富应有的再分配。同时，他还倡议其他富人也把钱捐出来，倡议国家提高富人的税收，从机制上进行更大力度的财富再分配。 存不存在一些机制让穷人也能卖“保险”给富人，从而实现更精细化的反馈，周期更短的钱从富人向穷人回流的循环呢？比如说有一千人在夏天的时候就想到在冬天的时候要买一件某种样子的羽绒衣，将联名订单给生产厂商，并愿意按去年的价格出10%的订金。这种情况下，工厂很有可能是愿意给他们30%的折扣的。因为工厂从联名订单里获得了一个工厂原来不具有的一种需求的确定性。这种确定性可以转变为利用生产计划低谷进行生产的便利，也可以转化为采购原材料时候的笃定。工厂甚至可以把这种确定性进一步售卖给上游和配套厂商使得成本进一步降低。 每个人（无论是穷人还是富人）对自己的意愿，对于自己在未来某个点的需求和规划比其他人要清楚得多，这种个人规划和意愿，以及个体对自身某个行为的确定性的把握，对供给方往往是有价值的，它可以降低组织生产的不确定性，可以帮助实现资源以及资本的更有效配置。因此我猜想资本家和富人是愿意向普通人、穷人反购这种成本的。这种反向保险不再是穷人积累信用和钱向富人借钱付利息或者是花钱给富人买生活的确定性，而是反过来，富人、资本家出钱给普通人、穷人买他的生产资本配置的确定性。 从何处获取力量段永平在商业和人生给我的启示是，他说快就是慢，慢就是快。用平常心来做事情会更好，平常人其实很难有平常心。段永平是一个不断学习不断进步的人。他还教给我一个商业常识，就是价格一定会波动，但只要你的价值提升，最终价格会和价值接近。这个常识让你安心于增加企业的内生价值，不要过度在意资本市场的价格波动。此外，段永平教我要胸无大志，做好当前就好。 阿里巴巴创始人之一孙彤宇对我的帮助是，他对平台的理解不一样，比如他认为平台更应该考虑不用阶段的生态演进，而品牌是单个细分人群标新立异的价值主张。 2006年，段永平带上我去参加巴菲特的午餐。我发现巴菲特讲的东西其实特别简单，连我母亲都能听懂。这顿饭最大的意义可能让我意识到简单和常识的力量。对一件事做判断时，你需要了解背景和事实，了解之后需要的不是睿智，而是面对事实时是否还有勇气用理性和常识来判断。常识显而易见、容易理解，但我们因为成长、学习形成的偏见和个人利益的诉求蒙蔽了我们。 读完罗素的《幸福之路》，我总结了几点， 一是要有勇气去面对尝试，用常识做理性的判断，用理性的意念指导自己的行动。 二是要对成就一个无限完美的自己的兴趣，转移为对外部可观事物的兴趣。 三是对不可改变，不可能征服的事要学会放弃。 佛学、量子力学和数理逻辑的不完备定理告诉我们两件事， 一是世界是不可知的，至少是不可精确度量的，是测不准的，是不确定的。 二是用有限的规则去描述规范世界是不可能的，事情是不完美的，不完备的。 除了拼多多，我最希望在未来能转型成真正意义上的科研人员，像富兰克林在40岁以后就不参与商业了，参与科研发明了避雷针，我觉得非营利性的全心全意的科研工作对人类的贡献会更大。","categories":[{"name":"大佬经历","slug":"大佬经历","permalink":"http://liuhaotian.top/categories/%E5%A4%A7%E4%BD%AC%E7%BB%8F%E5%8E%86/"}],"tags":[{"name":"大佬经历","slug":"大佬经历","permalink":"http://liuhaotian.top/tags/%E5%A4%A7%E4%BD%AC%E7%BB%8F%E5%8E%86/"}]},{"title":"2020/6/12未来规划粗略总结","slug":"2020-6-12未来规划粗略总结","date":"2020-06-12T15:49:11.000Z","updated":"2020-06-12T15:50:53.034Z","comments":true,"path":"2020/06/12/2020-6-12未来规划粗略总结/","link":"","permalink":"http://liuhaotian.top/2020/06/12/2020-6-12%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92%E7%B2%97%E7%95%A5%E6%80%BB%E7%BB%93/","excerpt":"","text":"YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS. 个人未来规划以及此公众号发展方向的一些调整因为我正在学习数据结构与算法，所以目前会把这方面做好，所以陆续会出文章讲解这方面的知识，由于我是搞ACM的，所以所有文章都是以竞赛的标准去总结的，所以无论各位读者的目的是为了工作还是为了学校学习的绩点，甚至是某些照顾我的前辈读者，我相信且有信心大家能从中收获许多 转眼间我已经快大二了，ACM是个无底洞，不能一直搞，得留一条后路 ACM能拿到成绩保研最好，准备的后路就是毕业工作，争取进大厂，银牌可能保研去不上好学校，但银牌起码是大厂一块基本的敲门砖，所以我的成绩起码为银牌 这都是后话，既然我热爱ACM，热爱算法，能投身于此，已经足够快乐了，不是吗 虽然说是留一条后路，但是计算机网络、数据库、操作系统那些东西对我而言并不是枯燥无味的，我和爱ACM一样热爱他们，因为它们都属于编程这一类，所以学起来应该没问题 我计划利用大一这即将到来的最后一个长假，来把ACM基础算法啃完，至少啃完一本基础的竞赛书，并做足够的题 至于编程之路，算法只是其中的一小部分，我目前还掌握一些SQL语句、计算机网络基础、python基本语法、C/C++基本语法、java基本语法，其中语言只有C++由系统学习过，读完一本大砖头《C++PrimerPlus》，别的语言没有看过经典书、只是看了入门书或者视频 目前阶段是搞算法竞赛，等到大二开始就每天抽出五小时准备后路（深入编程之路），个人方向还没有选好，先挑基础的开始学习，如linux操作系统，虽然已经明确python不是自己未来主流语言，但是还是决定从大二开始也要逐渐深入python（花闲余时间） 至于大三，就开始去找实习了，这就是目前的规划了，希望有建议的前辈指教 今天早睡，哈哈，明天开始我的复国大计","categories":[{"name":"随笔","slug":"随笔","permalink":"http://liuhaotian.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://liuhaotian.top/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2020/6/12博客更新总结","slug":"2020-6-12博客更新总结","date":"2020-06-12T15:03:53.000Z","updated":"2020-06-12T15:17:04.106Z","comments":true,"path":"2020/06/12/2020-6-12博客更新总结/","link":"","permalink":"http://liuhaotian.top/2020/06/12/2020-6-12%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%80%BB%E7%BB%93/","excerpt":"","text":"2020/6/12博客更新总结觉得博客太乱了，文章发布的太频繁，所以把一些文章合并了，也重新整理了一下标签和分类 分类 ACM C/C++ CODEFORCES LEETCODE PYTHON 博客搭建 计算机网络 目前的分类就这么多，日后还会再加 标签 C/C++常用API CODEFORCES/比赛 LEETCODE/比赛 PYTHON语法 力扣/python 博客搭建 算法竞赛进阶指南 计算机网络 日后还会添加具体算法的标签，例如： bfs dfs trie two points sort 重点改进把python解力扣的文章合为一起，每一百篇题解算一篇文章，这样就减去了一些水文","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"0x13链表与邻接表","slug":"0x13链表与邻接表","date":"2020-06-11T08:51:49.000Z","updated":"2020-06-13T01:40:29.345Z","comments":true,"path":"2020/06/11/0x13链表与邻接表/","link":"","permalink":"http://liuhaotian.top/2020/06/11/0x13%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/","excerpt":"","text":"0x13链表与邻接表链表为了避免双向链表在左右两端或者空链表中访问越界，我们通常建立额外的两个节点head与tail代表链表头尾，把实际数据节点存储在head与tail之间，来减少链表边界处的判断，降低编程复杂度 ACWING136.邻值查找解法一：链表 读入数据后串成链表，再对数组排序，此时找第N个数的前驱和后继，比较N与前驱、后继的差的绝对值，得到目标值后，再删除N，继续找N-1的前驱、后继，时间复杂度为O(NlogN) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longtypedef pair&lt;int, int&gt; PII;const int N = 1e5 + 10;int n;int l[N], r[N];int p[N];PII a[N], ans[N];int32_t main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i].first; a[i].second = i; &#125; sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; i++) &#123; l[i] = i - 1, r[i] = i + 1; p[a[i].second] = i; &#125; a[0].first = 0xffffffff; a[n + 1].first = 0xffffffff; for (int i = n; i &gt; 1; i--) &#123; int j = p[i], left = l[j], right = r[j]; int lv = abs(a[left].first - a[j].first); int rv = abs(a[right].first - a[j].first); if (lv &lt;= rv) ans[i] = &#123;lv, a[left].second&#125;; else ans[i] = &#123;rv, a[right].second&#125;; l[right] = left, r[left] = right; &#125; for (int i = 2; i &lt;= n; i++) cout &lt;&lt; ans[i].first &lt;&lt; \" \" &lt;&lt; ans[i].second &lt;&lt; endl; &#125; 解法二：平衡树 把A1 A2 A3 ... An依次插入一个集合，则在插入Ai之前，集合中保存的就是满足1&lt;=J&lt;i的所有Aj。根据题意，我们只需在集合中查找与Ai最接近的值 若能维护一个有序集合，则集合中与Ai最接近的值一定在Ai的前驱与后继当中，比较前驱与后继与Ai的差即可 而平衡二叉树就是一个支持动态插入、查询前驱以及查询后继的数据结构。在C++中，STLset也为我们提供了这些功能 邻接表邻接表是树与图的一般化存储方式，还能用于实现开散列Hash表。实际上，邻接表可以看成“带有索引数组的多个数据链表”构成的结构集合。在这样的结构中存储的数据会被分成若干类，每一类的数据构成一个链表，每一类还有一个代表元素，称为该类对应链表的表头。所有表头构成一个表头数组，作为一个可以随机访问的索引，从而可以通过表头数组定位到每一类数据对应的链表 在一个具有N个点M条边的有向图结构中，我们可以把每条边所属的“类别”定义为该边的起点标号。这样所有边被分为N类，其中第X类就由“从X出发的所有边”组成。通过表头head[X]，我们很容易定位到第X类对应的链表，从而访问从点X出发的所有边 对于无向图，我们把每条无向边看作两条有向边插入即可。有一个小技巧是，结合成对变换的位运算性质，我们可以在程序最开始时，把第一条边存储在2 3位置上，这样每条边都会存储在2 3 4 5这样的位置上。通过对下标进行XOR 1的运算，就可以直接定位到与当前边反向的边。换句话说，如果ver[i]时第i条边的终点，那么ver[i xor 1]时第i条边的起点","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"0x21树与图的遍历","slug":"0x21树与图的遍历","date":"2020-06-11T06:09:11.000Z","updated":"2020-06-12T14:51:28.429Z","comments":true,"path":"2020/06/11/0x21树与图的遍历/","link":"","permalink":"http://liuhaotian.top/2020/06/11/0x21%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"CODEFORCES/ROUND/648/DIV2","slug":"CODEFORCES-ROUND-648-DIV2","date":"2020-06-10T09:10:45.000Z","updated":"2020-06-12T14:39:46.676Z","comments":true,"path":"2020/06/10/CODEFORCES-ROUND-648-DIV2/","link":"","permalink":"http://liuhaotian.top/2020/06/10/CODEFORCES-ROUND-648-DIV2/","excerpt":"","text":"CODEFORCES/ROUND/648/DIV2A.Matrix Game难度1100，标签：implementation 描述有一个n乘m的矩阵，由0和1组成，当一个0的同行同列没有1时，可以把这个0变为1，两个人轮流把0变成1，最后无法执行此操作的人输（也就是轮到某一人时，此时矩阵上剩余的0都无法变成1，此人输） 第一行输入测试次数，每次测试第一行输入n和m，然后n行输入矩阵元素（每行m个），输出最后获胜者 思路思维题，读入的时候记录一下1所占的行和列数，用总的n和m减去行和列数求得剩余的行和列数，之后每翻一个0，此剩余的行数和列数减一，所以能翻的0的个数就是min(剩余的行数,剩余的列数)，用此最小值判断奇偶即可求出获胜者 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint32_t main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; set&lt;int&gt; a; set&lt;int&gt; b; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int temp; cin &gt;&gt; temp; if (temp == 1) &#123; a.insert(i); b.insert(j); &#125; &#125; &#125; int aa = n - a.size(); int bb = m - b.size(); int c = min(aa, bb); if (c % 2 == 0) cout &lt;&lt; \"Vivek\" &lt;&lt; endl; else cout &lt;&lt; \"Ashish\" &lt;&lt; endl; &#125; return 0;&#125; B.Trouble Sort难度1300，标签：implementation 题目第一行输入测试数目，每次测试输入一个数N，代表数组的元素，接下来一行输入N的值代表数组中的元素，再下一行输入N个0或1代表此数组元素的类型，类型不同的元素可以交换，问能否通过交换让此数组变成升序排列 思路当这N个数由0和1组成时，一定可以换成升序排列，因为只要有一对类型不一样的值，它们就可以无限换，当这N个数全为0或1组成时，特判一下原本的数组是否为升序排序 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 550;int a1[N], a2[N];int32_t main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; memset(a1, 0, sizeof a1); memset(a2, 0, sizeof a2); for (int i = 0; i &lt; n; i++) cin &gt;&gt; a1[i], a2[i] = a1[i]; int flag0 = 0, flag1 = 0; for (int i = 0; i &lt; n; i++) &#123; int temp; cin &gt;&gt; temp; if (temp == 0) flag0 = 1; else flag1 = 1; &#125; if (flag0 == 1 &amp;&amp; flag1 == 1) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else &#123; sort(a1, a1 + n); int x = 0; for (int i = 0; i &lt; n; i++) &#123; if (a1[i] != a2[i]) &#123;cout &lt;&lt; \"No\" &lt;&lt; endl; x = 1; break;&#125;; &#125; if (x==0) cout &lt;&lt; \"Yes\" &lt;&lt; endl; &#125; &#125; return 0;&#125; C.Rotation Matching难度1400，标签：implementation 题目输入一个数N，接下来两行每行输入N个数，代表数组A和B，A和B的元素值相同，但顺序不同，如果A和B数组下标相同的元素值相同，则称这两个元素相等，求执行某些操作后A数组中的元素与B数组中的元素相等的个数的最大值。操作为：把A或B数组的元素全部向左或向右循环移动任意位，如A为1 2 3则向左移动1位为2 3 1 思路与其让两个数组移动，不如让一个数组固定，另一个数组移动，因为数据范围的限制，我们只能用O(N)的时间复杂度，假设我们规定都向右移，移动的数组为A，那么我们用哈希表记录A中每个元素向右移动到B中对应值的位数，最后取相同位数出现最多的次数即可 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 2e5 + 10;int b[N];map&lt;int, int&gt; a;int32_t main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; int temp; cin &gt;&gt; temp; a[temp] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; int temp; cin &gt;&gt; temp; b[(a[temp] - i + n) % n]++; &#125; int ans = -1; for (int i = 0; i &lt;= n; i++) &#123; ans = max(ans, b[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; D.Solve The Maze难度1700，标签：bfs 题目给你一个矩阵，G代表好人，B代表坏人，#代表墙，.代表空，你可以在.的地方加上墙，问能否让好人都到达矩阵的右下角，坏人都不能到达矩阵的右下角，输入的矩阵的右下角一定为.，其中G、B、.可以穿过，墙不能穿过，好人坏人只能上下左右移动 思路先把坏人四周加上墙，然后从右下角BFS检查能否到达所有好人，而不能到达所有坏人 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl \"\\n\"const int N = 55;int n, m;char arr[N][N];bool istrue(int x, int y) &#123; return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m; &#125;int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;int32_t main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; arr[i][j]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (arr[i][j] == 'B') for (int k = 0; k &lt; 4; k++) &#123; int ni = i + dir[k][0]; int nj = j + dir[k][1]; if (istrue(ni, nj) &amp;&amp; arr[ni][nj] == '.') arr[ni][nj] = '#'; &#125; queue&lt;pair&lt;int, int&gt;&gt; que; bool v[n+5][m+5]; memset(v, 0, sizeof v); if (arr[n][m] == '.') &#123; v[n][m] = 1; que.push(&#123;n, m&#125;); &#125; while (!que.empty()) &#123; pair&lt;int, int&gt; cur = que.front(); que.pop(); for (int k = 0; k &lt; 4; k++) &#123; int ni = cur.first + dir[k][0]; int nj = cur.second + dir[k][1]; if (istrue(ni, nj) &amp;&amp; !v[ni][nj] &amp;&amp; arr[ni][nj] != '#') &#123; que.push(&#123;ni, nj&#125;); v[ni][nj] = 1; &#125; &#125; &#125; bool good = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if ((arr[i][j] == 'G' and !v[i][j]) or (arr[i][j] == 'B' and v[i][j])) &#123; good = 0; break; &#125; cout &lt;&lt; (good ? \"Yes\" : \"No\") &lt;&lt; endl; &#125; return 0;&#125; E.Maximum Subsequence Value难度1900，标签：brute force 题目这道题语言无法形容，直接上图 思路鸽巢原理，当n小于三，k一定小于3，max为1，只要遍历n个数找或运算最大的就行了 当n大于3时，K可能大于3，因为max为k-2，所以三层枚举一定会枚举到一个算i的情况，如果再加一个数，原先是0的一定不能变成1，原先是1的反而可能变成0，范围反而变小，所以枚举3个就能找到最大值了 因为如果枚举3个或运算得到的结果某一位都为0，那么再加一个这一位为1的数，整体这一位也一定不为1，因为max为k-2，最多有两位i为0，三层枚举已经有三个为0了，由于数据范围很小，所以满足时间复杂度 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;#define endl '\\n'typedef long long ll;const int MAXN =505;ll arr[MAXN];int main()&#123; int n; ll ans=0; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; arr[i]; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; for(int k=0;k&lt;n;k++)&#123; ans=max(ans,arr[i]|arr[j]|arr[k]); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; F.Swaps Again难度2100，标签：constructive algorithms 题目给两个数组，可以把两个数组中相同位数的前缀和后缀互换位置，问多次操作后两个数组能否相等 思路做法：把A数组前后对应的放到一个pair里，然后检查B数组前半段的每个元素是否满足每个pair都占一个 证明：先推出来它可以随便交换左边第x和右边第x，然后推出来它可以reverse左边一个区间和右边对称区间。于是对于任意pair可以交换到任意位置，且任意pair内部可以交换 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint32_t main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; map&lt;pair&lt;int, int&gt;, int&gt; pairs; vector&lt;int&gt; a(n), b(n); bool possible = 1; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; if (n % 2 == 1 &amp;&amp; a[n / 2] != b[n / 2]) possible = 0; for (int i = 0; i &lt; n / 2; i++) &#123; pair&lt;int, int&gt; p = &#123;min(a[i], a[n-i-1]), max(a[i],a[n-i-1])&#125;; pairs[p]++; &#125; for (int i = 0; i &lt; n / 2; i++) &#123; pair&lt;int, int&gt; p = &#123;min(b[i], b[n - 1 - i]), max(b[i], b[n - 1 - i])&#125;; if (pairs[p] &lt;= 0) possible = 0; pairs[p]--; &#125; if (possible) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125; G.Secure Password 一道很难的交互题，超出能力范围，以后再写，未完待续","categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"}],"tags":[{"name":"CODEFORCES/比赛","slug":"CODEFORCES-比赛","permalink":"http://liuhaotian.top/tags/CODEFORCES-%E6%AF%94%E8%B5%9B/"}]},{"title":"0x16Trie","slug":"0x16Trie","date":"2020-06-07T07:02:46.000Z","updated":"2020-06-12T14:51:32.310Z","comments":true,"path":"2020/06/07/0x16Trie/","link":"","permalink":"http://liuhaotian.top/2020/06/07/0x16Trie/","excerpt":"","text":"0x16Trie基础知识Trie（字典树）是一种实现字符串快速检索的多叉树结构。Trie的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符C，就沿着当前节点的C字符指针，走到该指针指向的节点。下面我们来详细讨论Trie的基本操作过程 初始化一棵空Trie仅包含一个根节点，该点的字符指针均指向空 插入当需要插入一个字符串S时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符C： 若P的C字符指针指向一个已经存在的节点Q，则令P=Q 若P的C字符指针指向空，则新建一个节点Q，令P的C字符指针指向Q，然后令P=Q 当S中的字符扫描完毕时，在当前P节点上标记它是一个字符串的末尾 检索当需要检索一个字符串S在Trie中是否存在时，我们另一个指针P起初指向根节点，然后依次扫描S中的每个字符C 若P的C字符指针指向空，则说明S没有被插入过Trie，结束检索 若P的C字符指针指向一个已经存在的节点Q，则令P=Q 当S中的字符串扫描完毕时，若当前节点P被标记为一个字符串的末尾，则说明S在Trie中存在，否则说明S没有被插入过Trie 在上图所示的例子中，需要插入和检索的字符串都由小写字母构成，所以Trie的每个节点具有26个字符指针，分别为a到z。上图展示了在一棵空树中依次插入cab、cos、car、cat、cate、rain后的Trie形态，绿色标记了单词的末尾节点。可以看出在Trie中，字符数据都体现在树的边（指针）上，树的节点仅保存一些额外信息，例如单词结尾标记等，其空间复杂度是O(NC)，其中N是节点个数，C是字符集的大小 模板123456789101112131415161718192021222324252627int son[N][26], cnt[N], idx;// idx为节点的编号// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p]++;&#125;// 查询字符串出现的次数int query(char *str) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p];&#125; ACWING142.前缀统计把这N个字符串插入一棵Trie树，Trie树的每个节点上存储一个整数cnt，记录该节点是多少个字符串的末尾节点（为了处理插入重复字符串的情况，这里要记录个数，而不能只做结尾标记），对于每个询问，在Trie树中检索要查询的串的每个子串，在检索的过程中累加每次子串查询得到的cnt值，最后得到最终答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;int son[N][26], cnt[N], idx;void insert(string str) &#123; int p = 0; for (int i = 0; str[i]; ++i) &#123; int temp = str[i] - 'a'; if (!son[p][temp]) son[p][temp] = ++idx; p = son[p][temp]; &#125; cnt[p]++;&#125;int query(string str) &#123; int p = 0; for (int i = 0; str[i]; ++i) &#123; int temp = str[i] - 'a'; if (!son[p][temp]) return 0; p = son[p][temp]; &#125; return cnt[p];&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; insert(s); &#125; while (m--) &#123; string s; cin &gt;&gt; s; int ans = 0; for (int i = 0; s[i]; i++) &#123; ans += query(s.substr(0, i + 1)); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 143.最大异或对我们首先想到的是朴素算法，暴力的在所有数中枚举两个数使这两个数做XOR运算的值最大，但是由于数据范围过大，这种算法是超时的，所以我们需要考虑其他思路 朴素的算法是两层嵌套的for循环，我们可以优化朴素算法，借助Trie把第二层for循环从O(N)优化到O(30)，这样其时间复杂度就由O(N*N)变成了O(30*N) 我们可以把每个整数看作其二进制位数为31的01字符串，当数值较小时在前补0（因为题目要求所有数大于0，而最高位存储的是符号位，所以最高位一定为0，做异或运算无意义，因此为31位），我们把把每个数的二进制串插入到Tire中（其中叶子节点为最低位），接下来假如第一重for循环枚举到Ai，那我们需要找到与Ai对应的整数，使其与Ai做异或运算的值最大，当我们从最高位开始找Ai对应的整数时，因为XOR运算“相同得0，不同得1”的性质，我们每次都希望找到与Ai对应位的相反的数（为0找1，为1找0），这样才能使两个数对应位做异或运算后为1，得到的值才尽可能大，如果“与Ai的当前为相反的字符指针”指向空节点，则只好访问与Ai当前位相同的字符指针，这样就可以找到所有数中和Ai做异或运算值最大的数 这就是这道题的思路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int M = 3100000;int son[M][2], a[N], idx;void insert(int x) &#123; int p = 0; for (int i = 30; ~i; --i) &#123; int u = (x &gt;&gt; i) &amp; 1; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125;&#125;int search(int x) &#123; int p = 0, ans = 0; for (int i = 30; ~i; --i) &#123; int u = (x &gt;&gt; i) &amp; 1; if (son[p][!u]) &#123; ans += (1 &lt;&lt; i); p = son[p][!u]; &#125; else &#123; p = son[p][u]; &#125; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; insert(a[i]); &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; ans = max(ans, search(a[i])); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 还差一道题","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"PYTHON中sort()和sorted()的用法","slug":"PYTHON中sort-和sorted-的用法","date":"2020-06-06T17:16:08.000Z","updated":"2020-06-12T14:38:29.271Z","comments":true,"path":"2020/06/07/PYTHON中sort-和sorted-的用法/","link":"","permalink":"http://liuhaotian.top/2020/06/07/PYTHON%E4%B8%ADsort-%E5%92%8Csorted-%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"PYTHON中sort()和sorted()的用法基本形式列表有自己的sort方法，其对列表进行原址排序，既然是原址排序，那显然元组不可能拥有这种方法，因为元组是不可修改的。 123x = [4, 6, 2, 1, 7, 9]x.sort()print x # [1, 2, 4, 6, 7, 9] 如果需要一个排序好的副本，同时保持原有列表不变，怎么实现呢 12345x =[4, 6, 2, 1, 7, 9]y = x[ : ]y.sort()print y #[1, 2, 4, 6, 7, 9]print x #[4, 6, 2, 1, 7, 9] 注意：y = x[:]通过分片操作将列表x的元素全部拷贝给y，如果简单的把x赋值给y：y=x，y和x还是指向同一个列表，并没有产生新的副本 另一种获取已排序的列表副本的方法是使用sorted函数： 1234x =[4, 6, 2, 1, 7, 9]y = sorted(x)print y #[1, 2, 4, 6, 7, 9]print x #[4, 6, 2, 1, 7, 9] sorted返回一个有序的副本，并且类型总是列表，如下： 1print sorted('Python') #['P', 'h', 'n', 'o', 't', 'y'] 可选参数sort方法还有两个可选参数：key和reverse key在使用时必须提供一个排序过程总调用的函数： 123x &#x3D; [&#39;mmm&#39;, &#39;mm&#39;, &#39;mm&#39;, &#39;m&#39; ]x.sort(key &#x3D; len)print x # [&#39;m&#39;, &#39;mm&#39;, &#39;mm&#39;, &#39;mmm&#39;] reverse实现降序排序，需要提供一个布尔值： 123y = [3, 2, 8 ,0 , 1]y.sort(reverse = True)print y #[8, 3, 2, 1, 0] 示例代码1234567891011121314151617181920212223a = [(123,'b',8),(122,'c',3),(128,'a',5)]print(a)# 以元组的第1个元素排序,没有任何参数时，默认是由小到大排序a.sort()print('\\n以元组的第1个元素排序')print(a)a.sort(reverse=True)print(f'由大到小：&#123;a&#125;')# 以元组的第2个元素排序print('\\n以元组的第2个元素排序')a.sort(key=lambda i:i[1])print(a)a.sort(key=lambda i:i[1],reverse=True)print(f'由大到小：&#123;a&#125;')# 以元组的第3个元素排序print('\\n以元组的第3个元素排序')a.sort(key=lambda i:i[2])print(a)a.sort(key=lambda i:i[2],reverse=True)print(f'由大到小：&#123;a&#125;')","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]},{"title":"0x11栈","slug":"0x11栈","date":"2020-06-06T08:47:20.000Z","updated":"2020-06-12T14:51:59.905Z","comments":true,"path":"2020/06/06/0x11栈/","link":"","permalink":"http://liuhaotian.top/2020/06/06/0x11%E6%A0%88/","excerpt":"","text":"0x11栈ACWING41.包含min函数的栈栈结构原本就支持O(1)的入栈、出栈操作，但不支持查询最小值的操作。一个比较直接的思路是，我们知道二叉堆是一种支持插入、取出堆顶、查询最小值的数据结构，如果在维护一个栈的同时再维护一个存储同样元素的二叉堆，就可以支持题目中要求的操作，然而，它的时间复杂度是O(logN)，如果我们只用一个变量记录最小值，当发生出栈操作时，如果最小值恰好被出栈，就无法得知新的最小值是什么。这启发我们使用一个线性结构来保存历史上每个时刻的最小值，这样我们就可以在出栈后进行还原 我们建立两个栈，栈A存储原本的数据、栈B用单调栈来实现，当我们向栈中压入一个数时，如果该数 ≤ 单调栈的栈顶元素，则将该数同时压入单调栈中；否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数，这样所有操作的时间复杂度都是O(1) 123456789101112131415161718192021222324252627282930313233343536class MinStack &#123; public: /** initialize your data structure here. */ stack&lt;int&gt; value; stack&lt;int&gt; minvalue; MinStack() &#123; &#125; void push(int x) &#123; if (minvalue.empty() || x &lt;= minvalue.top()) minvalue.push(x); value.push(x); &#125; void pop() &#123; if (minvalue.top() == value.top()) minvalue.pop(); value.pop(); &#125; int top() &#123; return value.top(); &#125; int getMin() &#123; return minvalue.top(); &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ ACWING128.编辑器本题的特殊点在于，I D L R四种操作都在光标位置处发生，并且操作完成后光标至多移动一个位置，根据这种“始终在序列中间某个指定位置进行修改”的性质，我们不难想到一个对顶栈的做法 建立两个栈，栈L存储从序列开头到当前光标位置的这一段子序列，栈R存储从当前光标位置到序列结尾的这一段子序列，二者都以光标所在的那一端作为栈顶，这两个栈合起来就保存了整个序列。因为查询操作的K不超过光标位置，所以我们用一个动态数组F维护栈L的前缀和最大值即可，通过这两个对顶栈，我们在O(1)的时间内实现了每种操作和询问 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;int l[N], r[N], ll, rr;int f[N], sum[N];void add(int x) &#123; l[++ll] = x; sum[ll] = sum[ll - 1] + x; f[ll] = max(f[ll - 1], sum[ll]);&#125;int main() &#123; int n; cin &gt;&gt; n; char ops[2]; f[0] = INT_MIN; while (n--) &#123; cin &gt;&gt; ops; int x; if (*ops == 'I') &#123; cin &gt;&gt; x; add(x); &#125; else if (*ops == 'D') &#123; if (ll) ll--; &#125; else if (*ops == 'L') &#123; if (ll) r[++rr] = l[ll--]; &#125; else if (*ops == 'R') &#123; if (rr) add(r[rr--]); &#125; else &#123; cin &gt;&gt; x; cout &lt;&lt; f[x] &lt;&lt; endl; &#125; &#125; return 0;&#125; ACWING129. 火车进栈题目要求按字典序输出前20种顺序，我们来看大部分的状态，都可以进行两种操作：第一种，栈顶元素输出；第二种，下一个数字进栈，当我们按照顺序把元素依次进栈时，下一次进栈的元素一定大于栈中的元素和输出的元素，所以为了输出字典序，我们先进行出栈操作，后进行进栈操作，用深搜的过程中，我们需要维护四种state，第一个是输出的元素，第二个是栈中的元素，第三个是未进栈的元素，第四个是已经输出的序列的数量（等于20停止） 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int n, remain = 20;vector&lt;int&gt; path;stack&lt;int&gt; stk;void dfs(int u) &#123; if (!remain) return; if (path.size() == n) &#123; remain--; for (auto x : path) cout &lt;&lt; x; cout &lt;&lt; endl; return; &#125; if (stk.size()) &#123; path.push_back(stk.top()); stk.pop(); dfs(u); stk.push(path.back()); path.pop_back(); &#125; if (u &lt;= n) &#123; stk.push(u); dfs(u + 1); stk.pop(); &#125;&#125;int main() &#123; cin &gt;&gt; n; dfs(1); return 0;&#125; ACWING130.火车进出栈问题 我被这题搞死了，未完待续","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"CODEFORCES/ROUND/647/DIV2","slug":"CODEFORCES-ROUND-647-DIV2","date":"2020-06-05T17:37:03.000Z","updated":"2020-06-12T14:39:57.675Z","comments":true,"path":"2020/06/06/CODEFORCES-ROUND-647-DIV2/","link":"","permalink":"http://liuhaotian.top/2020/06/06/CODEFORCES-ROUND-647-DIV2/","excerpt":"","text":"CODEFORCES/ROUND/647/DIV2A.Johnny and Ancient Computer难度1000，标签：implementation 描述给一个两个正整数，一个初始值，一个目标值，可以对初始值进行位运算，向左移动三位或两位或一位，或者向右移动三位或一位或两位，要求向右移动时必须除尽，舍弃小数部分的右移运算被禁止，求移动到目标值的最小次数，如果无法得到目标值则输出-1 思路如果目标值大于初始值，则左移，反之在可以右移的情况下右移，先移动位数多的，后移动位数小的，移动一次答案加一 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define IOS \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define int long longint32_t main() &#123; IOS; int t; cin &gt;&gt; t; while (t--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; if (a == b) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int nums = 0; if (a &gt; b) &#123; while (a &gt; b) &#123; if (a &gt;&gt; 3 &gt;= b &amp;&amp; a % 8 == 0) &#123; a = a &gt;&gt; 3; nums++; continue; &#125; if (a &gt;&gt; 2 &gt;= b &amp;&amp; a % 4 == 0) &#123; a = a &gt;&gt; 2; nums++; continue; &#125; if (a &gt;&gt; 1 &gt;= b &amp;&amp; a % 2 == 0) &#123; a = a &gt;&gt; 1; nums++; continue; &#125; break; &#125; if (a == b) cout &lt;&lt; nums &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; while (a &lt; b) &#123; if (a &lt;&lt; 3 &lt;= b) &#123; a = a &lt;&lt; 3; nums++; continue; &#125; if (a &lt;&lt; 2 &lt;= b) &#123; a = a &lt;&lt; 2; nums++; continue; &#125; if (a &lt;&lt; 1 &lt;= b) &#123; a = a &lt;&lt; 1; nums++; continue; &#125; break; &#125; if (a == b) cout &lt;&lt; nums &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; &#125; return 0;&#125; B.Johnny and His Hobbies难度1200，标签：brute force 题目给一个集合，里面元素为数字，求一个最小的正整数K，使每个集合的每个元素与K进行XOR运算后集合元素等于原集合元素，意味着集合的元素顺序改变，但元素大小不改变 思路取第一个元素，求分别XOR其他元素的K，再对每个元素异或K，看看运算后的集合是否等于原集合，求出最小的K 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;#define IOS \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define endl \"\\n\"#define int long longint nums[1500];int aa[1500];int bb[1500];int32_t main() &#123; IOS; int t; cin &gt;&gt; t; while (t--) &#123; memset(aa, 0, sizeof aa); int a; cin &gt;&gt; a; int ans = 0x3f3f3f3f; for (int i = 0; i &lt; a; i++) &#123; cin &gt;&gt; nums[i]; aa[nums[i]]++; &#125; int tt = -1; for (int i = 1; i &lt; a; i++) &#123; for (int j = 1; j &lt; 1025; j++) &#123; if ((j ^ nums[0]) == nums[i]) &#123; tt = j; &#125; &#125; if (tt != -1) &#123; memset(bb, 0, sizeof bb); for (int j = 0; j &lt; a; j++) &#123; bb[nums[j] ^ tt]++; &#125; bool flag = true; for (int k = 0; k &lt; 1500; k++) &#123; if (aa[k] != bb[k]) flag = false; &#125; if (flag == true) ans = min(ans, tt); &#125; &#125; if (ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C.Johnny and Another Rating Drop难度1400，标签：math、dp 题目给你一个正整数，问从1到此正整数（设为每个数Ki）的二进制形式与前一位（Ki-1）的二进制形式的每位二进制不一样的数量是多少，如果两个二进制位数不同，用0来填充 假如正整数为5 则0到5的二进制分别为：000 001 010 011 100 101000和001不同的位为最低位，数量为1所以从1到5分别为：1 2 1 3 1，总共为8 思路两种思路：第一种找规律，第二种数位dp 思路1：可以发现最低位二进制一直是01变化，所以其贡献是n，倒数第二位，同理可推出贡献为n/2，所以推到二进制第i位，贡献是n&lt;&lt;(i−1) ，累加就可以了 思路2：打开OEIS，输入数列，求出DP公式，递归即可，香 这里给出思路1的代码 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define IOS \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define endl \"\\n\"#define int long longint32_t main() &#123; IOS; int t; cin &gt;&gt; t; while (t--) &#123; int num; cin &gt;&gt; num; int ans = 0, i = 1; int temp = num; while (num) &#123; ans += temp / i; i *= 2; num &gt;&gt;= 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D.Johnny and Contribution难度1700，标签：greedy，constructive algorithms 题目有个傻逼想写博客，每个文章一个主题，一个主题可以被多个文章写，文章之间可以互相引用，但是互相引用的文章的主题不能相同 这个傻逼写博客有个毛病，写文章时，选择的主题序号要最小，比如一个文章的引用文章的主题为1和3，那么此逼在写这个文章时用的主题序号为2 假设给定文章数目N，从1到N的文章的主题规定为一个序列，现在这个逼从头写文章，问他写文章的次序，如果文章的主题不能达到此序列，输出-1 思路转化为一个图，每个文章为一个节点，文章间的引用当作节点之间的边，主题当作节点的权值 先把所有边记录下来，然后把最后要得到的图的节点按照权值从小到大排序，之后按照节点权值选择先填的节点，在填充节点的过程中，如果此节点填充的值为M，则它的相连节点（且已被填充）的个数必须为M-1，且相连的节点（已填充）的权值必须是从1到M-1，如果不满足则输出-1，最后输出填充的顺序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define forn(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define IOS \\ ios::sync_with_stdio(flase); \\ cin.tie(0); \\ cout.tie(0);#define endl '\\n'const int inf = 0x3f3f3f3f;const int INF = 8e18;const int maxn = 5e5 + 5;vector&lt;int&gt; e[maxn];int a[maxn], p[maxn], ans[maxn];inline bool cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;int32_t main() &#123; //freopen(\"in.txt\", \"r\", stdin); int n, m; cin &gt;&gt; n &gt;&gt; m; forn(i, m) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; e[u].push_back(v); e[v].push_back(u); &#125; for1(i, n) cin &gt;&gt; a[i], p[i] = i; sort(p + 1, p + 1 + n, cmp); for1(i, n) &#123; int u = p[i]; int val = a[u]; set&lt;int&gt; s; for (auto v : e[u]) if (ans[v]) s.insert(ans[v]); if (s.size() != val - 1) return cout &lt;&lt; -1 &lt;&lt; endl, 0; int cnt = 1; for (auto x : s) &#123; if (x != cnt) return cout &lt;&lt; -1 &lt;&lt; endl, 0; ++cnt; &#125; ans[u] = a[u]; &#125; for1(i, n) cout &lt;&lt; p[i] &lt;&lt; \" \"; return 0;&#125; E.Johnny and Grandmaster难度1900，标签：greedy 题目给两个数N和P，输入N个数，把N个数分为两个集合，以P为底，把每个集合的元素作为幂次，把集合的每个元素作为幂次算出来的值相加和为S，求出两个集合的S的差值最小为多少 思路思路1：从大到小枚举p^k，拿一个变量cur记录当前的枚举数字的幂次，dif记录当前集合中的数字的大小是当前枚举的数字的倍数，ans记录最终的值。枚举新一轮的时候，当dif==0的时候说明集合中的所有数字被抵消了或者循环刚开始，那么cur直接等于此次循环枚举数字的幂次即可，ans也直接等于当前的数字的值模mod即可。如果dif!=0说明当前集合不为0，我们就让集合中的数字减去当前枚举的数字，可以考虑把cur先化为跟当前枚举数字的幂次相同，这样dif就会不断乘底数p，如果dif变得大于1e6(也可以精确点写成i),说明当前集合中的数字已经是当前枚举数字的至少1e6倍大，那么就没必要接着枚举了，因为N的长度最大才是1e6，直接减去后面所有的数字即可，因为即使减去了后面所有的数字也一定还有剩余。如果小于1e6，就让dif--（减去当前枚举的这个数字后倍数自然会减一），计算幂时我们用到了快速幂的思想 思路2：开双模数，有一定几率倍卡，但是概率太小忽略不计。首先知道一点，集合中的数字不可能减少为负数。那么每次减少一个数，看两个答案ans1，ans2是否同为0，同为0说明集合中的值被减少为0，然后就加上下一个枚举的数字，然后继续减后面的数字，重复这个过程，最后输出ans1就行了。ans1和ans2是按照不同的模数来算的，ans1的模数是题目要求的模数，ans2的模数是自己随便定的大模数 这里给出思路1的代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;const int P = 1e9 + 7;#define int long longint n, a[maxn];int qpow(int c, int b) &#123; int ans = 1; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) ans = ans * c % P; c = c * c % P; &#125; return ans;&#125;int32_t main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; int p; cin &gt;&gt; n &gt;&gt; p; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; if (p == 1) &#123; cout &lt;&lt; (n &amp; 1LL) &lt;&lt; endl; continue; &#125; sort(a, a + n); int dif = 0, cur = 0, ans = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; if (!dif) &#123; cur = a[i]; dif = 1; ans += qpow(p, a[i]); &#125; else &#123; while (cur &gt; a[i]) &#123; cur --; dif *= p; if (dif &gt; i) break; &#125; if (cur == a[i]) &#123; dif --; ans -= qpow(p, a[i]); &#125; else &#123; for (int j = i; j &gt;= 0; j--) &#123; ans -= qpow(p, a[j]); &#125; break; &#125; &#125; &#125; ans = (ans % P + P) % P; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; F.Johnny and Megan’s Necklace难度2500，标签：dfs and similar 未完待续","categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"}],"tags":[{"name":"CODEFORCES/比赛","slug":"CODEFORCES-比赛","permalink":"http://liuhaotian.top/tags/CODEFORCES-%E6%AF%94%E8%B5%9B/"}]},{"title":"API之to_string用法","slug":"API之to-string用法","date":"2020-06-03T18:49:33.000Z","updated":"2020-06-12T14:39:29.043Z","comments":true,"path":"2020/06/04/API之to-string用法/","link":"","permalink":"http://liuhaotian.top/2020/06/04/API%E4%B9%8Bto-string%E7%94%A8%E6%B3%95/","excerpt":"","text":"API之to_string用法函数原型123456789string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val); 功能将数值转化为字符串。返回对应的字符串。 示例123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string pi = \"pi is \" + std::to_string(3.1415926); string perfect = to_string(1 + 2 + 4 + 7 + 14) + \" is a perfect number\"; cout &lt;&lt; pi &lt;&lt; '\\n'; cout &lt;&lt; perfect &lt;&lt; '\\n'; system(\"pause\"); return 0;&#125; 结果：12pi is 3.14159328 is a perfect number","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://liuhaotian.top/categories/C-C/"}],"tags":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/tags/C-C-%E5%B8%B8%E7%94%A8API/"}]},{"title":"LEETCODE双周赛26","slug":"LEETCODE双周赛26","date":"2020-06-03T17:30:33.000Z","updated":"2020-06-12T14:35:39.906Z","comments":true,"path":"2020/06/04/LEETCODE双周赛26/","link":"","permalink":"http://liuhaotian.top/2020/06/04/LEETCODE%E5%8F%8C%E5%91%A8%E8%B5%9B26/","excerpt":"","text":"LEETCODE双周赛261446.连续字符思路 双指针（滑动窗口） 代码1234567891011121314class Solution &#123;public: int maxPower(string s) &#123; int maxn = -0x3f3f3f3f; for (int i = 0; i &lt; s.size();) &#123; int j = i + 1; while (j &lt; s.size() &amp;&amp; s[i] == s[j]) j++; maxn = max(maxn, j - i); i = j; &#125; return maxn; &#125;&#125;; 1447.最简分数思路 gcd+遍历 代码12345678910111213141516class Solution &#123; int gcd(int x, int y) &#123; return y ? gcd(y, x % y) : x; &#125;public: vector&lt;string&gt; simplifiedFractions(int n) &#123; vector&lt;string&gt; result; for (int i = 1; i &lt; n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; if (gcd(j, i) == 1) result.push_back(to_string(i) + \"/\" + to_string(j)); &#125; &#125; return result; &#125;&#125;; 1448.统计二叉树中好节点的数目思路 简简单单的dfs，记录遍历的节点的最大值 代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int goodNodes(TreeNode* root) &#123; return dfs(root, INT_MIN); &#125; int dfs(TreeNode* root, int maxn) &#123; if (!root) return 0; int ans = maxn &lt;= root-&gt;val; if (root-&gt;left) ans += dfs(root-&gt;left, max(maxn, root-&gt;val)); if (root-&gt;right) ans += dfs(root-&gt;right, max(maxn, root-&gt;val)); return ans; &#125;&#125;; 1449.数位成本和为目标值的最大数字思路 完全背包 代码123456789101112131415161718192021222324class Solution &#123; public: string largestNumber(vector&lt;int&gt;&amp; cost, int target) &#123; vector&lt;vector&lt;int&gt;&gt; f(10, vector&lt;int&gt;(target + 1)); for (int i = 1; i &lt;= target; i++) f[0][i] = -1e8; for (int i = 1; i &lt;= 9; i++) for (int j = 0; j &lt;= target; j++) &#123; f[i][j] = f[i - 1][j]; if (j &gt;= cost[i - 1]) f[i][j] = max(f[i][j], f[i][j - cost[i - 1]] + 1); &#125; if (f[9][target] &lt; 1) return \"0\"; string res; for (int i = 9, j = target; i; i--) while (j &gt;= cost[i - 1] &amp;&amp; f[i][j] == f[i][j - cost[i - 1]] + 1) &#123; res += to_string(i); j -= cost[i - 1]; &#125; return res; &#125;&#125;;","categories":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/categories/LEETCODE/"}],"tags":[{"name":"LEETCODE/比赛","slug":"LEETCODE-比赛","permalink":"http://liuhaotian.top/tags/LEETCODE-%E6%AF%94%E8%B5%9B/"}]},{"title":"0x06倍增","slug":"0x06倍增","date":"2020-06-03T11:42:06.000Z","updated":"2020-06-12T14:52:04.422Z","comments":true,"path":"2020/06/03/0x06倍增/","link":"","permalink":"http://liuhaotian.top/2020/06/03/0x06%E5%80%8D%E5%A2%9E/","excerpt":"","text":"0x06倍增基础知识倍增，字面意思就是“成倍的增长”。这是指我们在进行递推时，如果状态空间很大，通常的线性递推无法满足时间与空间复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间中在2的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过“任意整数可以表示成若干个2的次幂项的和”这一性质 ，使用之前求出的代表值拼成所需的值。所以使用倍增算法也要求我们递推的问题的状态空间关于2的次幂具有可划分性 “倍增”与“二进制划分”两个思想相互结合，降低了求解很多问题的时间与空间复杂度。我们之前学习的快速幂其实就是“倍增”与“二进制划分”思想的一种体现。在此文章中，我们研究序列上的倍增问题，包括求解RMQ（区间最值）问题的ST算法，关于求解最近公共祖先LCA等在树上的倍增应用，我将在后续文章进行探讨 试想这样一个问题：给定一个长度为N的数列A，然后进行若干次询问，每次给定一个整数T，求出最大的k，满足数列A中前k个数的和小于等于T。你的算法必须是在线的（必须即时回答每一个询问，不能等待收到所有询问后再统一处理），假设T小于等于数组A中所有数的和 朴素做法当然是从前向后枚举K，每次询问花费的时间与答案的大小有关，最坏情况为O(N) 如果我们能够先花费O(N)的时间预处理A数组的前缀和数组S，就可以二分K的位置，比较S[K]与T的大小来确定二分上下界的变化，每次询问花费的时间都是O(logN)。这个算法在平均情况下表现很好，但是它的缺点是如果每次询问给定的整数T都非常小，造成答案K也非常小，那么该算法可能还不如从前往后枚举更优（因为假如每次只怼前3个，此时O(log)的算法可能不如O(3)的好） 我们可以设计这样一种倍增算法： 令p=1，k=0，sum=0 比较A数组中k之后的p个数的和与T的关系，也就是说，如果sum+S[k+p]-S[k]&lt;=T，则令sum+=S[k+p]-S[k]，k+=p，p*=2，即累加上p个数的和，然后把p的跨度增长一倍，如果sum+S[k+p]-S[k]&gt;T，则另p/=2 重复上一步，直至p的值变为0，此时k就是答案 这个算法始终在答案大小的范围内实施“倍增”与“二进制划分”的思想，通过若干长度为2的次幂的区间拼成最后的k，时间复杂度级别为答案的对数，能够应对T的各种大小情况 ACWING109.天才ACM首先，对于一个集合S，显然应该取S中最大的M个数和最小的M个数，最大的和最小的构成一对、次大和次小构成一对…这样求出的校验值最大。而为了让数组A分成的段数最少，每一段都应该在校验值不超过T的情况下，尽量包含更多的数，所以我们从头开始对A进行分段，让每一段尽量长，到达结尾时分成的段数就是答案 于是，需要解决的问题是：当确定一个左端点L之后，右端点R在满足A[L]到A[R]的校验值不超过T的前提下，最大能取到多少 求长度为N的一段校验值需要排序配对，时间复杂度为O(NlogN)。当校验值上限T比较小时，如果在整个L到N的区间二分右端点R，二分第一步就要检验(N-L)/2这么长的一段，最终右端点R却可能只扩展了一点儿，浪费了很多时间。与上一道题目一样，我们需要一个与右端点R扩展的长度相适应的算法———倍增 可以采用与上一题类似的倍增过程： 初始化p=1，R=L 求出[L,R+p]这一段区间的校验值，若检验值小于等于T，则R+=P，p*=2，否则P/=2 重复上一步，直到p的值变为0，此时R即为所求 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define fir(i, a, b) for (int i = a; i &lt;= b; i++)#define sqr(a) (a) * (a)#define IOS \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);const int N = 5e5 + 10;int n, m, p[N], ans, l, r;ll b[N], a[N], k;void merge(int l, int mid, int r) &#123; int i = l, j = mid, k = l; while (i &lt; mid &amp;&amp; j &lt;= r) if (a[i] &lt;= a[j]) b[k++] = a[i++]; else b[k++] = a[j++]; while (i &lt; mid) b[k++] = a[i++]; while (j &lt;= r) b[k++] = a[j++];&#125;bool check(int l, int mid, int r) &#123; fir(i, mid, r) a[i] = p[i]; sort(a + mid, a + r + 1); merge(l, mid, r); ll sum = 0; for (int i = 1; i &lt;= r - l + 1 &gt;&gt; 1 &amp;&amp; i &lt;= m; i++) sum += sqr(b[r - i + 1] - b[l + i - 1]); if (sum &lt;= k) &#123; for (int i = l; i &lt;= r; i++) a[i] = b[i]; return true; &#125; else return false;&#125;void init() &#123; l = r = 0; ans = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; fir(i, 1, n) cin &gt;&gt; p[i];&#125;void work() &#123; int len = 1; l = r = 1; a[l] = p[l]; while (r &lt;= n) if (!len) &#123; len = 1; ans++; l = (++r); a[l] = p[l]; &#125; else if (r + len &lt;= n &amp;&amp; check(l, r + 1, r + len)) &#123; r += len; len &lt;&lt;= 1; if (r == n) break; &#125; else len &gt;&gt;= 1; if (r == n) ans++;&#125;int main() &#123; IOS; int t; cin &gt;&gt; t; while (t--) &#123; init(); work(); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 这题的代码差点儿把我杀死，不写了，未完待续","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"力扣python题解(1-100题)","slug":"力扣python题解-1-100题","date":"2020-06-03T01:27:56.000Z","updated":"2020-06-12T14:36:15.917Z","comments":true,"path":"2020/06/03/力扣python题解-1-100题/","link":"","permalink":"http://liuhaotian.top/2020/06/03/%E5%8A%9B%E6%89%A3python%E9%A2%98%E8%A7%A3-1-100%E9%A2%98/","excerpt":"","text":"1.两数之和12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dic = &#123;&#125; for i in range(len(nums)): if nums[i] in dic: return [dic[nums[i]], i] else: dic[target - nums[i]] = i 2.两数相加123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: dummy = cur =ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //=10 return dummy.next 3.无重复字符的最长子串123456789101112131415class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: d = &#123;&#125; p1 = p2 = m = 0 while p2 &lt; len(s): if s[p2] not in d: d[s[p2]] = True p2 += 1 m = max(len(d), m) else: del d[s[p1]] p1 += 1 return m 4.寻找两个正序数组的中位数12345678910class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: totalList = nums1 + nums2 totalList.sort() if len(totalList) % 2 ==0: i = totalList[len(totalList)//2] j = totalList[len(totalList)//2 - 1] return (i+j)/2 else: return totalList[len(totalList)//2] 5. 最长回文子串1234567891011121314class Solution: def longestPalindrome(self, s: str) -&gt; str: p = '' for i in range(len(s)): p1 = self.get_palindrome(s, i, i+1) p2 = self.get_palindrome(s, i, i) p = max([p, p1, p2], key=lambda x: len(x)) return p def get_palindrome(self, s: str, l: int, r: int) -&gt; str: while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1 r += 1 return s[l+1:r] 6.Z字形变换12345678910111213class Solution: def convert(self, S: str, R: int) -&gt; str: if R == 1 or R &gt; len(S): # corner case return S res, i, step = ['' for r in range(R)], 0, 0 # a string for each line for s in S: res[i] += s if i == 0: # first row step = 1 # down if i == R - 1: # last row step = -1 # up i += step return \"\".join(res) 7.整数反转12345678class Solution: def reverse(self, x: int) -&gt; int: result = int(str(x)[::-1]) if x &gt;= 0 else -int(str(x)[1:][::-1]) if -2**31 &lt;= result &lt;= (2**31)-1: return result else: return 0 8.字符串转换整数12345678910111213141516class Solution: def myAtoi(self, str: str) -&gt; int: def helper(x): if not x: return 0 ret = 0 for i in x: if not i.isdigit(): return ret ret = ret *10 + int(i) return ret s = str.strip() if not s: return 0 elif s[0] == '+': return min(2**31-1,helper(s[1:])) elif s[0] == '-': return max(-2**31,-helper(s[1:])) elif s[0].isdigit(): return min(2**31-1,helper(s)) else: return 0 9.回文数12345678class Solution: def isPalindrome(self, x: int) -&gt; bool: orig = x back_x = 0 while x &gt; 0: back_x = back_x * 10 + x % 10 x //= 10 return orig == back_x 10.正则表达式匹配12345678910111213141516171819class Solution: def isMatch(self, s: str, p: str) -&gt; bool: s, p = ' '+ s, ' '+ p lenS, lenP = len(s), len(p) dp = [[0]*(lenP) for i in range(lenS)] dp[0][0] = 1 for j in range(1, lenP): if p[j] == '*': dp[0][j] = dp[0][j-2] for i in range(1, lenS): for j in range(1, lenP): if p[j] in &#123;s[i], '.'&#125;: dp[i][j] = dp[i-1][j-1] elif p[j] == \"*\": dp[i][j] = dp[i][j-2] or int(dp[i-1][j] and p[j-1] in &#123;s[i], '.'&#125;) return bool(dp[-1][-1]) 11.盛最多水的容器12345678910111213class Solution: def maxArea(self, height: List[int]) -&gt; int: first = 0 second = len(height) - 1 area = 0 while first &lt; second: area = max((second - first) * min(height[first], height[second]), area) if height[first] &lt; height[second]: first+=1 else: second-=1 return area 12.整数转罗马数字123456789101112131415161718192021222324class Solution: def intToRoman(self, num: int) -&gt; str: mapping = &#123; 1: \"I\", 4: \"IV\", 5: \"V\", 9: \"IX\", 10: \"X\", 40: \"XL\", 50: \"L\", 90: \"XC\", 100: \"C\", 400: \"CD\", 500: \"D\", 900: \"CM\", 1000: \"M\", &#125; arr = [1000,900,500,400,100,90,50,40,10,9,5,4,1] result = \"\" for a in arr: while num &gt;= a: num = num - a result = result + mapping[a] return result 13.罗马数字转整数1234567891011class Solution: def romanToInt(self, s: str) -&gt; int: res, prev = 0, 0 dict = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; for i in s[::-1]: if dict[i] &gt;= prev: res += dict[i] else: res -= dict[i] prev = dict[i] return res 14.最长公共前缀12345678910class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: l = list(zip(*strs)) prefix = \"\" for i in l: if len(set(i))==1: prefix += i[0] else: break return prefix 15.三数之和12345678910111213141516171819class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() result = set() for i in range(len(nums)): l = i + 1 r = len(nums) - 1 target = 0 - nums[i] while l &lt; r: if nums[l] + nums[r]== target: result.add((nums[i], nums[l], nums[r])) l += 1 r -= 1 elif nums[l] + nums[r] &lt; target: l += 1 else: r -= 1 return list(result)","categories":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/categories/LEETCODE/"}],"tags":[{"name":"力扣/python","slug":"力扣-python","permalink":"http://liuhaotian.top/tags/%E5%8A%9B%E6%89%A3-python/"}]},{"title":"计算机网络基础总结(1)","slug":"计算机网络基础总结-1","date":"2020-06-02T13:44:17.000Z","updated":"2020-06-12T14:46:59.846Z","comments":true,"path":"2020/06/02/计算机网络基础总结-1/","link":"","permalink":"http://liuhaotian.top/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-1/","excerpt":"","text":"计算机网络基础总结(1) 局域网：覆盖范围小、自己花钱买设备、带宽固定、自己维护、100米、10M 100M 1000M广域网：距离远、花钱租带宽Internet：由ISP组成、有自己的机房、对网民提供访问Internet连接 ISP：Internet服务提供商（Internet service provide） DNS：把网站域名解析成IP地址 子网掩码：告诉计算机哪里是网络部分，哪里是主机部分 路由器的作用是在不同网段转发数据 计算机的网卡有mac地址（物理地址），全球唯一，mac地址在计算机出场时已经被固定在网卡中：48位二进制（12位十六进制） 计算机访问过程： 先把要访问的域名发送给DNS服务器，DNS服务器把域名解析成IP地址返回 数据包由数据、原IP地址、目标IP地址组成 数据帧由数据、原IP地址、目标IP地址、此时的mac地址、下一个目的地的mac地址组成 计算机发送数据帧后，数据帧在运输的过程中两个mac地址不断变化，因此不断重新封装，但是数据包没变 数据帧在运输过程中不断经过路由器，路由器看数据包中的IP地址，决定下一步走哪个mac地址 目标服务器收到请求后，往计算机回传数据，会把数据切割成小块，并给每一块编号，然后取一部分放到目标服务器的缓存当中，再然后在缓存中取出一块，加上此服务器IP地址、目标计算机IP地址、此时的mac地址、下一个目的地的mac开始发送，发送后，此数据块不会被缓存区删除，因为发送的过程中可能会丢失，当目标计算机收到此数据块放到计算机中的缓存区后，发送请求接受下一个数据块的消息到此服务器时，此数据块才会在缓存区被删除 当计算机的缓存满了时，会读取，然后再存缓存 第一张图说明： 第二张图说明： OSI参考模型（国际标准把计算机通信进行的定义） 应用层：所有能产生网络流量的程序 表示层：在传输之前是否进行加密或压缩处理、传的是二进制还是ASCII码 会话层：电脑和某服务器建立起的联系，比如电影前进后退进、查木马都是会话层的体现 netstat -n 命令可在终端查看此电脑建立的会话 传输层：可靠传输（比如某服务器传输数据到计算机、把数据分块传输，如果发送了某一块之后没收到请求下一块的信息，就会接着发送这个数据块，防止数据块丢失）、流量控制（比如服务器发送数据太快了，则计算机发消息告诉服务器调整发送速度）、不可靠传输（比如DNS解析域名，一个数据包就能说明问题与得到答案，不需要建立会话） 网络层：负责选择最佳路径、规划IP地址 数据链路层：帧的开始和结束、透明传输（将数据中与开头或结尾表示相同的部分进行转义）、差错校验（检错错误，数据中多加一部分数据进行校验，但不纠错，只检查，错误的就扔掉，纠错是在传输层进行） 物理层：接口标准、电器标准、如何在物理链路上传输更快的速度 每一层都是一个较为独立的模块，每一个模块变化都不会影响其他的模块；但每一层都有关系：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层-&gt;人（-&gt;代表xx为xx提供服务） 网络出现故障，应该从最底层物理层往上一层一层进行检查 物理层故障：查看连接状态、查看发送和接收的数据包 数据链路层故障：mac地址冲突、ADSL欠费、网速没办法协商一致、计算机连接到错误的VLAN(虚拟局域网) 网络层故障：配置了错误的IP地址、子网掩码、配置错误的网关、路由器没有配置到达目标网络的路由、数据有没有通过各个网关到达指定位置 应用层故障：应用程序配置错误 打开终端输入命令ping一个网址，若数据有来有回，则证明网通了 OSI参考模型和网络安全 物理层安全 数据链路层安全：ADSL账号密码、VLAN、交换机端口绑定mac地址 网络层安全：在路由器上时使用ACL控制数据包流量、防火墙 应用层安全：开发的应用程序没漏洞","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://liuhaotian.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://liuhaotian.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"API之lowerer_bound/upper_bound用法","slug":"API之lowerer-bound-upper-bound用法","date":"2020-06-02T06:22:27.000Z","updated":"2020-06-12T14:39:19.082Z","comments":true,"path":"2020/06/02/API之lowerer-bound-upper-bound用法/","link":"","permalink":"http://liuhaotian.top/2020/06/02/API%E4%B9%8Blowerer-bound-upper-bound%E7%94%A8%E6%B3%95/","excerpt":"","text":"API之lowerer_bound/upper_bound用法lower_bound()lower_bound(beg, end, val, comp) 参数： 一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是数组的首地址，只是用于比较的“首”地址） 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址） 就是一个要二分查找的那个数 greater&lt;int&gt;()代表降序，less&lt;int&gt;()代表升序，默认是升序，也就是数组元素从小到大排列 返回值: 返回值就是返回第一次出现大于等于那个要查找的数的地址 注意： 返回值是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组的数组名，即这个数组的首地址,只有这样才代表那个要查找的数字的下标 那就是要大于等于那个数，等于好理解，大于怎么理解呢，比如说我并没有找到那个数，加入一个的数组里边就有5个数，分别是1,1,1,3,5,而我需要找的那个数就是2，怎么返回呢？就是返回那个第一个大于2的数的地址，就是返回3的地址，那么再有一组数据就是5个数1,1,1,3,3，还是需要找寻2，那么该返回什么呢？那就是第一个3的地址 示例：1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int k, n = 10;int a[10] = &#123;1, 1, 1, 3, 3, 5, 5, 5, 5, 6&#125;;int main() &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; while (scanf(\"%d\", &amp;k)) &#123; cout &lt;&lt; k &lt;&lt; \"的第一个大于等于它的位置在\" &lt;&lt; ((lower_bound(a, a + n, k)) - a) + 1 &lt;&lt; endl; &#125;&#125;结果：123451 1 1 3 3 5 5 5 5 6 33的第一个大于等于它的位置在455的第一个大于等于它的位置在6 upper_bound()upper_bound函数的用法lower_bound函数的用法相似，不过这个唯一的不同就是返回的是第一个比我要找的那个数大的数的地址，注意，这里并没有等于，也就是说如果在5个数1,1,2,2,4，里边寻找3，那么就会返回4的地址 示例：1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int k, n = 10;int a[10] = &#123;1, 1, 1, 3, 3, 5, 5, 5, 5, 6&#125;;int main() &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; while (scanf(\"%d\", &amp;k)) &#123; cout &lt;&lt; k &lt;&lt; \"的第一个大于它的位置在\" &lt;&lt; ((upper_bound(a, a + n, k)) - a) + 1 &lt;&lt; endl; &#125;&#125;结果：123451 1 1 3 3 5 5 5 5 6 55的第一个大于它的位置在1011的第一个大于它的位置在4 set和map中的upper_bound/lower_bound和上述一样的功能，不过其本身class内的放法比调用用外部的upper_bound/lower_bound效率高 灵活使用123map&lt;int, int&gt; spfs;auto spf = spfs.upper_bound(cows[i].second);spf--; 这就实现了找小于等于cows[i].second的数中最大值的功能","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://liuhaotian.top/categories/C-C/"}],"tags":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/tags/C-C-%E5%B8%B8%E7%94%A8API/"}]},{"title":"0x07贪心","slug":"0x07贪心","date":"2020-06-02T05:16:30.000Z","updated":"2020-06-12T14:52:02.093Z","comments":true,"path":"2020/06/02/0x07贪心/","link":"","permalink":"http://liuhaotian.top/2020/06/02/0x07%E8%B4%AA%E5%BF%83/","excerpt":"","text":"0x07贪心基础知识贪心是一种在每次决策时采取当前意义下最优策略的算法，因此，使用贪心法要求问题的整体最优性可以由局部最优性导出。贪心算法的正确性需要证明，常见的证明手段有： 微扰（邻项交换）证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果的变差，经常用于以“排序”为贪心策略的证明 范围缩放证明任何对局部最优策略作用范围的扩展都不会造成整体结果的变差 决策包容性证明在任意局面下，做出局部最优策略以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略的可能性包含其他所有策略提供的可能性 反证法 数学归纳法 我们通过几道例题来介绍贪心算法的应用 ACWING110.防晒按照minSPF递减的顺序把奶牛排序，依次考虑每头奶牛 对于每头奶牛，扫描一遍所有的防晒霜，在这头奶牛能用（能用指的是该防晒霜的强度符合这头奶牛的范围，并且瓶数还有剩余）的防晒霜里找SPF值最大的使用 以上算法的贪心策略是在满足条件的前提下每次选择SPF最大的防晒霜，这个策略正确的原因是：我们考虑这一步策略的作用范围扩展到后续其他奶牛之后产生的影响。每瓶防晒霜是否可用，会被minSPF和maxSPF两个条件限制，因为奶牛已经按照minSPF递减排序，所以每一个不低于当前奶牛minSPF值的防晒霜，都不会低于后面其他奶牛的minSPF。也就是说，对于当前奶牛可用的任意两瓶防晒霜x和y，如果SFP[X]&lt;SFP[y]，那么后面的奶牛只可能出现三种情况之一 x和y都能用 x和y都不能用 x能用，y不能用 因此当前奶牛选择较大的y去用，对于整体的影响肯定比选择较小的x去用要好，另外，每头奶牛对答案的贡献至多是1，即使让当前奶牛放弃日光浴，留下防晒霜给后面的某一头奶牛去用，对答案的贡献也不会更大，综上所述，尽量满足当前的奶牛，并选择SPF值尽量大的防晒霜是一个正确的贪心策略 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2510;typedef pair&lt;int, int&gt; PII;int n, m;PII cows[N];int main() &#123; cin &gt;&gt; n &gt;&gt; m; map&lt;int, int&gt; spfs; for (int i = 0; i &lt; n; i++) cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second; for (int i = 0; i &lt; m; i++) &#123; int spf, cover; cin &gt;&gt; spf &gt;&gt; cover; spfs[spf] += cover; &#125; sort(cows, cows + n); int res = 0; spfs[0] = spfs[1001] = 1; for (int i = n - 1; i &gt;= 0; i--) &#123; auto spf = spfs.upper_bound(cows[i].second); spf--; if (spf-&gt;first &gt;= cows[i].first) &#123; res++; if (--spf-&gt;second == 0) spfs.erase(spf); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; ACWING111.畜栏预定按照开始吃草的时间把牛排序，用小根堆维护所有畜栏中最后一头牛结束吃草的时间的最小值，每循环到一头牛，如果这头牛的吃草开始时间比这个小根堆的堆顶大，则把这个牛插入到这个小根堆堆顶对应的畜栏中，再重新维护小根堆；如果小根堆的堆顶比这头牛的开始吃草时间大，则新建一个畜栏，插入到小根堆中 这种策略成功的原因在于：把每个畜栏的时间都充分利用，如果存在多个畜栏可以存放此牛，则选择最后一头牛结束吃草时间最小的畜栏，这样可以充分利用每个畜栏的时间；把每个牛的开始吃草时间从小到大排序的原因是，这样就可以让后面的牛插入在畜栏的后面，如果不排序，则每个畜栏前面可能有时间空隙放牛，这是不符合要求的，很难做出来 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 50010;int n;int id[N];pair&lt;PII, int&gt; cows[N];int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second; cows[i].second = i; &#125; sort(cows, cows + n); priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap; for (int i = 0; i &lt; n; i++) &#123; if (heap.empty() || heap.top().first &gt;= cows[i].first.first) &#123; id[cows[i].second] = heap.size() + 1; heap.push(&#123;cows[i].first.second, heap.size() + 1&#125;); &#125; else &#123; auto stall = heap.top(); heap.pop(); stall.first = cows[i].first.second; id[cows[i].second] = stall.second; heap.push(stall); &#125; &#125; cout &lt;&lt; heap.size() &lt;&lt; endl; for (int i = 0; i &lt; n; i++) cout &lt;&lt; id[i] &lt;&lt; endl; return 0;&#125; 未完待续","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"PYTHON基础语法总结","slug":"PYTHON基础语法总结","date":"2020-06-01T10:33:39.000Z","updated":"2020-06-12T14:48:29.806Z","comments":true,"path":"2020/06/01/PYTHON基础语法总结/","link":"","permalink":"http://liuhaotian.top/2020/06/01/PYTHON%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"PYTHON视频讲解(MOSH)总结和C/C++的区别 python的print是一个函数，其中代表换行的参数默认换行，所以每次执行一次print都会自动换行 python的bool值是False和True，首字母大写，而C/C++的bool类型值是false和true，首字母小写 python的输出函数是print，而C的输出语句是printf python的输入语句是input()，这个函数把括号内的东西输出，并接受输入的值，所以可以有如下写法name = input(&quot;what&#39;s your name&quot;) input把接收的值转化为字符串 10/3 = 3.333，这与C/C++不同10//3 = 3，这与C/C++相同3**2 = 9，C/C++中没有此用法 C++中的类与python中的类有一点区别假设都定义了School这个类 12345C++:School one;python:one &#x3D; School() 基础语法 type(变量) 打印变量的类型 三个引号&#39;&#39;&#39; &#39;&#39;&#39;，三引号中间的变量可以换行，此外还有双引号和单引号 1234567891011121314程序：email = '''Hello!This is Fu JANG 's blog.Welcome to u.'''print(email)结果：Hello!This is Fu JANG 's blog.Welcome to u.进程已结束,退出代码0 对于第二点的代码（三引号）email[0]就是H，email[-1]就是换行符，email[-2]就是.，而对于以下的代码： 123456程序：email = 'Hello'print(email[-1])结果：o [0:3]左闭右开[0:] 0到末尾[:3]与第一个等效[:] 全部 f&#39;{变量名}’ 占位符，程序会用对应变量的值去填充大括号 len() 返回字符串的长度 .upper()把字符串中字母全部转 为大写，但不改变原字符串.lower()把字符串中字母全部转为小写，但不改变原字符串.title()把字符串中单词首字母字母全部转为大写，但不改变原字符串 .find(&#39;&#39;)找到这个字符在字符串中的第一个索引 若&#39;&#39;中为一串字符，则返回第一个字符的索引 若&#39;&#39;中的字符在字符串中不存在，则返回-1 .replace(&#39;原&#39;, &#39;新&#39;) 若字符串中没有原字符，则不替换 &#39; &#39; in 变量 返回一个布尔值，代表该字符是否在此变量中 round()四舍五入abs()取绝对值 引用模块 12345678程序：import mathprint(math.ceil(2.9)) 封print(math.floor(2.9)) 底结果：32 if语句：if:elif:else: 逻辑运算符：and or not while循环，当条件不符合时，执行else，break的程序不执行elsewhile:else: range(10) 0到9range(5,10) 5到9range(5,10,2) 5,7,9 123456789101112131415代码：for item in range(10): print(item)结果：0123456789 列表：方括号 1[1,2,3] 二维列表 12345[ [1,2,3], [4,5,6], [7,8,9]] 列表定义的方法.append() 在最后面插入 .insert(0,10) 在索引为0的位置加10 .remove(5) 删除第一个5 .clear() 清空列表 .pop() 删最后 .index(5) 传第一个5的索引 .count(5) 传5的个数 .sort() 不返回值，从小到大排序 .reverse() 从大到小排序 .copy() 复制 (,,) 元组 不可变.count() 计数.index() 传索引 压缩属性 12m &#x3D; (1,2,3)x, y, z &#x3D; m 字典 1234567891011121314程序：customer = &#123; \"name\" : \"FuJANG\", \"sex\" : \"man\", \"address\" : \"China\", \"age\" : 6, \"is_handsome\" : True&#125;print(customer[\"name\"])结果：FuJANG进程已结束,退出代码0 字典定义的方法.get(&quot; &quot;) 若键不存在则返回None.get(&quot;key&quot;, &quot;value&quot;) 提供一个默认的值，并不修改字典，当在字典中对应的key存在时，默认值无效可用此形式更改、添加字典[&quot; &quot;] = &quot; &quot; 表示形式列表[ , , ]元组( , , )字典{ , , } abc = &quot;字符串”for ch in abc:遍历字符串中的所有字符abc.split(&quot;空格&quot;) 根据空格分割字符串中的单词并储存在一个列表中 函数与模块 定义一个函数 每个函数后最好加上两个空行（标准格式），先定义函数后才可引用，()中可以加参数，如(name),调用时需要传一个值如(&quot;Mosh&quot;)，关键字参数一般放在最后 没有return的函数默认返回None 当return x, y时，python把x, y解释为一个元组(x, y) 12def 函数名(): 内容 用try...expect来处理异常错误 1234try： ×××expect 错误类型: ××× class定义一个类，首字母大写，不用下划线 def定义一个函数，首字母小写，用下划线链接 1234567891011121314class Point: def ×××(self, ×××): ××× def ×××用类声明对象point1 = Point()调用定义的方法point1.×××()可以在程序的任何位置设置属性，属性没有必要一定在类里定义point1.属性名 = 10 python中的构造函数 1234567class Point: def __init__(self, x, y): self.x = x self.y = ypoint1 = Point(10, 20) 继承：当一个类中没有任何东西时，为了规范格式，通常加一个pass 123456789101112class Normal: def walk(self): ×××class Dog(Normal): passclass Cat(Normal): def bark(self): print(\"×××\") 调用模块 12345678import hellohello.×××()from hello import ××××××()import hello as hehe.×××() 建立一个包 1234567891011① New → Directory → __init__.py② New → Python Packageimport 包.文件包.文件.函数()from 包.文件 import 函数函数()from 包 import 文件文件.函数() 内置模块的调用举例 12345# randint 为闭区间import randomrandom.random() 随机跳出一个0和1间的数字random.randint(10, 20) 10到20间的一个整数值random.choice(numbers) 假如numbers是一个列表，则随机跳出列表中的一个元素 内置模块与下载模块python中有内置模块，当找不到想使用的模块时，可以去pypi.org寻找相应的模块下载命令，然后在终端上用命令下载相应的模块","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]},{"title":"0x04二分","slug":"0x04二分","date":"2020-05-31T10:05:30.000Z","updated":"2020-06-12T14:51:09.243Z","comments":true,"path":"2020/05/31/0x04二分/","link":"","permalink":"http://liuhaotian.top/2020/05/31/0x04%E4%BA%8C%E5%88%86/","excerpt":"","text":"0x04二分基础知识二分的基础的用法是在单调序列或单调函数中进行查找，因此当问题的答案具有单调性时，就可以通过二分把求解问题转换为判定（根据复杂度理论，判定的难度小于求解），进一步地，我们还可以扩展到通过三分法去解决单峰函数的极值以及相关问题 对于整数域上的二分，需要注意中止边界、左右区间取舍时的开闭情况，避免漏掉答案或者造成死循环；对于实数域上的二分，需要注意精度问题 整数集合上的二分本文章的写法保证最终答案处于闭区间[l,r]以内，循环以l=r结束，每次二分的中间值mid会归属于左半段与右半段二者之一 模板如下： 在单调递增序列a中查找&gt;=x的数中最小的一个（x或x的后继）12345while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (a[mid] &gt;= x) r = mid; else l = mid + 1;&#125;return a[l];在单调递增序列a中查找&lt;=x的数中最大的一个（x或x的前驱）12345while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (a[mid] &lt;= x) l = mid; else r = mid - 1;&#125;return a[l]; 如上面两段代码所示，这种二分写法可能会有两种形式：1.缩小范围时，r=mid， l=mid+1，取中间值时，mid=(l+r)&gt;&gt;12.缩小范围时，l=mid， r=mid-1，取中间值时，mid=(l+r+1)&gt;&gt;1如果不对mid的取法加以区分，假如第二段代码也采用mid=(l+r)&gt;&gt;1，那么当r-l等于1时，就有mid=(l+r)&gt;&gt;1=l，接下来若进入l=mid分支，可行区间未缩小，造成死循环；若进入r=mid-1分支，造成l&gt;r，循环不能以l=r结束；相反若mid=(l+r+1)&gt;&gt;1 ，则第二段代码则正确得到结果。因此对两个形式采用配套的mid取法是必要的。此外还要注意：我们在二分实现中采用了右移运算符&gt;&gt;1，而不是整数除法/2。这是因为右移运算是向下取整，而整数除法是向0取整，在二分值域包含负数时后者不能正常工作。 我用一个例题来体现这两个模板的差别：ACWING789.数的范围1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 10;int nums[MAXN];int main() &#123; int n, q; scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;nums[i]); &#125; while (q--) &#123; int l = 0, r = n - 1; int x; scanf(\"%d\", &amp;x); while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] &gt;= x) r = mid; else l = mid + 1; &#125; if (nums[l] != x) printf(\"-1 -1\\n\"); else &#123; cout &lt;&lt; l &lt;&lt; \" \"; int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (nums[mid] &lt;= x) l = mid; else r = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; &#125; return 0;&#125;可以看出这两个模板的另一个区别：当目标值不止一个时，第一个模板是取到左边，也就是在单调递增序列a中查找&gt;=x的数中最小的一个；第二个模板是取到右边，也就是在单调递增序列a中查找&lt;=x的数中最大的一个；当目标值只有只有一个时，两个模板的结果没有差别 仔细分析这两种mid的取法，我们还发现：mid=(l+r)&gt;&gt;1不会取到r这个值，mid=(l+r+1)&gt;&gt;1不会取到l这个值，我们可以利用这一性质来处理无解的情况，把最初的二分区间分别扩大为[1,n+1]和[0,n]，把a数组的一个越界下标包含进来。如果最后二分终止于扩大后的这个越界下标上，则说明目标值不在a中；当然我们也可以直接看最终求得的l下标在a数组中对应的值是否为目标值 二分的终止条件就是l==r，该值就是答案所在位置 C++STL的lower_bound和upper_bound函数实现了在一个序列中二分查找某个整数x的后继 未完待续","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"API之stringstream用法","slug":"API之stringstream用法","date":"2020-05-30T02:06:47.000Z","updated":"2020-06-12T14:39:24.947Z","comments":true,"path":"2020/05/30/API之stringstream用法/","link":"","permalink":"http://liuhaotian.top/2020/05/30/API%E4%B9%8Bstringstream%E7%94%A8%E6%B3%95/","excerpt":"","text":"API之stringstream用法本文主要介绍 C++ 中 stringstream 类的常见用法。 1.概述&lt;sstream&gt;定义了三个类：istringstream、ostringstream和stringstream，分别用来进行流的输入、输出和输入输出操作。本文以stringstream为主，介绍流的输入和输出操作 &lt;sstream&gt;主要用来进行数据类型转换，由于&lt;sstream&gt;使用string对象来代替字符数组（snprintf方式），就避免缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符的问题。简单说，相比c库的数据类型转换而言，&lt;sstream&gt;更加安全、自动和直接 2.代码示例2.1数据类型转换这里展示一个代码示例，该示例介绍了将int类型转换为string类型的过程。示例代码（stringstream_test1.cpp）如下：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() &#123; stringstream sstream; string strResult; int nValue = 1000; // 将int类型的值放入输入流中 sstream &lt;&lt; nValue; // 从sstream中抽取前面插入的int类型的值，赋给string类型 sstream &gt;&gt; strResult; cout &lt;&lt; \"[cout]strResult is: \" &lt;&lt; strResult &lt;&lt; endl; printf(\"[printf]strResult is: %s\\n\", strResult.c_str()); return 0;&#125;结果如下：12[cout]strResult is: 1000 [printf]strResult is: 1000 2.2多个字符串拼接本示例介绍在stringstream中存放多个字符串，实现多个字符串拼接的目的（其实完全可以使用 string类实现），同时，介绍stringstream的清空方法。示例代码（stringstream_test2.cpp）如下： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() &#123; stringstream sstream; // 将多个字符串放入 sstream 中 sstream &lt;&lt; \"first\" &lt;&lt; \" \" &lt;&lt; \"string,\"; sstream &lt;&lt; \" second string\"; cout &lt;&lt; \"strResult is: \" &lt;&lt; sstream.str() &lt;&lt; endl; // 清空 sstream sstream.str(\"\"); sstream &lt;&lt; \"third string\"; cout &lt;&lt; \"After clear, strResult is: \" &lt;&lt; sstream.str() &lt;&lt; endl; return 0;&#125; 结果如下：12strResult is: first string, second stringAfter clear, strResult is: third string 从上述代码执行结果能够知道： 可以使用str()方法，将stringstream类型转换为string类型 可以将多个字符串放入stringstream中，实现字符串的拼接目的 如果想清空stringstream，必须使用sstream.str(&quot;&quot;); 方式:clear()方法适用于进行多次数据类型转换的场景。详见示例2.3 2.3stringstream的清空清空stringstream有两种方法：clear()方法以及str(&quot;&quot;)方法，这两种方法有不同的使用场景。str(&quot;&quot;)方法的使用场景，在上面的示例中已经介绍了，这里介绍clear()方法的使用场景。示例代码（stringstream_test3.cpp）如下： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; stringstream sstream; int first, second; // 插入字符串 sstream &lt;&lt; \"456\"; // 转换为int类型 sstream &gt;&gt; first; cout &lt;&lt; first &lt;&lt; endl; // 在进行多次类型转换前，必须先运行clear() sstream.clear(); // 插入bool值 sstream &lt;&lt; true; // 转换为int类型 sstream &gt;&gt; second; cout &lt;&lt; second &lt;&lt; endl; return 0;&#125; 结果如下：124561 注意：在本示例涉及的场景下（多次数据类型转换），必须使用clear()方法清空stringstream，不使用clear()方法或使用str(&quot;&quot;)方法，都不能得到数据类型转换的正确结果。下图分别是未使用clear()方法、使用str(&quot;&quot;)方法时的运行结果： 1234545641970084560 2.4测试1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() &#123; stringstream sstream; // 将多个字符串放入 sstream 中 sstream &lt;&lt; \"firstiiii\" &lt;&lt; \" \" &lt;&lt; \"string,\"; sstream &lt;&lt; \" second string\"; string a, b; sstream &gt;&gt; a; cout &lt;&lt; \"strResult is: \" &lt;&lt; a &lt;&lt; endl; sstream &gt;&gt; a; cout &lt;&lt; \"strResult is: \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; sstream.str(); return 0;&#125; 结果如下：123strResult is: firstiiiistrResult is: string,firstiiii string, second string由此可知，我们可以用它来分割字符串中的单词 3.例题LEETCODE1455. 检查单词是否为句中其他单词的前缀 123456789101112class Solution &#123; public: int isPrefixOfWord(string sentence, string searchWord) &#123; stringstream ssin(sentence); string word; for (int i = 1; ssin &gt;&gt; word; i++) if (word.substr(0, searchWord.size()) == searchWord) return i; return -1; &#125;&#125;;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://liuhaotian.top/categories/C-C/"}],"tags":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/tags/C-C-%E5%B8%B8%E7%94%A8API/"}]},{"title":"0x02递推与递归","slug":"0x02递推与递归","date":"2020-05-30T00:39:58.000Z","updated":"2020-06-12T14:50:58.658Z","comments":true,"path":"2020/05/30/0x02递推与递归/","link":"","permalink":"http://liuhaotian.top/2020/05/30/0x02%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/","excerpt":"","text":"0x02递推与递归基础知识一个实际问题的各种可能情况构成的集合通常称为“状态空间”，而程序的运行则是对状态空间的遍历 对于一个待求解的问题，当它局限在某处边界、某个小范围或者某种特殊情况下时，其答案往往是已知的。如果能够将该解答的应用场景扩大到原问题的状态空间，并且扩展过程的每个步骤具有相似性，就可以考虑使用递推或者递归求解 以已知的“问题边界”为起点向“原问题”正向推导的扩展方式就是递推。然而在很多时候，推导的路线难以确定，这时以“原问题”为起点尝试寻找把状态空间缩小到已知的“问题边界”路线，再通过该路线反向回溯的遍历方式就是递归 使用递推或递归要求“原问题”与“问题边界”之间的每个变换步骤具有相似性，这样我们才能设计一段程序来实现该步骤，将其重复作用于问题之中。换句话说，程序在每个步骤上应该面对相同种类的问题，这些问题都是原问题的一个子问题，可能仅在规模或者某些限制条件上有所区别，并且能够使用“求解原问题的程序”进行求解 对于递归算法，有了上面这个前提，我们就可以让程序在每个变换步骤中执行三个操作： 缩小问题状态空间的规模。这意味着程序尝试寻找在“原问题”与“问题边界”之间的变换路线，并向正在探索的路线迈出一步 尝试求解规模缩小以后的问题，结果可能是成功，也可能是失败 如果成功，即找到了规模缩小后的问题的答案，那么将答案扩展到当前问题；如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直至最终确定当前问题无法继续求解 以上三个操作有两点特别关键：一是“如何尝试求解规模缩小以后的问题”。因为规模缩小以后的问题是原问题的一个子问题，所以我们可以把它视为一个新的原问题，由相同的程序进行求解，这就是所谓的“自身调用自身”；二是如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“回溯时还原现场”，关于递归与回溯，举一道简单的例题 LEETCODES1457. 二叉树中的伪回文路径1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123; public: unordered_map&lt;int, int&gt; cnt; int pseudoPalindromicPaths(TreeNode* root) &#123; cnt[root-&gt;val]++; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; int t = 0; for (auto item : cnt) if (item.second % 2) t++; cnt[root-&gt;val]--; return t &lt;= 1; &#125; int res = 0; if (root-&gt;left) res += pseudoPalindromicPaths(root-&gt;left); if (root-&gt;right) res += pseudoPalindromicPaths(root-&gt;right); cnt[root-&gt;val]--; return res; &#125;&#125;; y总原话：从这道题中我们可以看出回溯时还原现场的要求，每一次return之前都要记得恢复，有两次return，所以两次都要记得恢复。我们要记住一点：如果进来的时候修改了，那么在退出之前就应该恢复 重申：如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“回溯时还原现场” 递归总结可以看到，递归程序的基本单元是由“缩小”、“求解”、“扩展”组成的一种变换步骤，只是在“求解”时因为问题的相似性，不断重复使用了这样一种变换步骤，直至在一致的问题边界上直接确定答案。对于其中任意一条从“原问题”到“边界问题”的变换路线，横向来看，它跳的每一层是一次递归程序的执行；纵向来看，它的左右两边分别是寻找路线和沿其推导的流程。为了保证每层的“缩小”与“拓展”能够衔接在同一形式的问题上，“求解”操作自然要保证在执行前后程序面对的问题的状态是相同的，这也就是“还原现场”的必要性所在 递推与递归的简单应用在使用枚举算法蛮力探索问题的整个”状态空间“时，经常需要递归。按照规模大小，有如下的几种常见的枚举形式和遍历方式： 枚举形式 状态空间规模 一般遍历方式 多项式 n^k k为常数 循环(for)、递推 指数 k^n k为常数 递归、位运算 排列 n! 递归、C++next_permutation 组合 C_n^m 递归+减枝 递归的机器实现一台典型的32位计算机采用“堆栈结构”来实现函数调用，它在汇编语言中，把函数所需的第k个、第k-1个，……，第1个参数依次入栈，然后执行call(address)指令。该指令把返回地址（当前语句的下一条语句地址）入栈，然后跳转到address位置的语句。在函数返回时，它执行ret指令。该指令把返回地址出栈，并跳转到该地址继续执行 对于函数中定义的C++局部变量，在每次执行call与ret指令时，也会在栈中相应的保存与复原，而作用范围超过该函数的变量，以及通过new和malloc函数动态分配的空间则保存在另一块成为堆的结构中。栈指针、返回值、局部的运算会借助CPU的“寄存器”完成 由此我们得知： 局部变量在每层递归中都占有一份空间，声明过多或递归过深就会超出”栈“所能存储的范围，造成栈溢出 非局部变量对于各层递归都共享一份空间，需要及时维护、还原现场，以防止在各层递归之间存储和读取的数据相互影响 了解了递归的及其实现之后，我们就可以使用模拟的方法，把递归程序改写为非递归程序。具体来说，我们可以用一个数组来模拟栈，使用变量来模拟栈指针和返回值，使用switch/case或者goto/label来模拟语句跳转 分治分治法把一个问题划分成若干个规模更小的同类子问题，对这些子问题递归求解，然后在回溯时通过它们推导出原问题的解","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"0x01位运算","slug":"0x01位运算","date":"2020-05-28T04:52:08.000Z","updated":"2020-06-12T14:50:51.338Z","comments":true,"path":"2020/05/28/0x01位运算/","link":"","permalink":"http://liuhaotian.top/2020/05/28/0x01%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"0x01 位 运 算基础知识 用xor表示异或运算，在m位二进制数中，通常称最低位为0位，从右到左依此类推，最高位为m-1位。 |-1|的原码为00000001|-1|的反码为11111110-1的补码为11111111，十六进制表示为0xff8位二进制对应的最大值127的十六进制表示为0x7f在计算机中数字以其补码的形式保存，正数的补码等于其原码，负数的补码等于其对应正数的原码取反码再+1 对于32位二进制数C(设十进制的值为S)，其按位取反得到的编码~C对应的十进制的值为-1-S(正负都满足此规律) 补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在32位补码下做最高位不进位的二进制加减法运算。发生算术溢出时，32位无符号整数相当于自动对2^32取模，这也解释了有符号整数溢出时为何会出现负数的现象。 在算法竞赛中常用十六进制来表示一个常数，这样书写需要八个字符。| 10进制 | 16进制 || :-: | :-: || 21 4748 3647 | 0x7f ff ff ff || 10 6110 9567 | 0x3f 3f 3f 3f || -1 | 0xff ff ff ff | 4个字节的int表示的最大值为21 4748 36474个字节的unsigned int表示的最大值为42 9496 7295 0x3f 3f 3f 3f是一个很有用的值，它满足两个条件：其一，整数的两倍不超过int能表示的最大正整数其二，二进制下每八位都相同因此，我们可以用memset(a, 0x3f, sizeof a)来给a数组的每一个元素都赋值为正无穷，虽然0x7f能给每一个元素赋值成最大，但是为了避免溢出情况，推荐用0x3f。 1 &lt;&lt; n = 2^n, n &lt;&lt; 1 = 2nn &gt;&gt; 1 = n / 2.0 向下取整需要注意的是，整数做/运算执行的是向0取整(-3) &gt;&gt; 1 = -2, (-3) / 2 = -1 除非特殊提示，我们默认右移采用的是算术右移的实现方式 逻辑右移不考虑符号位，右移一位，左边补零即可。 算术右移考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。 所以算术右移也可以进行有符号位的除法,右移n位就等于除2的n次方。 例如，8位二进制数11001101分别右移一位。 逻辑右移就是[0]1100110 算术右移就是[1]1100110 状态压缩二进制状态压缩是指将一个长度为m的bool数组用一个m位二进制整数表示并存储的方法，利用如下操作实现对原bool数组对应下标元素的存取。 取出整数n的第k位：(n&gt;&gt;k)&amp;1 取出整数n的后k位(0到k-1位)：((1&lt;&lt;K)-1)&amp;n 把整数n的第k位反转：(1&lt;&lt;k) nor n 把整数n的第k位赋值为1：(1&lt;&lt;k)|n 把整数n的第k位赋值为0：(~(1&lt;&lt;k))&amp;n 当m不大时，我们可以使用一个整数存储，当m很大时，我们可以用若干个整数存储(int数组)，也可以用C++STL为我们提供的bitset实现。 成对变换通过计算可发现，对于非负整数n: 当n为偶数时，n xor 1 = n + 1 当n为奇数时，n xor 1 = n - 1 因此0与1, 2与3, 4与5 … 关于xor 1运算构成成对变换。 这一性质经常用于图论邻接表中边集的存储。在具有无向边(双向边)的图中把一对正反方向的边分别存储在邻接表数组的第n与n+1位置(其中n为偶数)，就可以通过xor 1的运算获得与当前边(x,y)反向的边(y,x)的存储位置。 lowbit运算lowbit(n)定义为非负整数n在二进制表示下“最低位的1及其后边所有的0”构成的数值。 例子：lowbit(10)=2 其原理为：lowbit(n)=n&amp;(~n-1)=n&amp;(-n) lowbit运算配合Hash可以找出整数二进制下所有是1的位，所花费的时间与1的个数同级。为了达到这个目的，我们只需要不断把n赋值为n-lowbit(n)直至n=0。我们可以把每次减去的数(其一定为2的幂)求log得到对应的1所在的位数，因为C++math.h库中的log函数复杂度常数较大，所以我们可以预处理一个数组，通过Hash的方法代替log运算。 此外lowbit运算也是树状数组中的一个基本运算。 0x01位运算例题 点击每道题题目即可获取原题链接 a^b分析long long可以表示的最大值为922 3372 0368 5477 5807unsigned long long可以表示的最大值为1844 6744 0737 0955 1615 由此观之a^b大于ULL类型可以表示的最大值，所以要用快速幂的思想来求解这道题。 且取模的性质如下 (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p) % p (a b) % p = (a % p b % p) % p a ^ b % p = ((a % p)^b) % p 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int power(int a, int b, int c) &#123; int ans = 1 % c; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) ans = (long long)ans * a % c; a = (long long)a * a % c; &#125; return ans;&#125;int main() &#123; int a, b, p; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;p); int ans = power(a, b, p); printf(\"%d\", ans);&#125; 复杂度我们可以用b&amp;1运算表示b的二进制下的最低位，并用b&gt;&gt;1来舍去最低位。在递归的过程中把&gt;&gt;和&amp;结合，其时间复杂度为O(logb) 64位整数乘法代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL power(LL a, LL b, LL c) &#123; LL ans = 0; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) ans = (ans + a) % c; a = a * 2 % c; &#125; return ans;&#125;int main() &#123; LL a, b, p; scanf(\"%lld%lld%lld\", &amp;a, &amp;b, &amp;p); LL ans = power(a, b, p); printf(\"%lld\", ans);&#125; 复杂度我们可以用b&amp;1运算表示b的二进制下的最低位，并用b&gt;&gt;1来舍去最低位。在递归的过程中把&gt;&gt;和&amp;结合，其时间复杂度为O(logb)，与上一题不同的是位数问题，但是每次%p之后都能保证不超过2*10^18，在long long的范围内 最短Hamilton路径分析我们可以采用朴素算法,其时间复杂度为O(n*n!)，n!为枚举n个点的全排列，n代表枚举路径的长度求得结果，这个算法的时间复杂度太高，不符合。而我们可以用二进制状态压缩DP来把时间复杂度优化到O((n^2)*(2^n)),我们用F[i,j]表示点被经过的状态对应二进制数i，且目前处于点j的最短路径 在起点时F[1,0]=0，即目前处于点0且只经过了点0的最短路径为0。为方便起见，我们将数组中其他元素设为无穷大，最终目的是求F[(1&lt;&lt;n),n-1]的值，即经过所有点且最终处于n-1的最短路径 在任意时刻，有公式F[i,j]=min(F[i,j],F[i^(1&lt;&lt;j),k]+weight[k,j])，根据分析可得k一定是倒数第二个经过的点。我们枚举k，当k对应在i的二进制为1时，我们讨论这种情况并比较 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; 20;int weight[N][N], F[M][N];int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf(\"%d\", &amp;weight[i][j]); memset(F, 0x3f, sizeof F); F[1][0] = 0; for (int i = 1; i &lt; 1 &lt;&lt; n; i++) for (int j = 0; j &lt; n; j++) if (i &gt;&gt; j &amp; 1) for (int k = 0; k &lt; n; k++) if ((i ^ 1 &lt;&lt; j) &gt;&gt; k &amp; 1) F[i][j] = min(F[i][j], F[i ^ 1 &lt;&lt; j][k] + weight[k][j]); printf(\"%d\", F[(1 &lt;&lt; n) - 1][n - 1]);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"}],"tags":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}]},{"title":"HEXO+BUTTERFLY搭建骚气且实用的个人网站","slug":"HEXO-BUTTERFLY搭建骚气且实用的个人网站","date":"2020-05-27T03:01:58.000Z","updated":"2020-06-12T14:38:56.806Z","comments":true,"path":"2020/05/27/HEXO-BUTTERFLY搭建骚气且实用的个人网站/","link":"","permalink":"http://liuhaotian.top/2020/05/27/HEXO-BUTTERFLY%E6%90%AD%E5%BB%BA%E9%AA%9A%E6%B0%94%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/","excerpt":"","text":"YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS. 引子最近狂刷codeforces，但是逐渐发现自身一个问题，那就是刷过的题虽然在当天感觉很明白，但是隔一天，隔两天，就发现自己再遇到此题时又是一翻鏖战，这就是说明自己做过的题吸收的效率不够高，于是我就打算做一道题总结一道题。那么问题来了，在哪里总结呢？ 首先排除的是微信公众号，众所周知，微信公众号只能是自己分享东西的平台，而在这上面总结知识点就会引出很多问题，其一，每篇文章都要排版，其二，我的粉丝未必合此文章的胃口，其三，每天只能发布一篇文章，大大限制了自己的总结内容与时间分配。 那么诸如csdn、博客园、掘金、知乎这种东西呢？也有很多不方便的地方，比如文章左右侧的广告，实在影响人的心情，此外还有审核等等的制约，思前想后，我决定自己开辟一个个人网站。 当然不能从无到有手动开辟，自己能力有限，而且我的目的也是总结，总不能让自己以后把大把的时间浪费到维护网站上面去。于是我听从了大佬的建议，采用hexo+github的方式，hexo开辟网站，托管到github上面去。 花里胡哨的页面也是最吸引我的原因之一，我采用了butterfly的主题，绝对美炸天！ 过程过程当然是心酸+心酸+心酸，心态险些被搞没。至于搭建网站的教程，实话实说，看了n多篇技术总结，都号称史上最全，到最后还是觉得看官方文档最省事。 当然自己也找到了一些好的文章，在此列出来希望对大家有帮助： hexo安装文章： Hexo+Butterfly+Github+Coding搭建个人博客 hexo官方文档 butterfly主题系列文章： hexo-theme-butterfly 安装文档(一)快速开始 hexo-theme-butterfly 安装文档(二)主题页面 hexo-theme-butterfly 安装文档(三)主题配置 hexo-theme-butterfly 安装文档(四)主题问答、打赏名单 hexo-theme-butterfly 安装文档(五)更新日誌 收益没日没夜的折腾了两天，总能从其中学到什么：其一，当然是收获了又骚又实用的好网站；其二，学会了git+github的基本使用，常见的git命令也记得很熟；其三，收获了一种精神——永不放弃，哪有什么一帆风顺，加油，骚年！ 不足自己的网站弄的也不是很成熟，还有很多功能没有上线，比如日历、赞赏等，自己没有买域名，只是托管到github上。 欢迎我的个人网站","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"PYTHON中print格式化输出用法","slug":"PYTHON中print格式化输出用法","date":"2020-05-06T06:02:49.000Z","updated":"2020-06-21T15:30:29.083Z","comments":true,"path":"2020/05/06/PYTHON中print格式化输出用法/","link":"","permalink":"http://liuhaotian.top/2020/05/06/PYTHON%E4%B8%ADprint%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%94%A8%E6%B3%95/","excerpt":"","text":"Python中print用法里面% 、%s 、 % d 代表的意思语法%s表示格化式一个对象为字符%d表示格化式一个对象为整数%字符：标记转换说明符的开始在%的左侧放置一个字符串（格式化字符串），右侧放置希望格式化的值 123\"Hello, %s\"%\"zhang3\" =&gt; \"Hello, zhang3\"\"%d\"%33 =&gt; \"33\"\"%s:%d\"%(\"ab\",3) =&gt; \"ab:3\" 示例 12'%s plus %s equals %s' % (1,2,2)Out[29]: '1 plus 2 equals 2' 1234567LOTTERY_PRE = \"LXG_LOT_\"LOTTERY_ITEM = LOTTERY_PRE + '%s_ITEM'new_version = \"20181007220245756\"new_lobbery_item = LOTTERY_ITEM % new_versionprint(new_lobbery_item)输出 LXG_LOT_20181007220245756_ITEM %s 字符串1234567891011121314151617181920212223242526272829303132string=\"hello\"print(\"string=%s\" % string) # output: string=hello# %2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是helloprint(\"string=%2s\" % string) # output: string=hello# %7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格# 所以%7s的打印结果是 helloprint(\"string=%7s\" % string)# output: string= hello# %-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格# 所以%-7s的打印结果是hello !print(\"string=%-7s!\" % string)# output: string=hello !# %.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是heprint(\"string=%.2s\" % string) # output: string=he# %.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身# 所以%.7s的打印结果是helloprint(\"string=%.7s\" % string)# output: string=hello# %a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串# 当截取的字符串长度小于a时，还需要在其左侧补空格print(\"string=%7.2s\" % string )# output: string= heprint(\"string=%2.7s\" % string )# output: string=helloprint(\"string=%10.7s\" % string) # output: string= hello# 还可以用%.s来表示精度，两个*的值分别在后面小括号的前两位数值指定print(\"string=%*.*s\" % (7,2,string)) # output: string= he %d 整型1234567891011121314151617181920212223242526272829303132333435num=14# %d打印时结果是14print(\"num=%d\" % num) # output: num=14# %1d意思是打印结果为1位整数，当整数的位数超过1位时，按整数原值打印，所以%1d的打印结果还是14print(\"num=%1d\" % num) # output: num=14# %3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数左侧补空格，所以%3d的打印结果是 14print(\"num=%3d\" % num) # output: num= 14# %-3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数右侧补空格，所以%3d的打印结果是14_print(\"num=%-3d!\" % num) # output: num=14 !# %05d意思是打印结果为5位整数，当整数的位数不够5位时，在整数左侧补0，所以%05d的打印结果是00014print(\"num=%05d\" % num) # output: num=00014# %.3d小数点后面的3意思是打印结果为3位整数，# 当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果是014print(\"num=%.3d\" % num) # output: num=014# %.0003d小数点后面的0003和3一样，都表示3，意思是打印结果为3位整数，# 当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果还是014print(\"num=%.0003d\" % num) # output: num=014# %5.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，再在左侧补空格，# 规则就是补0优先，最终的长度选数值较大的那个，所以%5.3d的打印结果还是 014print(\"num=%5.3d\" % num)# output: num= 014# %05.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，# 由于是05，再在左侧补0，最终的长度选数值较大的那个，所以%05.3d的打印结果还是00014print(\"num=%05.3d\" % num) # output: num=00014# 还可以用%.d来表示精度，两个*的值分别在后面小括号的前两位数值指定print(\"num=%*.*d\" % (4,3,num)) # output: num= 014 %f 浮点型1234567891011121314151617181920import math# %a.bf，a表示浮点数的打印长度，b表示浮点数小数点后面的精度# 只是%f时表示原值，默认是小数点后5位数print(\"PI=%f\" % math.pi) # output: PI=3.141593# 只是%9f时，表示打印长度9位数，小数点也占一位，不够左侧补空格print(\"PI=%9f\" % math.pi) # output: PI= 3.141593# 只有.而没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补0print(\"PI=%03.f\" % math.pi) # output: PI=003# %6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够左侧补空格print(\"PI=%6.3f\" % math.pi) # output: PI= 3.142# %-6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够右侧补空格print(\"PI=%-6.3f!\" % math.pi) # output: PI=3.142 !# 还可以用%.f来表示精度，两个*的值分别在后面小括号的前两位数值指定print(\"PI=%*.*f\" % (6,3,math.pi)) # output: PI= 3.142","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]},{"title":"PYTHON中zip()与zip(*)的用法","slug":"PYTHON中zip-与zip-的用法","date":"2020-05-06T05:46:32.000Z","updated":"2020-06-21T15:30:22.776Z","comments":true,"path":"2020/05/06/PYTHON中zip-与zip-的用法/","link":"","permalink":"http://liuhaotian.top/2020/05/06/PYTHON%E4%B8%ADzip-%E4%B8%8Ezip-%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"PYTHON中zip()与zip(*)的用法可以看成是zip()为压缩，zip(*)是解压 zip()与zip(*)举一个示例代码来说明 123456789101112131415161718192021222324252627282930313233a = [1, 2, 3]b = [4, 5, 6]c = [4, 5, 6, 7, 8]a_b_zip = zip(a, b) # 打包为元组的列表,而且元素个数与最短的列表一致print(\"type of a_b_zip is %s\" % type(a_b_zip)) # 输出zip函数的返回对象类型a_b_zip = list(a_b_zip) # 因为zip函数返回一个zip类型对象，所以需要转换为list类型print(a_b_zip)print(\"------------------------------------------\")a_c_zip = zip(a, c)a_c_zip = list(a_c_zip)print(a_c_zip)nums = [['a1', 'a2', 'a3'], ['b1', 'b2', 'b3'], ['c1', 'c2', 'c3']]iterator = zip(*nums) # 参数为list数组时，是压缩数据，相当于zip()函数print(\"type of iterator is %s\" % type(iterator)) # 输出zip(*zipped)函数返回对象的类型iterator = list(iterator) # 因为zip(*zipped)函数返回一个zip类型对象，所以需要转换为list类型print(iterator)print(\"------------------------------------------\")print(\"a_b_zip ：\", a_b_zip)print(\"zip(*a_b_zip) ：\", list(zip(*a_b_zip)))结果：type of a_b_zip is &lt;class 'zip'&gt;[(1, 4), (2, 5), (3, 6)]------------------------------------------[(1, 4), (2, 5), (3, 6)]type of iterator is &lt;class 'zip'&gt;[('a1', 'b1', 'c1'), ('a2', 'b2', 'c2'), ('a3', 'b3', 'c3')]------------------------------------------a_b_zip ： [(1, 4), (2, 5), (3, 6)]zip(*a_b_zip) ： [(1, 2, 3), (4, 5, 6)] ps：zip()函数的返回对象转换成list不是必须的，只是为了方便输出，list输出很直观 用zip()反转字典12345678910m &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;m.items()print(list(zip(m.values(), m.keys())))mi &#x3D; dict(zip(m.values(), m.keys()))print(mi)结果：[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;d&#39;)]&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;&#125;","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]},{"title":"PYTHON中strip()、lstrip()、rstrip()用法详解","slug":"PYTHON中strip-、lstrip-、rstrip-用法详解","date":"2020-05-04T09:13:24.000Z","updated":"2020-06-21T15:30:19.460Z","comments":true,"path":"2020/05/04/PYTHON中strip-、lstrip-、rstrip-用法详解/","link":"","permalink":"http://liuhaotian.top/2020/05/04/PYTHON%E4%B8%ADstrip-%E3%80%81lstrip-%E3%80%81rstrip-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"PYTHON中strip()、lstrip()、rstrip()用法详解Python中有三个去除头尾字符、空白符的函数，它们依次为: strip： 用来去除头尾字符、空白符(换行、回车、制表符、空格)lstrip：用来去除开头字符、空白符(换行、回车、制表符、空格)rstrip：用来去除结尾字符、空白符(换行、回车、制表符、空格) 注意：这些函数都只会删除头和尾的字符，中间的不会删除 用法分别为：123string.strip([chars])string.lstrip([chars])string.rstrip([chars]) 参数chars是可选的，当chars为空，默认删除string头尾的空白符 当chars不为空时，函数会被chars解成一个个的字符，然后将这些字符去掉 它返回的是去除头尾字符(或空白符)的string副本，string本身不会发生改变 举例说明如下： 当chars为空时，默认删除空白符 12345678910&gt;&gt;&gt; str = ' ab cd '&gt;&gt;&gt; str.strip() #删除头尾空格'ab cd'&gt;&gt;&gt; str.lstrip() #删除开头空格'ab cd '&gt;&gt;&gt; str.rstrip() #删除结尾空格' ab cd' 当chars不为空时，函数会被chars解成一个个的字符，然后将这些字符去掉 12345678910&gt;&gt;&gt; str2 = '1a2b12c21'&gt;&gt;&gt; str2.strip('12') #删除头尾的1和2'a2b12c'&gt;&gt;&gt; str2.lstrip('12') #删除开头的1和2'a2b12c21'&gt;&gt;&gt; str2.rstrip('12') #删除结尾的1和2'1a2b12c'","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]},{"title":"PYTHON中反转字符串的三种方法","slug":"PYTHON中反转字符串的三种方法","date":"2020-05-04T07:40:48.000Z","updated":"2020-06-21T15:30:25.951Z","comments":true,"path":"2020/05/04/PYTHON中反转字符串的三种方法/","link":"","permalink":"http://liuhaotian.top/2020/05/04/PYTHON%E4%B8%AD%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"PYTHON中反转字符串的三种方法1.切片法（最简洁的一种）1234567891011def reverse1(): s = input(\"请输入需要反转的内容：\") return s[::-1]print(reverse1())#运行结果请输入需要反转的内容：莺啼岸柳弄春晴 柳弄春晴夜月明明月夜晴春弄柳 晴春弄柳岸啼莺 This is extended slice syntax. It works by doing [begin:end:step] - by leaving begin and end off and specifying a step of -1, it reverses a string.这是扩展片语法。它的工作方式是[begin:end:step]-离开begin和end并指定步骤-1，它反转字符串。 2.递归12345678910def reverse2(s): if s==\"\": return s else: return reverse2(s[1:])+s[0]print(reverse2(\"莺啼岸柳弄春晴 柳弄春晴夜月明\"))#运行结果明月夜晴春弄柳 晴春弄柳岸啼莺 3.借用列表的reverse()方法 reverse()函数将列表的内容进行了反转，借助这个特性，可以先将字符串转换成列表，利用reverse()函数进行反转后，再处理成字符串。 123456789def reverse3(s): l=list(s) l.reverse() return (\"\".join(l))print(reverse3(\"莺啼岸柳弄春晴 柳弄春晴夜月明\"))#运行结果明月夜晴春弄柳 晴春弄柳岸啼莺","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]},{"title":"PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点","slug":"PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点","date":"2020-05-04T07:17:15.000Z","updated":"2020-06-21T15:30:38.555Z","comments":true,"path":"2020/05/04/PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点/","link":"","permalink":"http://liuhaotian.top/2020/05/04/PYTHON%E4%B8%ADisdigit-%E3%80%81isalpha-%E3%80%81isalnum-%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/","excerpt":"","text":"PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点isdigit()python关于isdigit()内置函数的官方定义： S.isdigit() -&gt; bool Return True if all characters in S are digits and there is at least one character in S, False otherwise. 翻译： S.isdigit()返回的是布尔值：True、FalseS字符串中至少有一个字符且如果S中的所有字符都是数字，那么返回结果就是True；否则，就返回False 123456789101112131415161718S1 = '12345' #纯数字S2 = '①②' #带圈的数字S3 = '汉字' #汉字S4 = '%#￥' #特殊符号S5 = '12345a' #数字和字母print(S1.isdigit())print(S2.isdigit())print(S3.isdigit())print(S4.isdigit())print(S5.isdigit())# 执行结果：True TrueFalseFalseFalse isalpha()python关于isalpha()内置函数的官方定义： S.isalpha() -&gt; bool Return True if all characters in S are alphabetic and there is at least one character in S, False otherwise. 翻译：S.isalpha()返回的是布尔值：True、FalseS字符串中至少有一个字符且如果S中的所有字符都是字母，那么返回结果就是True；否则，就返回False 123456789101112S1 = 'abc汉字' #汉字+字母S2 = 'ab字134' #包含数字S3 = '*&amp;&amp;' #特殊符号print(S1.isalpha())print(S2.isalpha())print(S3.isalpha())#执行结果TrueFalseFalse isalnum()python关于isalnum()内置函数的官方定义： S.isalnum() -&gt; bool Return True if all characters in S are alphanumeric and there is at least one character in S, False otherwise. 翻译： S.isalnum()返回的是布尔值：True、FalseS中至少有一个字符且如果S中的所有字符都是字母数字，那么返回结果就是True；否则，就返回False 123456789101112S1 = 'abc汉字1' #字母+汉字+数字S2 = '①②③' #带圈的数字S3 = '%……&amp;' #特殊符号print(S1.isalnum())print(S2.isalnum())print(S3.isalnum())#执行结果TrueTrueFalse 注意 python官方定义中的字母：大家默认为英文字母+汉字即可 python官方定义中的数字：大家默认为Unicode数字、byte数字（单字节）、全角数字（双字节）、罗马数字、带圈的数字即可","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]},{"title":"PYTHON中join函数的用法","slug":"PYTHON中join函数的用法","date":"2020-05-04T06:52:29.000Z","updated":"2020-06-21T15:30:36.039Z","comments":true,"path":"2020/05/04/PYTHON中join函数的用法/","link":"","permalink":"http://liuhaotian.top/2020/05/04/PYTHON%E4%B8%ADjoin%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"PYTHON中join函数的用法Python中有.join()和os.path.join()两个函数，具体作用如下： .join()：连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串os.path.join()：将多个路径组合后返回 对序列进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）1234567891011121314151617a=['1','2','3','4','5']&gt;&gt; ' '.join(a)1 2 3 4 5&gt;&gt; ''.join(a)12345&gt;&gt;'-'.jion(a)1-2-3-4-5&gt;&gt;'.'.join(a)1.2.3.4.5 对字符串进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）12345678910111213b='hello world'&gt;&gt; ' '.join(b)h e l l o w o r l d&gt;&gt;'-' .join(b)h-e-l-l-o- -w-o-r-l-d&gt;&gt;':'.jion(b)h:e:l:l:o: :w:o:r:l:d 对元组进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）12345678910111213c=('1','2','3','4','5')&gt;&gt;' '.join(c)1 2 3 4 5&gt;&gt;'-'.join(c)1-2-3-4-5&gt;&gt;':'.join(c)1:2:3:4:5 对字典进行无序操作（分别使用’ ‘、’-‘与’:’作为分隔符）12345678910111213d=&#123;'name1':'a','name2':'b','name3':'c','name4':'d'&#125;&gt;&gt;' '.jion(d)name1 name2 name3 name4&gt;&gt;'-'.join(d)name1-name2-name3-name4&gt;&gt;':'.join(d)name1:name2:name3:name4 对目录进行操作12345import osos.path.join('/hello/','good/date','datbody')hello/good/date/datbody","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]},{"title":"PYTHON中max函数的lambda表达式用法","slug":"PYTHON中max函数的lambda表达式用法","date":"2020-05-03T08:59:07.000Z","updated":"2020-06-21T15:30:32.610Z","comments":true,"path":"2020/05/03/PYTHON中max函数的lambda表达式用法/","link":"","permalink":"http://liuhaotian.top/2020/05/03/PYTHON%E4%B8%ADmax%E5%87%BD%E6%95%B0%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/","excerpt":"","text":"PYTHON中max函数的lambda表达式用法引入由一道leetcode题来引入PYTHON中max函数的lambda表达式用法5. 最长回文子串 1234567891011121314class Solution: def longestPalindrome(self, s: str) -&gt; str: p = '' for i in range(len(s)): p1 = self.get_palindrome(s, i, i+1) p2 = self.get_palindrome(s, i, i) p = max([p, p1, p2], key=lambda x: len(x)) return p def get_palindrome(self, s: str, l: int, r: int) -&gt; str: while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1 r += 1 return s[l+1:r] max([p, p1, p2], key=lambda x: len(x))的含义就是本文章的内容 lambda表达式介绍在学习python的过程中，lambda的语法时常会使人感到困惑，lambda是什么，为什么要使用lambda，是不是必须使用lambda？ lambda是什么？我们来看此表达式：g = lambda x:x+1，看一下执行的结果：g(1)==2、g(2)==3,当然，你也可以这样使用：lambda x:x+1(1)，结果为2可以这样认为,lambda作为一个表达式，定义了一个匿名函数，上例的代码x为入口参数，x+1为函数体，用函数来表示为:12def g(x): return x+1 lambda定义了一个匿名函数 lambda并不会带来程序运行效率的提高，只会使代码更简洁 如果可以使用for...in...if来完成的，坚决不用lambda 如果使用lambda，lambda内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。 总结：lambda是为了减少单行函数的定义而存在的 max函数中的lambda表达式现在回到我们的max函数中，就十分容易理解了:函数形式：max( x ,key=lambda a : b )，x可以是任何数值，可以有多个x值这个函数的意思是：我们先把x值带入lambda函数转换成b值，然后再将b值进行比较1234567haha0=max('az','za', key=lambda a: a[0])haha1=max('az','za', key=lambda a: a[1])haha2=max(range(10),key=lambda a:a&gt;3) print(haha0) #输出zaprint(haha1) #输出azprint(haha2) #输出4 以haha0为例子：我们传入az，za，为了方便解释称之为虚拟比较，但是因为我们引入了lambda表达式，所以，我们实际上比较的是，az中的第一位a和za中第一位的z，由ascii码表可以知道a是小于z的，所以在这里最大的是z，那么我们返回的就是z的虚拟比较变量，也就是本来的za。 haha2的用法十分少见，实际上比较的是:F F F T T T T T T T ( False 和 True ) T是肯定比F大的，但是一堆True哪里能互相比较大小呢，所以就输出第一个True值的虚拟比较变量，也就是4 max中带有lambda的这个写法的意义在于代码变得更简洁 假如我们有一个字典，里面记录着人名和相应年龄，现在我们想要在里面筛选出年龄最大的那个人的一条字典记录123x=&#123;\"老王\" :18 , \"小李\":99&#125;haha3=max(x.items(), key=lambda a: a[1])print(haha3) #输出('小李', 99) 要注意使用字典的话一定要x.items()，不能直接输入x值，达不到我们想要的效果 其实我们大可不必这么写，直接从字典中提取出年龄列表进行比较：123456x=&#123;\"老王\" :18 , \"小李\":99&#125;y=[]for name,age in x.items(): y.append(age)haha4=max(y)print(haha4) 只是这样写是比较麻烦以及浪费内存的不是么？我想这就是max函数中设置lambda表达式的意义 再举两个例子： 取第一维123num = [(1,2.5), (1.5, 3.2), (1.3, 4.0), (2.2, 1.8)]y,z = max(num, key=lambda x:x[0])print(y, z) #结果为2.2 1.8 取第二维123num = [(1,2.5), (1.5, 3.2), (1.3, 4.0), (2.2, 1.8)]y,z = max(num, key=lambda x:x[1])print(y, z) #结果为1.3 4.0","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"}]}],"categories":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/categories/ACM/"},{"name":"大佬经历","slug":"大佬经历","permalink":"http://liuhaotian.top/categories/%E5%A4%A7%E4%BD%AC%E7%BB%8F%E5%8E%86/"},{"name":"随笔","slug":"随笔","permalink":"http://liuhaotian.top/categories/%E9%9A%8F%E7%AC%94/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"},{"name":"C/C++","slug":"C-C","permalink":"http://liuhaotian.top/categories/C-C/"},{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/categories/LEETCODE/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://liuhaotian.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"ACWING算法基础课总结","slug":"ACWING算法基础课总结","permalink":"http://liuhaotian.top/tags/ACWING%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E6%80%BB%E7%BB%93/"},{"name":"大佬经历","slug":"大佬经历","permalink":"http://liuhaotian.top/tags/%E5%A4%A7%E4%BD%AC%E7%BB%8F%E5%8E%86/"},{"name":"随笔","slug":"随笔","permalink":"http://liuhaotian.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"},{"name":"CODEFORCES/比赛","slug":"CODEFORCES-比赛","permalink":"http://liuhaotian.top/tags/CODEFORCES-%E6%AF%94%E8%B5%9B/"},{"name":"PYTHON语法","slug":"PYTHON语法","permalink":"http://liuhaotian.top/tags/PYTHON%E8%AF%AD%E6%B3%95/"},{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/tags/C-C-%E5%B8%B8%E7%94%A8API/"},{"name":"LEETCODE/比赛","slug":"LEETCODE-比赛","permalink":"http://liuhaotian.top/tags/LEETCODE-%E6%AF%94%E8%B5%9B/"},{"name":"力扣/python","slug":"力扣-python","permalink":"http://liuhaotian.top/tags/%E5%8A%9B%E6%89%A3-python/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://liuhaotian.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}
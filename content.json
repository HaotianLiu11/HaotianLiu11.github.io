{"meta":{"title":"福江 の いえ","subtitle":"富江江江江","description":"一只孜孜不倦的程序猿，立志把分享变成一种习惯！","author":"Fu JANG","url":"http://liuhaotian.top","root":"/"},"pages":[{"title":"留言板","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-29T12:23:57.525Z","comments":true,"path":"comments/index.html","permalink":"http://liuhaotian.top/comments/index.html","excerpt":"","text":"欢迎大家留言给我鸭，我都会看到的~"},{"title":"友链","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T13:39:16.948Z","comments":true,"path":"link/index.html","permalink":"http://liuhaotian.top/link/index.html","excerpt":"","text":"想分享友情链接的小伙伴留言即可~"},{"title":"分类","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T04:57:46.858Z","comments":false,"path":"categories/index.html","permalink":"http://liuhaotian.top/categories/index.html","excerpt":"","text":""},{"title":"音乐","date":"2020-05-27T11:17:35.000Z","updated":"2020-05-27T12:07:16.641Z","comments":false,"path":"music/index.html","permalink":"http://liuhaotian.top/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T04:58:17.182Z","comments":false,"path":"tags/index.html","permalink":"http://liuhaotian.top/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-05-27T09:20:50.000Z","updated":"2020-08-17T11:14:41.642Z","comments":true,"path":"about/index.html","permalink":"http://liuhaotian.top/about/index.html","excerpt":"","text":"征婚启事我是个普普通通的大二学生，来自普普通通的大学，有着普普通通的生活，不知不觉已经19了，最大的梦想是找个女朋友！ 不过要实现找个妞陪我的梦想好难好难，所以我退而求其次，希望自己未来可以过一个好生活，然后再找个妞，曲线救国哈哈哈。 不过未来想活的好就得有money呀，虽然俗气了一些。但是毕竟贫贱夫妻百事哀嘛，所以为了给将来的老婆买包，我要努力努力努力努力努力努力！！！ 最近想努力奋斗，然后在ACM或者蓝桥杯中拿个好名次，and now自己同时在学习编程知识(后端开发)，不过学业荒废了好久emmmmm… 联系方式热烈欢迎女同学来找我玩儿！！五大三粗并且要请教问题的汉子就不要加了emmmm我怕入坑… QQ： 2235749416 微信： a13019949398 日常热爱超喜欢你的名字、天气之子、大鱼海棠，因为女主都好温柔啊~ 还喜欢听音乐，温柔中带一点点忧郁那种类型，emmmm,当然也喜欢敲代码…还有我超级老实，一个本分的孩子就是我啦! 个人性格也很多愁善感，超级善变，泪点超低。就叨咕这么多啦~ 附图一张"}],"posts":[{"title":"LC 第 203 场周赛","slug":"LC-第-203-场周赛","date":"2020-09-04T08:05:32.000Z","updated":"2020-09-04T08:10:15.395Z","comments":true,"path":"2020/09/04/LC-第-203-场周赛/","link":"","permalink":"http://liuhaotian.top/2020/09/04/LC-%E7%AC%AC-203-%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"","text":"LC 第 203 场周赛1560. 圆形赛道上经过次数最多的扇区题意给你一个整数 n 和一个整数数组 rounds 。有一条圆形赛道由 n 个扇区组成，扇区编号从 1 到 n 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 m 个阶段组成。其中，第 i 个阶段将会从扇区 rounds[i - 1] 开始，到扇区 rounds[i] 结束。举例来说，第 1 阶段从 rounds[0] 开始，到 rounds[1] 结束。 请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。 注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。 思路因为 rounds.length 一定大于大于 2，所以我们只需要考虑 rounds.front 和 rounds.back 就可以了，前者代表第一个阶段从此扇形区域开始跑，后者代表最后一圈跑到此扇形区域截止，因此 rounds.front 到 n 和 1 到 rounds.back 所经过的扇形中重复次数多的即为我们所求。 复杂度O(nlogn) 代码123456789101112131415class Solution &#123; public: vector&lt;int&gt; mostVisited(int n, vector&lt;int&gt;&amp; rounds) &#123; vector&lt;int&gt; res; int st = rounds.front(); while (st != rounds.back()) &#123; res.push_back(st); st++; st = (st &gt; n ? st % n : st); &#125; res.push_back(rounds.back()); sort(res.begin(), res.end()); return res; &#125;&#125;; 收获充满自信！ 1561. 你可以获得的最大硬币数目题意有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币： 每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。 Alice 将会取走硬币数量最多的那一堆。 你将会取走硬币数量第二多的那一堆。 Bob 将会取走最后一堆。 重复这个过程，直到没有更多硬币。 给你一个整数数组 piles ，其中 piles[i] 是第 i 堆中硬币的数目。 返回你可以获得的最大硬币数目。 思路把数组从大到小排序，从头到截止部分（不是数组尾部）依次取两个，累加每次取的两个数中较小的那个，此和即为所求。 复杂度O(nlogn) 代码12345678910class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; piles) &#123; sort(piles.begin(), piles.end()); int res = 0; for (int i = 0, j = piles.size() - 1; i &lt; j; i++, j -= 2) res += piles[j - 1]; return res; &#125;&#125;; 收获充满自信！ 1562. 查找大小为 M 的最新分组题意给你一个数组 arr ，该数组表示一个从 1 到 n 的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。 在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 arr[i] 的位将会设为 1 。 给你一个整数 m ，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。 返回存在长度 恰好 为 m 的一组 1 的最后步骤。如果不存在这样的步骤，请返回 -1 。 思路维护双链表，设 l[x] 为 x 的左端点，设 r[x] 为 x 的右端点。当 l[x] 和 r[x] 不为 0 时，x 到 r[x] 或者 l[x] 到 x 为一段连续的 1。 复杂度O(n) 代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public: vector&lt;int&gt; l, r; int get(int x) &#123; return r[x] - x + 1; &#125; int findLatestStep(vector&lt;int&gt;&amp; arr, int m) &#123; int n = arr.size(); l.resize(n + 2), r.resize(n + 2); int cnt = 0, res = -1; for (int i = 0; i &lt; arr.size(); i++) &#123; int x = arr[i]; if (l[x - 1] &amp;&amp; r[x + 1]) &#123; if (get(l[x - 1]) == m) cnt--; if (get(x + 1) == m) cnt--; r[l[x - 1]] = r[x + 1]; l[r[x + 1]] = l[x - 1]; if (get(l[x - 1]) == m) cnt++; &#125; else if (l[x - 1]) &#123; if (get(l[x - 1]) == m) cnt--; r[l[x - 1]] = x, l[x] = l[x - 1]; if (get(l[x - 1]) == m) cnt++; &#125; else if (r[x + 1]) &#123; if (get(x + 1) == m) cnt--; l[r[x + 1]] = x, r[x] = r[x + 1]; if (get(x) == m) cnt++; &#125; else &#123; l[x] = r[x] = x; if (m == 1) cnt++; &#125; if (cnt) res = i + 1; &#125; return res; &#125;&#125;; 收获涨知识emmmm 1563. 石子游戏 V题意几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。 游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。 只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。 返回 Alice 能够获得的最大分数 。 思路区间 DP 类型题。 复杂度O(n^3)，勉强能冲emmmm 如果在双重枚举 len 循环内再加个 for，会 TLE，因此代码用自增存值，避免反复取值拿前缀和，计算机取值时间消耗高，这样减少常数，勉强能过，此题可以把双重 len 循环内再加个 for 要写的状态再加个 dp，可优化到 O(ln^2logn)。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public: vector&lt;int&gt; s; int get(int l, int r) &#123; return s[r] - s[l - 1]; &#125; int stoneGameV(vector&lt;int&gt;&amp; w) &#123; int n = w.size(); s.resize(n + 1); for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + w[i - 1]; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1)); for (int len = 2; len &lt;= n; len++) for (int i = 1; i + len - 1 &lt;= n; i++) &#123; int j = i + len - 1, sum = get(i, j), k = i, p = w[i - 1]; int t = 0; while (p &lt; sum - p) &#123; if (t &lt; p + f[i][k]) t = p + f[i][k]; p += w[k++]; &#125; if (p == sum - p) &#123; if (t &lt; p + max(f[i][k], f[k + 1][j])) t = p + max(f[i][k], f[k + 1][j]); p += w[k++]; &#125; while (k &lt; j) &#123; if (t &lt; sum - p + f[k + 1][j]) t = sum - p + f[k + 1][j]; p += w[k++]; &#125; f[i][j] = t; &#125; return f[1][n]; &#125;&#125;; 收获知道了卡常这东西emmmm","categories":[{"name":"LC 周赛","slug":"LC-周赛","permalink":"http://liuhaotian.top/categories/LC-%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"LC 第 33 场双周赛","slug":"LC-第-33-场双周赛","date":"2020-09-03T08:05:54.000Z","updated":"2020-09-04T08:11:13.786Z","comments":true,"path":"2020/09/03/LC-第-33-场双周赛/","link":"","permalink":"http://liuhaotian.top/2020/09/03/LC-%E7%AC%AC-33-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/","excerpt":"","text":"LC 第 33 场双周赛1556. 千位分隔数题意给你一个整数 n，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。 思路先把整数转为字符串，遍历字符串，在符合条件的位置上加上点。 复杂度O(n) 代码12345678910111213class Solution &#123;public: string thousandSeparator(int n) &#123; string num = to_string(n); string res; for (int i = num.size() - 1, j = 0; i &gt;= 0; i--, j++) &#123; if (j % 3 == 0 &amp;&amp; j) res += '.'; res += num[i]; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 收获充满自信！ 1557. 可以到达所有点的最少点数目题意给你一个 有向无环图 ， n 个节点编号为 0 到 n-1 ，以及一个边数组 edges ，其中 edges[i] = [fromi, toi] 表示一条从点 fromi 到点 toi 的有向边。 找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。 你可以以任意顺序返回这些节点编号。 思路入读为 0 的节点一定不能被其余点遍历，入度不为 0 的点一定能被其余点遍历，统计入度为 0 的点的个数即为答案。 复杂度O(n) 代码1234567891011121314class Solution &#123;public: vector&lt;int&gt; findSmallestSetOfVertices(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;int&gt; d(n); for (auto &amp;e : edges) d[e[1]]++; vector&lt;int&gt; res; for (int i = 0; i &lt; n; i++) if (!d[i]) res.push_back(i); return res; &#125;&#125;; 收获充满自信！ 1558. 得到目标数组的最少函数调用次数题意 给你一个与 nums 大小相同且初始值全为 0 的数组 arr ，请你调用以上函数得到整数数组 nums 。 请你返回将 arr 变成 nums 的最少函数调用次数。 答案保证在 32 位有符号整数以内。 思路贪心的思想，假设一个数字的二进制有 k 位，那么把它从 0 变为目标数字时，会左移 k-1 位，并在左移的过程中穿插着 +1 的步骤，所以把 0 变为目标数一共需要 k-1+n，n 为二进制中 1 的个数。 对于此题来说，我们找到最大的数的位数 k，然后对于所有数都左移 k-1 次，并在左移过程中对一部分数 +1。 代码1234567891011121314151617class Solution &#123;public: int minOperations(vector&lt;int&gt;&amp; nums) &#123; int k = 0, o = 0; for (auto x : nums) &#123; int ones = 0, bits = 0; while (x) &#123; if (x &amp; 1) ones++; bits++; x &gt;&gt;= 1; &#125; k = max(k, bits); o += ones; &#125; return k - 1 + o; &#125;&#125;; 收获涨知识emmmm 1559. 二维网格图中探测环题意给你一个二维字符网格数组 grid ，大小为 m x n ，你需要检查 grid 中是否存在 相同值 形成的环。 一个环是一条开始和结束于同一个格子的长度 大于等于 4 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 相同的值 。 同时，你也不能回到上一次移动时所在的格子。比方说，环 (1, 1) -&gt; (1, 2) -&gt; (1, 1) 是不合法的，因为从 (1, 2) 移动到 (1, 1) 回到了上一次移动时的格子。 如果 grid 中有相同值形成的环，请你返回 true ，否则返回 false 。 思路dfs 遍历，设状态 st，初次遍历一个方格时，st 从 0 变为 1，当再次遍历到 st 为 1 的点时，证明有环，注意 dfs 爆搜时不能往上一次的相反方向搜，也就是第一次向下搜，第二次不能向上搜，我们用位运算 符 ^ 来满足此条件。 代码1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;char&gt;&gt; g; vector&lt;vector&lt;bool&gt;&gt; st; bool containsCycle(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; g = grid; st = vector&lt;vector&lt;bool&gt;&gt;(g.size(), vector&lt;bool&gt;(g[0].size())); for (int i = 0 ; i &lt; g.size(); i++) for (int j = 0; j &lt; g[0].size(); j++) if (!st[i][j] &amp;&amp; dfs(i, j, -1)) return true; return false; &#125; int dx[4] = &#123;0, 0, -1, 1&#125;; int dy[4] = &#123;-1, 1, 0, 0&#125;; bool dfs(int x, int y, int p) &#123; st[x][y] = true; for (int i = 0; i &lt; 4; i++) if (i != p) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; g.size() &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; g[0].size() &amp;&amp; g[x][y] == g[a][b]) &#123; if (st[a][b]) return true; if (dfs(a, b, i ^ 1)) return true; &#125; &#125; return false; &#125;&#125;; 收获充满自信！第一次把 ^ 用于图论相反边 知识点用在了题目上！","categories":[{"name":"LC 周赛","slug":"LC-周赛","permalink":"http://liuhaotian.top/categories/LC-%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"LC 第 204 场周赛","slug":"LC-第-204-场周赛","date":"2020-09-02T00:27:33.000Z","updated":"2020-09-04T08:08:35.992Z","comments":true,"path":"2020/09/02/LC-第-204-场周赛/","link":"","permalink":"http://liuhaotian.top/2020/09/02/LC-%E7%AC%AC-204-%E5%9C%BA%E5%91%A8%E8%B5%9B/","excerpt":"","text":"LC 第 204 场周赛1566. 重复至少 K 次且长度为 M 的模式题意给你一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。 模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。 如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true ，否则返回 false 。 思路由于 m 和 k 的范围很小，所以我们采取暴力法，遍历数组的所有符合条件的元素，查看以该元素为起始点的 m * k 的序列是否为定义的模式，且符合条件。 复杂度双重循环，时间复杂度为 O(n ^ 2)。 代码12345678910111213141516class Solution &#123; public: bool containsPattern(vector&lt;int&gt;&amp; arr, int m, int k) &#123; int n = arr.size(); for (int i = 0; i + m * k &lt;= n; i++) &#123; bool flag = true; for (int j = i; j &lt; i + m * k; j++) &#123; if (arr[j] != arr[i + (j - i) % m]) &#123; flag = false; &#125; &#125; if (flag) return true; &#125; return false; &#125;&#125;; 收获假设两个指针 i 在前，j 在后， 那么 j - i 为 j 对 i 的偏移量，而 j - i + 1 为 [i, j] 的长度。 1567. 乘积为正数的最长子数组长度题意给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。 请你返回乘积为正数的最长子数组长度。 思路数组中有三类元素，分别为正数、负数、零，所以我们可以用 DP 来做这道题。 我们令 f[i] 代表以 i 为终止点且数组元素乘积为正数的最大的序列；我们令 g[i] 代表以 i 为终止点且数组元素乘积为负数的最大的序列。 复杂度DP 遍历，g 算一次，f 算一次，时间复杂度为 O(n)。 代码1234567891011121314151617181920212223242526class Solution &#123; public: int getMaxLen(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; f(n), g(n); if (nums[0] &gt; 0) f[0] = 1; else if (nums[0] &lt; 0) g[0] = 1; int res = f[0]; for (int i = 1; i &lt; n; i++) &#123; if (nums[i] &gt; 0) &#123; f[i] = f[i - 1] + 1; if (g[i - 1]) g[i] = g[i - 1] + 1; &#125; else if (nums[i] &lt; 0) &#123; g[i] = f[i - 1] + 1; if (g[i - 1]) f[i] = g[i - 1] + 1; &#125; res = max(res, f[i]); &#125; return res; &#125;&#125;; 收获收获是啥？见识了新东西？更熟悉 DP？ 1568. 使陆地分离的最少天数题意给你一个由若干 0 和 1 组成的二维网格 grid ，其中 0 表示水，而 1 表示陆地。岛屿由水平方向或竖直方向上相邻的 1 （陆地）连接形成。 如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。 一天内，可以将任何单个陆地单元（1）更改为水单元（0）。 返回使陆地分离的最少天数。 思路答案只可能是 0 或者 1 或者 2，因为如果陆地已经分离，那么不需要更改，返回 0 天。 此外，我们需要知道，一块连通的陆地分离做多需要两天，因为每块连通的陆地都有边界坐标，那么一定至少有一个坐标的陆地的四联通中的其二为水，剩余二为陆地，那么我们最多需要两天就可以把连通的陆地分离。 如果需要一天，我们则可以遍历联通陆地，依次取其中的一个坐标变为水，检测是否能让此联通的陆地分离，如果分离，则可以需要一天，如果不可以，则证明分离此陆地需要两天。 复杂度当为 1 个联通陆地时，我们遍历此连通块，依次替换单位坐标为水，时间复杂度为 n * n，每次替换之后 check 检查，所以总共的时间复杂度为 O(n^4)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int n, m; vector&lt;vector&lt;bool&gt;&gt; st; vector&lt;vector&lt;int&gt;&gt; g; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; void dfs(int x, int y) &#123; st[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; ! st[a][b] &amp;&amp; g[a][b] == 1) dfs(a, b); &#125; &#125; bool check() &#123; int cnt = 0; st = vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(m)); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; if (!st[i][j] &amp;&amp; g[i][j] == 1) &#123; cnt++; dfs(i, j); &#125; &#125; return cnt &gt; 1; &#125; int minDays(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; n = grid.size(), m = grid[0].size(); g = grid; if (check()) return 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (g[i][j]) &#123; g[i][j] = 0; if (check()) return 1; g[i][j] = 1; &#125; return 2; &#125;&#125;; 收获更加熟悉图论？题是好题，我是傻逼。 1569. 将子数组重新排序得到同一个二叉查找树的方案数题意给你一个数组 nums 表示 1 到 n 的一个排列。我们按照元素在 nums 中的顺序依次插入一个初始为空的二叉查找树（BST）。请你统计将 nums 重新排序后，统计满足如下条件的方案数：重排后得到的二叉查找树与 nums 原本数字顺序得到的二叉查找树相同。 比方说，给你 nums = [2,1,3]，我们得到一棵 2 为根，1 为左孩子，3 为右孩子的树。数组 [2,3,1] 也能得到相同的 BST，但 [3,2,1] 会得到一棵不同的 BST 。 请你返回重排 nums 后，与原数组 nums 得到相同二叉查找树的方案数。 由于答案可能会很大，请将结果对 10^9 + 7 取余数。 思路用到了组合计数，由于 C_n^m 其中的 n 和 m 的范围小于 2000，所以我们可以用杨辉三角形定理来求此组合计数并记录。 那么数组中的第一个元素的位置是确定的，不能改变，设为 k，之后所有的元素，把大于 k 的和小于 k 的元素依次存储，那么此题的答案就是两类数据（大于 k 和小于 k 的两组数据）的排序，和两组数据内部的排序的乘积。 之后对两组数据内部递归排列，每次递归会确定一个元素的次数，最后求得答案。 复杂度每次递归筛出一个元素，所以外重循环是遍历数组所有元素，每次筛时遍历数组分大小，所以时间复杂度为 O(n^2)。 代码12345678910111213141516171819202122232425262728293031typedef long long LL;class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; C; const int MOD = 1e9 + 7; int numOfWays(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); C = vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(n + 1)); for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= i; j++) if (!j) C[i][j] = 1; else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD; return (f(nums) + MOD - 1) % MOD; &#125; int f(vector&lt;int&gt; nums) &#123; if (nums.empty()) return 1; int n = nums.size(); int k = nums[0]; vector&lt;int&gt; left, right; for (auto x : nums) if (x &lt; k) left.push_back(x); else if (x &gt; k) right.push_back(x - k); return (LL)C[n - 1][k - 1] * f(left) % MOD * f(right) % MOD; &#125;&#125;; 收获拓宽视野！","categories":[{"name":"LC 周赛","slug":"LC-周赛","permalink":"http://liuhaotian.top/categories/LC-%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"HEXO+BUTTERFLY搭建骚气且实用的个人网站","slug":"HEXO-BUTTERFLY搭建骚气且实用的个人网站","date":"2020-05-27T03:01:58.000Z","updated":"2020-06-12T14:38:56.806Z","comments":true,"path":"2020/05/27/HEXO-BUTTERFLY搭建骚气且实用的个人网站/","link":"","permalink":"http://liuhaotian.top/2020/05/27/HEXO-BUTTERFLY%E6%90%AD%E5%BB%BA%E9%AA%9A%E6%B0%94%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/","excerpt":"","text":"YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS. 引子最近狂刷codeforces，但是逐渐发现自身一个问题，那就是刷过的题虽然在当天感觉很明白，但是隔一天，隔两天，就发现自己再遇到此题时又是一翻鏖战，这就是说明自己做过的题吸收的效率不够高，于是我就打算做一道题总结一道题。那么问题来了，在哪里总结呢？ 首先排除的是微信公众号，众所周知，微信公众号只能是自己分享东西的平台，而在这上面总结知识点就会引出很多问题，其一，每篇文章都要排版，其二，我的粉丝未必合此文章的胃口，其三，每天只能发布一篇文章，大大限制了自己的总结内容与时间分配。 那么诸如csdn、博客园、掘金、知乎这种东西呢？也有很多不方便的地方，比如文章左右侧的广告，实在影响人的心情，此外还有审核等等的制约，思前想后，我决定自己开辟一个个人网站。 当然不能从无到有手动开辟，自己能力有限，而且我的目的也是总结，总不能让自己以后把大把的时间浪费到维护网站上面去。于是我听从了大佬的建议，采用hexo+github的方式，hexo开辟网站，托管到github上面去。 花里胡哨的页面也是最吸引我的原因之一，我采用了butterfly的主题，绝对美炸天！ 过程过程当然是心酸+心酸+心酸，心态险些被搞没。至于搭建网站的教程，实话实说，看了n多篇技术总结，都号称史上最全，到最后还是觉得看官方文档最省事。 当然自己也找到了一些好的文章，在此列出来希望对大家有帮助： hexo安装文章： Hexo+Butterfly+Github+Coding搭建个人博客 hexo官方文档 butterfly主题系列文章： hexo-theme-butterfly 安装文档(一)快速开始 hexo-theme-butterfly 安装文档(二)主题页面 hexo-theme-butterfly 安装文档(三)主题配置 hexo-theme-butterfly 安装文档(四)主题问答、打赏名单 hexo-theme-butterfly 安装文档(五)更新日誌 收益没日没夜的折腾了两天，总能从其中学到什么：其一，当然是收获了又骚又实用的好网站；其二，学会了git+github的基本使用，常见的git命令也记得很熟；其三，收获了一种精神——永不放弃，哪有什么一帆风顺，加油，骚年！ 不足自己的网站弄的也不是很成熟，还有很多功能没有上线，比如日历、赞赏等，自己没有买域名，只是托管到github上。 欢迎我的个人网站","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"LC 周赛","slug":"LC-周赛","permalink":"http://liuhaotian.top/categories/LC-%E5%91%A8%E8%B5%9B/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://liuhaotian.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://liuhaotian.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}
{"meta":{"title":"福江 の いえ","subtitle":"富江江江江","description":"一只孜孜不倦的程序猿，立志把分享变成一种习惯！","author":"Fu JANG","url":"http://liuhaotian.top","root":"/"},"pages":[{"title":"分类","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T04:57:46.858Z","comments":false,"path":"categories/index.html","permalink":"http://liuhaotian.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T04:58:17.182Z","comments":false,"path":"tags/index.html","permalink":"http://liuhaotian.top/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-29T12:23:57.525Z","comments":true,"path":"comments/index.html","permalink":"http://liuhaotian.top/comments/index.html","excerpt":"","text":"欢迎大家留言给我鸭，我都会看到的~"},{"title":"友链","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T13:39:16.948Z","comments":true,"path":"link/index.html","permalink":"http://liuhaotian.top/link/index.html","excerpt":"","text":"想分享友情链接的小伙伴留言即可~"},{"title":"关于我","date":"2020-05-27T09:20:50.000Z","updated":"2020-05-29T16:19:14.544Z","comments":true,"path":"about/index.html","permalink":"http://liuhaotian.top/about/index.html","excerpt":"","text":"征婚启事我是个普普通通的大一学生，来自普普通通的大学，有着普普通通的生活，不知不觉已经19了，最大的梦想是找个女朋友！ 不过要实现找个妞陪我的梦想好难好难，所以我退而求其次，希望自己未来可以过一个好生活，然后再找个妞，曲线救国哈哈哈。 不过未来想活的好就得有money呀，虽然俗气了一些。但是毕竟贫贱夫妻百事哀嘛，所以为了给将来的老婆买包，我要努力努力努力努力努力努力！！！ 最近想努力奋斗，然后在ACM或者蓝桥杯中拿个好名次，and now自己同时在学习编程知识(后端开发)，不过学业荒废了好久emmmmm… 联系方式热烈欢迎女同学来找我玩儿！！五大三粗并且要请教问题的汉子就不要加了emmmm我怕入坑… QQ： 2235749416 微信： a13019949398 日常热爱超喜欢你的名字、天气之子、大鱼海棠，因为女主都好温柔啊~ 还喜欢听音乐，温柔中带一点点忧郁那种类型，emmmm,当然也喜欢敲代码…还有我超级老实，一个本分的孩子就是我啦! 个人性格也很多愁善感，超级善变，泪点超低。就叨咕这么多啦~ 附图一张"},{"title":"音乐","date":"2020-05-27T11:17:35.000Z","updated":"2020-05-27T12:07:16.641Z","comments":false,"path":"music/index.html","permalink":"http://liuhaotian.top/music/index.html","excerpt":"","text":""}],"posts":[{"title":"CODEFORCES/ROUND/647/DIV2","slug":"CODEFORCES-ROUND-647-DIV2","date":"2020-06-05T17:37:03.000Z","updated":"2020-06-05T19:22:46.347Z","comments":true,"path":"2020/06/06/CODEFORCES-ROUND-647-DIV2/","link":"","permalink":"http://liuhaotian.top/2020/06/06/CODEFORCES-ROUND-647-DIV2/","excerpt":"","text":"CODEFORCES/ROUND/647/DIV2A.Johnny and Ancient Computer难度1000，标签：implementation 描述给一个两个正整数，一个初始值，一个目标值，可以对初始值进行位运算，向左移动三位或两位或一位，或者向右移动三位或一位或两位，要求向右移动时必须除尽，舍弃小数部分的右移运算被禁止，求移动到目标值的最小次数，如果无法得到目标值则输出-1 思路如果目标值大于初始值，则左移，反之在可以右移的情况下右移，先移动位数多的，后移动位数小的，移动一次答案加一 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define IOS \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define int long longint32_t main() &#123; IOS; int t; cin &gt;&gt; t; while (t--) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; if (a == b) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int nums = 0; if (a &gt; b) &#123; while (a &gt; b) &#123; if (a &gt;&gt; 3 &gt;= b &amp;&amp; a % 8 == 0) &#123; a = a &gt;&gt; 3; nums++; continue; &#125; if (a &gt;&gt; 2 &gt;= b &amp;&amp; a % 4 == 0) &#123; a = a &gt;&gt; 2; nums++; continue; &#125; if (a &gt;&gt; 1 &gt;= b &amp;&amp; a % 2 == 0) &#123; a = a &gt;&gt; 1; nums++; continue; &#125; break; &#125; if (a == b) cout &lt;&lt; nums &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; while (a &lt; b) &#123; if (a &lt;&lt; 3 &lt;= b) &#123; a = a &lt;&lt; 3; nums++; continue; &#125; if (a &lt;&lt; 2 &lt;= b) &#123; a = a &lt;&lt; 2; nums++; continue; &#125; if (a &lt;&lt; 1 &lt;= b) &#123; a = a &lt;&lt; 1; nums++; continue; &#125; break; &#125; if (a == b) cout &lt;&lt; nums &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; &#125; return 0;&#125; B.Johnny and His Hobbies难度1200，标签：brute force 题目给一个集合，里面元素为数字，求一个最小的正整数K，使每个集合的每个元素与K进行XOR运算后集合元素等于原集合元素，意味着集合的元素顺序改变，但元素大小不改变 思路取第一个元素，求分别XOR其他元素的K，再对每个元素异或K，看看运算后的集合是否等于原集合，求出最小的K 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;#define IOS \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define endl \"\\n\"#define int long longint nums[1500];int aa[1500];int bb[1500];int32_t main() &#123; IOS; int t; cin &gt;&gt; t; while (t--) &#123; memset(aa, 0, sizeof aa); int a; cin &gt;&gt; a; int ans = 0x3f3f3f3f; for (int i = 0; i &lt; a; i++) &#123; cin &gt;&gt; nums[i]; aa[nums[i]]++; &#125; int tt = -1; for (int i = 1; i &lt; a; i++) &#123; for (int j = 1; j &lt; 1025; j++) &#123; if ((j ^ nums[0]) == nums[i]) &#123; tt = j; &#125; &#125; if (tt != -1) &#123; memset(bb, 0, sizeof bb); for (int j = 0; j &lt; a; j++) &#123; bb[nums[j] ^ tt]++; &#125; bool flag = true; for (int k = 0; k &lt; 1500; k++) &#123; if (aa[k] != bb[k]) flag = false; &#125; if (flag == true) ans = min(ans, tt); &#125; &#125; if (ans == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C.Johnny and Another Rating Drop难度1400，标签：math、dp 题目给你一个正整数，问从1到此正整数（设为每个数Ki）的二进制形式与前一位（Ki-1）的二进制形式的每位二进制不一样的数量是多少，如果两个二进制位数不同，用0来填充 假如正整数为5 则0到5的二进制分别为：000 001 010 011 100 101000和001不同的位为最低位，数量为1所以从1到5分别为：1 2 1 3 1，总共为8 思路两种思路：第一种找规律，第二种数位dp 思路1：可以发现最低位二进制一直是01变化，所以其贡献是n，倒数第二位，同理可推出贡献为n/2，所以推到二进制第i位，贡献是n&lt;&lt;(i−1) ，累加就可以了 思路2：打开OEIS，输入数列，求出DP公式，递归即可，香 这里给出思路1的代码 代码12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define IOS \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);#define endl \"\\n\"#define int long longint32_t main() &#123; IOS; int t; cin &gt;&gt; t; while (t--) &#123; int num; cin &gt;&gt; num; int ans = 0, i = 1; int temp = num; while (num) &#123; ans += temp / i; i *= 2; num &gt;&gt;= 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D.Johnny and Contribution难度1700，标签：greedy，constructive algorithms 题目有个傻逼想写博客，每个文章一个主题，一个主题可以被多个文章写，文章之间可以互相引用，但是互相引用的文章的主题不能相同 这个傻逼写博客有个毛病，写文章时，选择的主题序号要最小，比如一个文章的引用文章的主题为1和3，那么此逼在写这个文章时用的主题序号为2 假设给定文章数目N，从1到N的文章的主题规定为一个序列，现在这个逼从头写文章，问他写文章的次序，如果文章的主题不能达到此序列，输出-1 思路转化为一个图，每个文章为一个节点，文章间的引用当作节点之间的边，主题当作节点的权值 先把所有边记录下来，然后把最后要得到的图的节点按照权值从小到大排序，之后按照节点权值选择先填的节点，在填充节点的过程中，如果此节点填充的值为M，则它的相连节点（且已被填充）的个数必须为N-1，且相连的节点（已填充）的权值必须是从1到N-1，如果不满足则输出-1，最后输出填充的顺序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define forn(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define IOS \\ ios::sync_with_stdio(flase); \\ cin.tie(0); \\ cout.tie(0);#define endl '\\n'const int inf = 0x3f3f3f3f;const int INF = 8e18;const int maxn = 5e5 + 5;vector&lt;int&gt; e[maxn];int a[maxn], p[maxn], ans[maxn];inline bool cmp(int x, int y) &#123; return a[x] &lt; a[y];&#125;int32_t main() &#123; //freopen(\"in.txt\", \"r\", stdin); int n, m; cin &gt;&gt; n &gt;&gt; m; forn(i, m) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; e[u].push_back(v); e[v].push_back(u); &#125; for1(i, n) cin &gt;&gt; a[i], p[i] = i; sort(p + 1, p + 1 + n, cmp); for1(i, n) &#123; int u = p[i]; int val = a[u]; set&lt;int&gt; s; for (auto v : e[u]) if (ans[v]) s.insert(ans[v]); if (s.size() != val - 1) return cout &lt;&lt; -1 &lt;&lt; endl, 0; int cnt = 1; for (auto x : s) &#123; if (x != cnt) return cout &lt;&lt; -1 &lt;&lt; endl, 0; ++cnt; &#125; ans[u] = a[u]; &#125; for1(i, n) cout &lt;&lt; p[i] &lt;&lt; \" \"; return 0;&#125; E.Johnny and Grandmaster难度1900，标签：greedy 题目给两个数N和P，输入N个数，把N个数分为两个集合，以P为底，把每个集合的元素作为幂次，把集合的每个元素作为幂次算出来的值相加和为S，求出两个集合的S的差值最小为多少 思路思路1：从大到小枚举p^k，拿一个变量cur记录当前的枚举数字的幂次，dif记录当前集合中的数字的大小是当前枚举的数字的倍数，ans记录最终的值。枚举新一轮的时候，当dif==0的时候说明集合中的所有数字被抵消了或者循环刚开始，那么cur直接等于此次循环枚举数字的幂次即可，ans也直接等于当前的数字的值模mod即可。如果dif!=0说明当前集合不为0，我们就让集合中的数字减去当前枚举的数字，可以考虑把cur先化为跟当前枚举数字的幂次相同，这样dif就会不断乘底数p，如果dif变得大于1e6(也可以精确点写成i),说明当前集合中的数字已经是当前枚举数字的至少1e6倍大，那么就没必要接着枚举了，因为N的长度最大才是1e6，直接减去后面所有的数字即可，因为即使减去了后面所有的数字也一定还有剩余。如果小于1e6，就让dif--（减去当前枚举的这个数字后倍数自然会减一），计算幂时我们用到了快速幂的思想 思路2：开双模数，有一定几率倍卡，但是概率太小忽略不计。首先知道一点，集合中的数字不可能减少为负数。那么每次减少一个数，看两个答案ans1，ans2是否同为0，同为0说明集合中的值被减少为0，然后就加上下一个枚举的数字，然后继续减后面的数字，重复这个过程，最后输出ans1就行了。ans1和ans2是按照不同的模数来算的，ans1的模数是题目要求的模数，ans2的模数是自己随便定的大模数 这里给出思路1的代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;const int P = 1e9 + 7;#define int long longint n, a[maxn];int qpow(int c, int b) &#123; int ans = 1; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) ans = ans * c % P; c = c * c % P; &#125; return ans;&#125;int32_t main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin &gt;&gt; t; while (t--) &#123; int p; cin &gt;&gt; n &gt;&gt; p; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; if (p == 1) &#123; cout &lt;&lt; (n &amp; 1LL) &lt;&lt; endl; continue; &#125; sort(a, a + n); int dif = 0, cur = 0, ans = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; if (!dif) &#123; cur = a[i]; dif = 1; ans += qpow(p, a[i]); &#125; else &#123; while (cur &gt; a[i]) &#123; cur --; dif *= p; if (dif &gt; i) break; &#125; if (cur == a[i]) &#123; dif --; ans -= qpow(p, a[i]); &#125; else &#123; for (int j = i; j &gt;= 0; j--) &#123; ans -= qpow(p, a[j]); &#125; break; &#125; &#125; &#125; ans = (ans % P + P) % P; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; F.Johnny and Megan’s Necklace难度2500，标签：dfs and similar 未完待续","categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"}],"tags":[{"name":"CODEFORCES/div2","slug":"CODEFORCES-div2","permalink":"http://liuhaotian.top/tags/CODEFORCES-div2/"}]},{"title":"LEETCODE10/PYTHON解法/正则表达式匹配","slug":"LEETCODE10-PYTHON解法-正则表达式匹配","date":"2020-06-05T08:00:58.000Z","updated":"2020-06-05T08:02:47.096Z","comments":true,"path":"2020/06/05/LEETCODE10-PYTHON解法-正则表达式匹配/","link":"","permalink":"http://liuhaotian.top/2020/06/05/LEETCODE10-PYTHON%E8%A7%A3%E6%B3%95-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"","text":"10.正则表达式匹配题解12345678910111213141516171819class Solution: def isMatch(self, s: str, p: str) -&gt; bool: s, p &#x3D; &#39; &#39;+ s, &#39; &#39;+ p lenS, lenP &#x3D; len(s), len(p) dp &#x3D; [[0]*(lenP) for i in range(lenS)] dp[0][0] &#x3D; 1 for j in range(1, lenP): if p[j] &#x3D;&#x3D; &#39;*&#39;: dp[0][j] &#x3D; dp[0][j-2] for i in range(1, lenS): for j in range(1, lenP): if p[j] in &#123;s[i], &#39;.&#39;&#125;: dp[i][j] &#x3D; dp[i-1][j-1] elif p[j] &#x3D;&#x3D; &quot;*&quot;: dp[i][j] &#x3D; dp[i][j-2] or int(dp[i-1][j] and p[j-1] in &#123;s[i], &#39;.&#39;&#125;) return bool(dp[-1][-1])","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"dp","slug":"dp","permalink":"http://liuhaotian.top/tags/dp/"}]},{"title":"LEETCODE9/PYTHON解法/回文数","slug":"LEETCODE9-PYTHON解法-回文数","date":"2020-06-05T07:24:36.000Z","updated":"2020-06-05T07:37:58.254Z","comments":true,"path":"2020/06/05/LEETCODE9-PYTHON解法-回文数/","link":"","permalink":"http://liuhaotian.top/2020/06/05/LEETCODE9-PYTHON%E8%A7%A3%E6%B3%95-%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"9.回文数题解12345678class Solution: def isPalindrome(self, x: int) -&gt; bool: orig &#x3D; x back_x &#x3D; 0 while x &gt; 0: back_x &#x3D; back_x * 10 + x % 10 x &#x2F;&#x2F;&#x3D; 10 return orig &#x3D;&#x3D; back_x","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"string","slug":"string","permalink":"http://liuhaotian.top/tags/string/"}]},{"title":"PYTHON中strip()、lstrip()、rstrip()用法详解","slug":"PYTHON中strip-、lstrip-、rstrip-用法详解","date":"2020-06-04T09:13:24.000Z","updated":"2020-06-04T09:20:34.127Z","comments":true,"path":"2020/06/04/PYTHON中strip-、lstrip-、rstrip-用法详解/","link":"","permalink":"http://liuhaotian.top/2020/06/04/PYTHON%E4%B8%ADstrip-%E3%80%81lstrip-%E3%80%81rstrip-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"PYTHON中strip()、lstrip()、rstrip()用法详解Python中有三个去除头尾字符、空白符的函数，它们依次为: strip： 用来去除头尾字符、空白符(换行、回车、制表符、空格)lstrip：用来去除开头字符、空白符(换行、回车、制表符、空格)rstrip：用来去除结尾字符、空白符(换行、回车、制表符、空格) 注意：这些函数都只会删除头和尾的字符，中间的不会删除 用法分别为：123string.strip([chars])string.lstrip([chars])string.rstrip([chars]) 参数chars是可选的，当chars为空，默认删除string头尾的空白符 当chars不为空时，函数会被chars解成一个个的字符，然后将这些字符去掉 它返回的是去除头尾字符(或空白符)的string副本，string本身不会发生改变 举例说明如下： 当chars为空时，默认删除空白符 12345678910&gt;&gt;&gt; str &#x3D; &#39; ab cd &#39;&gt;&gt;&gt; str.strip() #删除头尾空格&#39;ab cd&#39;&gt;&gt;&gt; str.lstrip() #删除开头空格&#39;ab cd &#39;&gt;&gt;&gt; str.rstrip() #删除结尾空格&#39; ab cd&#39; 当chars不为空时，函数会被chars解成一个个的字符，然后将这些字符去掉 12345678910&gt;&gt;&gt; str2 &#x3D; &#39;1a2b12c21&#39;&gt;&gt;&gt; str2.strip(&#39;12&#39;) #删除头尾的1和2&#39;a2b12c&#39;&gt;&gt;&gt; str2.lstrip(&#39;12&#39;) #删除开头的1和2&#39;a2b12c21&#39;&gt;&gt;&gt; str2.rstrip(&#39;12&#39;) #删除结尾的1和2&#39;1a2b12c&#39;","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"}]},{"title":"PYTHON中反转字符串的三种方法","slug":"PYTHON中反转字符串的三种方法","date":"2020-06-04T07:40:48.000Z","updated":"2020-06-04T07:59:37.792Z","comments":true,"path":"2020/06/04/PYTHON中反转字符串的三种方法/","link":"","permalink":"http://liuhaotian.top/2020/06/04/PYTHON%E4%B8%AD%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"PYTHON中反转字符串的三种方法1.切片法（最简洁的一种）1234567891011def reverse1(): s &#x3D; input(&quot;请输入需要反转的内容：&quot;) return s[::-1]print(reverse1())#运行结果请输入需要反转的内容：莺啼岸柳弄春晴 柳弄春晴夜月明明月夜晴春弄柳 晴春弄柳岸啼莺 This is extended slice syntax. It works by doing [begin:end:step] - by leaving begin and end off and specifying a step of -1, it reverses a string.这是扩展片语法。它的工作方式是[begin:end:step]-离开begin和end并指定步骤-1，它反转字符串。 2.递归12345678910def reverse2(s): if s&#x3D;&#x3D;&quot;&quot;: return s else: return reverse2(s[1:])+s[0]print(reverse2(&quot;莺啼岸柳弄春晴 柳弄春晴夜月明&quot;))#运行结果明月夜晴春弄柳 晴春弄柳岸啼莺 3.借用列表的reverse()方法 reverse()函数将列表的内容进行了反转，借助这个特性，可以先将字符串转换成列表，利用reverse()函数进行反转后，再处理成字符串。 123456789def reverse3(s): l&#x3D;list(s) l.reverse() return (&quot;&quot;.join(l))print(reverse3(&quot;莺啼岸柳弄春晴 柳弄春晴夜月明&quot;))#运行结果明月夜晴春弄柳 晴春弄柳岸啼莺","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"}]},{"title":"PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点","slug":"PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点","date":"2020-06-04T07:17:15.000Z","updated":"2020-06-04T07:38:48.091Z","comments":true,"path":"2020/06/04/PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点/","link":"","permalink":"http://liuhaotian.top/2020/06/04/PYTHON%E4%B8%ADisdigit-%E3%80%81isalpha-%E3%80%81isalnum-%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/","excerpt":"","text":"PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点isdigit()python关于isdigit()内置函数的官方定义： S.isdigit() -&gt; bool Return True if all characters in S are digits and there is at least one character in S, False otherwise. 翻译： S.isdigit()返回的是布尔值：True、FalseS字符串中至少有一个字符且如果S中的所有字符都是数字，那么返回结果就是True；否则，就返回False 123456789101112131415161718S1 &#x3D; &#39;12345&#39; #纯数字S2 &#x3D; &#39;①②&#39; #带圈的数字S3 &#x3D; &#39;汉字&#39; #汉字S4 &#x3D; &#39;%#￥&#39; #特殊符号S5 &#x3D; &#39;12345a&#39; #数字和字母print(S1.isdigit())print(S2.isdigit())print(S3.isdigit())print(S4.isdigit())print(S5.isdigit())# 执行结果：True TrueFalseFalseFalse isalpha()python关于isalpha()内置函数的官方定义： S.isalpha() -&gt; bool Return True if all characters in S are alphabetic and there is at least one character in S, False otherwise. 翻译：S.isalpha()返回的是布尔值：True、FalseS字符串中至少有一个字符且如果S中的所有字符都是字母，那么返回结果就是True；否则，就返回False 123456789101112S1 &#x3D; &#39;abc汉字&#39; #汉字+字母S2 &#x3D; &#39;ab字134&#39; #包含数字S3 &#x3D; &#39;*&amp;&amp;&#39; #特殊符号print(S1.isalpha())print(S2.isalpha())print(S3.isalpha())#执行结果TrueFalseFalse isalnum()python关于isalnum()内置函数的官方定义： S.isalnum() -&gt; bool Return True if all characters in S are alphanumeric and there is at least one character in S, False otherwise. 翻译： S.isalnum()返回的是布尔值：True、FalseS中至少有一个字符且如果S中的所有字符都是字母数字，那么返回结果就是True；否则，就返回False 123456789101112S1 &#x3D; &#39;abc汉字1&#39; #字母+汉字+数字S2 &#x3D; &#39;①②③&#39; #带圈的数字S3 &#x3D; &#39;%……&amp;&#39; #特殊符号print(S1.isalnum())print(S2.isalnum())print(S3.isalnum())#执行结果TrueTrueFalse 注意 python官方定义中的字母：大家默认为英文字母+汉字即可 python官方定义中的数字：大家默认为Unicode数字、byte数字（单字节）、全角数字（双字节）、罗马数字、带圈的数字即可","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"}]},{"title":"PYTHON中join函数的用法","slug":"PYTHON中join函数的用法","date":"2020-06-04T06:52:29.000Z","updated":"2020-06-04T07:13:51.605Z","comments":true,"path":"2020/06/04/PYTHON中join函数的用法/","link":"","permalink":"http://liuhaotian.top/2020/06/04/PYTHON%E4%B8%ADjoin%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"PYTHON中join函数的用法Python中有.join()和os.path.join()两个函数，具体作用如下： .join()：连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串os.path.join()：将多个路径组合后返回 对序列进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）1234567891011121314151617a&#x3D;[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;]&gt;&gt; &#39; &#39;.join(a)1 2 3 4 5&gt;&gt; &#39;&#39;.join(a)12345&gt;&gt;&#39;-&#39;.jion(a)1-2-3-4-5&gt;&gt;&#39;.&#39;.join(a)1.2.3.4.5 对字符串进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）12345678910111213b&#x3D;&#39;hello world&#39;&gt;&gt; &#39; &#39;.join(b)h e l l o w o r l d&gt;&gt;&#39;-&#39; .join(b)h-e-l-l-o- -w-o-r-l-d&gt;&gt;&#39;:&#39;.jion(b)h:e:l:l:o: :w:o:r:l:d 对元组进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）12345678910111213c&#x3D;(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;)&gt;&gt;&#39; &#39;.join(c)1 2 3 4 5&gt;&gt;&#39;-&#39;.join(c)1-2-3-4-5&gt;&gt;&#39;:&#39;.join(c)1:2:3:4:5 对字典进行无序操作（分别使用’ ‘、’-‘与’:’作为分隔符）12345678910111213d&#x3D;&#123;&#39;name1&#39;:&#39;a&#39;,&#39;name2&#39;:&#39;b&#39;,&#39;name3&#39;:&#39;c&#39;,&#39;name4&#39;:&#39;d&#39;&#125;&gt;&gt;&#39; &#39;.jion(d)name1 name2 name3 name4&gt;&gt;&#39;-&#39;.join(d)name1-name2-name3-name4&gt;&gt;&#39;:&#39;.join(d)name1:name2:name3:name4 对目录进行操作12345import osos.path.join(&#39;&#x2F;hello&#x2F;&#39;,&#39;good&#x2F;date&#39;,&#39;datbody&#39;)hello&#x2F;good&#x2F;date&#x2F;datbody","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"}]},{"title":"LEETCODE8/PYTHON解法/字符串转换整数","slug":"LEETCODE8-PYTHON解法-字符串转换整数","date":"2020-06-04T04:24:14.000Z","updated":"2020-06-04T06:50:31.786Z","comments":true,"path":"2020/06/04/LEETCODE8-PYTHON解法-字符串转换整数/","link":"","permalink":"http://liuhaotian.top/2020/06/04/LEETCODE8-PYTHON%E8%A7%A3%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/","excerpt":"","text":"8.字符串转换整数12345678910111213141516class Solution: def myAtoi(self, str: str) -&gt; int: def helper(x): if not x: return 0 ret &#x3D; 0 for i in x: if not i.isdigit(): return ret ret &#x3D; ret *10 + int(i) return ret s &#x3D; str.strip() if not s: return 0 elif s[0] &#x3D;&#x3D; &#39;+&#39;: return min(2**31-1,helper(s[1:])) elif s[0] &#x3D;&#x3D; &#39;-&#39;: return max(-2**31,-helper(s[1:])) elif s[0].isdigit(): return min(2**31-1,helper(s)) else: return 0","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"string","slug":"string","permalink":"http://liuhaotian.top/tags/string/"}]},{"title":"LEETCODE7/PYTHON解法/整数反转","slug":"LEETCODE7-PYTHON解法-整数反转","date":"2020-06-04T03:45:38.000Z","updated":"2020-06-04T04:13:52.904Z","comments":true,"path":"2020/06/04/LEETCODE7-PYTHON解法-整数反转/","link":"","permalink":"http://liuhaotian.top/2020/06/04/LEETCODE7-PYTHON%E8%A7%A3%E6%B3%95-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"7.整数反转题解12345678class Solution: def reverse(self, x: int) -&gt; int: result &#x3D; int(str(x)[::-1]) if x &gt;&#x3D; 0 else -int(str(x)[1:][::-1]) if -2**31 &lt;&#x3D; result &lt;&#x3D; (2**31)-1: return result else: return 0","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"string","slug":"string","permalink":"http://liuhaotian.top/tags/string/"}]},{"title":"LEETCODE6/PYTHON解法/Z字形变换","slug":"LEETCODE6-PYTHON解法-Z字形变换","date":"2020-06-04T02:18:29.000Z","updated":"2020-06-04T03:44:37.796Z","comments":true,"path":"2020/06/04/LEETCODE6-PYTHON解法-Z字形变换/","link":"","permalink":"http://liuhaotian.top/2020/06/04/LEETCODE6-PYTHON%E8%A7%A3%E6%B3%95-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","excerpt":"","text":"6.Z字形变换题解12345678910111213class Solution: def convert(self, S: str, R: int) -&gt; str: if R &#x3D;&#x3D; 1 or R &gt; len(S): # corner case return S res, i, step &#x3D; [&#39;&#39; for r in range(R)], 0, 0 # a string for each line for s in S: res[i] +&#x3D; s if i &#x3D;&#x3D; 0: # first row step &#x3D; 1 # down if i &#x3D;&#x3D; R - 1: # last row step &#x3D; -1 # up i +&#x3D; step return &quot;&quot;.join(res)","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"math","slug":"math","permalink":"http://liuhaotian.top/tags/math/"}]},{"title":"API之to_string用法","slug":"API之to-string用法","date":"2020-06-03T18:49:33.000Z","updated":"2020-06-03T18:55:46.412Z","comments":true,"path":"2020/06/04/API之to-string用法/","link":"","permalink":"http://liuhaotian.top/2020/06/04/API%E4%B9%8Bto-string%E7%94%A8%E6%B3%95/","excerpt":"","text":"API之to_string用法函数原型123456789string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val); 功能将数值转化为字符串。返回对应的字符串。 示例123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string pi &#x3D; &quot;pi is &quot; + std::to_string(3.1415926); string perfect &#x3D; to_string(1 + 2 + 4 + 7 + 14) + &quot; is a perfect number&quot;; cout &lt;&lt; pi &lt;&lt; &#39;\\n&#39;; cout &lt;&lt; perfect &lt;&lt; &#39;\\n&#39;; system(&quot;pause&quot;); return 0;&#125; 结果：12pi is 3.14159328 is a perfect number","categories":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/categories/C-C-%E5%B8%B8%E7%94%A8API/"}],"tags":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/tags/C-C-%E5%B8%B8%E7%94%A8API/"}]},{"title":"LEETCODE双周赛26","slug":"LEETCODE双周赛26","date":"2020-06-03T17:30:33.000Z","updated":"2020-06-03T18:18:07.784Z","comments":true,"path":"2020/06/04/LEETCODE双周赛26/","link":"","permalink":"http://liuhaotian.top/2020/06/04/LEETCODE%E5%8F%8C%E5%91%A8%E8%B5%9B26/","excerpt":"","text":"LEETCODE双周赛261446.连续字符思路 双指针（滑动窗口） 代码1234567891011121314class Solution &#123;public: int maxPower(string s) &#123; int maxn &#x3D; -0x3f3f3f3f; for (int i &#x3D; 0; i &lt; s.size();) &#123; int j &#x3D; i + 1; while (j &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; s[j]) j++; maxn &#x3D; max(maxn, j - i); i &#x3D; j; &#125; return maxn; &#125;&#125;; 1447.最简分数思路 gcd+遍历 代码12345678910111213141516class Solution &#123; int gcd(int x, int y) &#123; return y ? gcd(y, x % y) : x; &#125;public: vector&lt;string&gt; simplifiedFractions(int n) &#123; vector&lt;string&gt; result; for (int i &#x3D; 1; i &lt; n; i++) &#123; for (int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123; if (gcd(j, i) &#x3D;&#x3D; 1) result.push_back(to_string(i) + &quot;&#x2F;&quot; + to_string(j)); &#125; &#125; return result; &#125;&#125;; 1448.统计二叉树中好节点的数目思路 简简单单的dfs，记录遍历的节点的最大值 代码12345678910111213141516171819202122232425&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: int goodNodes(TreeNode* root) &#123; return dfs(root, INT_MIN); &#125; int dfs(TreeNode* root, int maxn) &#123; if (!root) return 0; int ans &#x3D; maxn &lt;&#x3D; root-&gt;val; if (root-&gt;left) ans +&#x3D; dfs(root-&gt;left, max(maxn, root-&gt;val)); if (root-&gt;right) ans +&#x3D; dfs(root-&gt;right, max(maxn, root-&gt;val)); return ans; &#125;&#125;; 1449.数位成本和为目标值的最大数字思路 完全背包 代码123456789101112131415161718192021222324class Solution &#123; public: string largestNumber(vector&lt;int&gt;&amp; cost, int target) &#123; vector&lt;vector&lt;int&gt;&gt; f(10, vector&lt;int&gt;(target + 1)); for (int i &#x3D; 1; i &lt;&#x3D; target; i++) f[0][i] &#x3D; -1e8; for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) for (int j &#x3D; 0; j &lt;&#x3D; target; j++) &#123; f[i][j] &#x3D; f[i - 1][j]; if (j &gt;&#x3D; cost[i - 1]) f[i][j] &#x3D; max(f[i][j], f[i][j - cost[i - 1]] + 1); &#125; if (f[9][target] &lt; 1) return &quot;0&quot;; string res; for (int i &#x3D; 9, j &#x3D; target; i; i--) while (j &gt;&#x3D; cost[i - 1] &amp;&amp; f[i][j] &#x3D;&#x3D; f[i][j - cost[i - 1]] + 1) &#123; res +&#x3D; to_string(i); j -&#x3D; cost[i - 1]; &#125; return res; &#125;&#125;;","categories":[{"name":"LEETCODE周赛","slug":"LEETCODE周赛","permalink":"http://liuhaotian.top/categories/LEETCODE%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"LEETCODE周赛","slug":"LEETCODE周赛","permalink":"http://liuhaotian.top/tags/LEETCODE%E5%91%A8%E8%B5%9B/"}]},{"title":"0x06倍增","slug":"0x06倍增","date":"2020-06-03T11:42:06.000Z","updated":"2020-06-03T15:49:41.573Z","comments":true,"path":"2020/06/03/0x06倍增/","link":"","permalink":"http://liuhaotian.top/2020/06/03/0x06%E5%80%8D%E5%A2%9E/","excerpt":"","text":"0x06倍增基础知识倍增，字面意思就是“成倍的增长”。这是指我们在进行递推时，如果状态空间很大，通常的线性递推无法满足时间与空间复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间中在2的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过“任意整数可以表示成若干个2的次幂项的和”这一性质 ，使用之前求出的代表值拼成所需的值。所以使用倍增算法也要求我们递推的问题的状态空间关于2的次幂具有可划分性 “倍增”与“二进制划分”两个思想相互结合，降低了求解很多问题的时间与空间复杂度。我们之前学习的快速幂其实就是“倍增”与“二进制划分”思想的一种体现。在此文章中，我们研究序列上的倍增问题，包括求解RMQ（区间最值）问题的ST算法，关于求解最近公共祖先LCA等在树上的倍增应用，我将在后续文章进行探讨 试想这样一个问题：给定一个长度为N的数列A，然后进行若干次询问，每次给定一个整数T，求出最大的k，满足数列A中前k个数的和小于等于T。你的算法必须是在线的（必须即时回答每一个询问，不能等待收到所有询问后再统一处理），假设T小于等于数组A中所有数的和 朴素做法当然是从前向后枚举K，每次询问花费的时间与答案的大小有关，最坏情况为O(N) 如果我们能够先花费O(N)的时间预处理A数组的前缀和数组S，就可以二分K的位置，比较S[K]与T的大小来确定二分上下界的变化，每次询问花费的时间都是O(logN)。这个算法在平均情况下表现很好，但是它的缺点是如果每次询问给定的整数T都非常小，造成答案K也非常小，那么该算法可能还不如从前往后枚举更优（因为假如每次只怼前3个，此时O(log)的算法可能不如O(3)的好） 我们可以设计这样一种倍增算法： 令p=1，k=0，sum=0 比较A数组中k之后的p个数的和与T的关系，也就是说，如果sum+S[k+p]-S[k]&lt;=T，则令sum+=S[k+p]-S[k]，k+=p，p*=2，即累加上p个数的和，然后把p的跨度增长一倍，如果sum+S[k+p]-S[k]&gt;T，则另p/=2 重复上一步，直至p的值变为0，此时k就是答案 这个算法始终在答案大小的范围内实施“倍增”与“二进制划分”的思想，通过若干长度为2的次幂的区间拼成最后的k，时间复杂度级别为答案的对数，能够应对T的各种大小情况 ACWING109.天才ACM首先，对于一个集合S，显然应该取S中最大的M个数和最小的M个数，最大的和最小的构成一对、次大和次小构成一对…这样求出的校验值最大。而为了让数组A分成的段数最少，每一段都应该在校验值不超过T的情况下，尽量包含更多的数，所以我们从头开始对A进行分段，让每一段尽量长，到达结尾时分成的段数就是答案 于是，需要解决的问题是：当确定一个左端点L之后，右端点R在满足A[L]到A[R]的校验值不超过T的前提下，最大能取到多少 求长度为N的一段校验值需要排序配对，时间复杂度为O(NlogN)。当校验值上限T比较小时，如果在整个L到N的区间二分右端点R，二分第一步就要检验(N-L)/2这么长的一段，最终右端点R却可能只扩展了一点儿，浪费了很多时间。与上一道题目一样，我们需要一个与右端点R扩展的长度相适应的算法———倍增 可以采用与上一题类似的倍增过程： 初始化p=1，R=L 求出[L,R+p]这一段区间的校验值，若检验值小于等于T，则R+=P，p*=2，否则P/=2 重复上一步，直到p的值变为0，此时R即为所求 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define ll long long#define fir(i, a, b) for (int i &#x3D; a; i &lt;&#x3D; b; i++)#define sqr(a) (a) * (a)#define IOS \\ ios::sync_with_stdio(0); \\ cin.tie(0); \\ cout.tie(0);const int N &#x3D; 5e5 + 10;int n, m, p[N], ans, l, r;ll b[N], a[N], k;void merge(int l, int mid, int r) &#123; int i &#x3D; l, j &#x3D; mid, k &#x3D; l; while (i &lt; mid &amp;&amp; j &lt;&#x3D; r) if (a[i] &lt;&#x3D; a[j]) b[k++] &#x3D; a[i++]; else b[k++] &#x3D; a[j++]; while (i &lt; mid) b[k++] &#x3D; a[i++]; while (j &lt;&#x3D; r) b[k++] &#x3D; a[j++];&#125;bool check(int l, int mid, int r) &#123; fir(i, mid, r) a[i] &#x3D; p[i]; sort(a + mid, a + r + 1); merge(l, mid, r); ll sum &#x3D; 0; for (int i &#x3D; 1; i &lt;&#x3D; r - l + 1 &gt;&gt; 1 &amp;&amp; i &lt;&#x3D; m; i++) sum +&#x3D; sqr(b[r - i + 1] - b[l + i - 1]); if (sum &lt;&#x3D; k) &#123; for (int i &#x3D; l; i &lt;&#x3D; r; i++) a[i] &#x3D; b[i]; return true; &#125; else return false;&#125;void init() &#123; l &#x3D; r &#x3D; 0; ans &#x3D; 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; fir(i, 1, n) cin &gt;&gt; p[i];&#125;void work() &#123; int len &#x3D; 1; l &#x3D; r &#x3D; 1; a[l] &#x3D; p[l]; while (r &lt;&#x3D; n) if (!len) &#123; len &#x3D; 1; ans++; l &#x3D; (++r); a[l] &#x3D; p[l]; &#125; else if (r + len &lt;&#x3D; n &amp;&amp; check(l, r + 1, r + len)) &#123; r +&#x3D; len; len &lt;&lt;&#x3D; 1; if (r &#x3D;&#x3D; n) break; &#125; else len &gt;&gt;&#x3D; 1; if (r &#x3D;&#x3D; n) ans++;&#125;int main() &#123; IOS; int t; cin &gt;&gt; t; while (t--) &#123; init(); work(); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 这题的代码差点儿把我杀死，不写了，未完待续","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/tags/ACM/"}]},{"title":"PYTHON中max函数的lambda表达式用法","slug":"PYTHON中max函数的lambda表达式用法","date":"2020-06-03T08:59:07.000Z","updated":"2020-06-03T09:33:37.611Z","comments":true,"path":"2020/06/03/PYTHON中max函数的lambda表达式用法/","link":"","permalink":"http://liuhaotian.top/2020/06/03/PYTHON%E4%B8%ADmax%E5%87%BD%E6%95%B0%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/","excerpt":"","text":"PYTHON中max函数的lambda表达式用法引入由一道leetcode题来引入PYTHON中max函数的lambda表达式用法5. 最长回文子串 1234567891011121314class Solution: def longestPalindrome(self, s: str) -&gt; str: p &#x3D; &#39;&#39; for i in range(len(s)): p1 &#x3D; self.get_palindrome(s, i, i+1) p2 &#x3D; self.get_palindrome(s, i, i) p &#x3D; max([p, p1, p2], key&#x3D;lambda x: len(x)) return p def get_palindrome(self, s: str, l: int, r: int) -&gt; str: while l &gt;&#x3D; 0 and r &lt; len(s) and s[l] &#x3D;&#x3D; s[r]: l -&#x3D; 1 r +&#x3D; 1 return s[l+1:r] max([p, p1, p2], key=lambda x: len(x))的含义就是本文章的内容 lambda表达式介绍在学习python的过程中，lambda的语法时常会使人感到困惑，lambda是什么，为什么要使用lambda，是不是必须使用lambda？ lambda是什么？我们来看此表达式：g = lambda x:x+1，看一下执行的结果：g(1)==2、g(2)==3,当然，你也可以这样使用：lambda x:x+1(1)，结果为2可以这样认为,lambda作为一个表达式，定义了一个匿名函数，上例的代码x为入口参数，x+1为函数体，用函数来表示为:12def g(x): return x+1 lambda定义了一个匿名函数 lambda并不会带来程序运行效率的提高，只会使代码更简洁 如果可以使用for...in...if来完成的，坚决不用lambda 如果使用lambda，lambda内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。 总结：lambda是为了减少单行函数的定义而存在的 max函数中的lambda表达式现在回到我们的max函数中，就十分容易理解了:函数形式：max( x ,key=lambda a : b )，x可以是任何数值，可以有多个x值这个函数的意思是：我们先把x值带入lambda函数转换成b值，然后再将b值进行比较1234567haha0&#x3D;max(&#39;az&#39;,&#39;za&#39;, key&#x3D;lambda a: a[0])haha1&#x3D;max(&#39;az&#39;,&#39;za&#39;, key&#x3D;lambda a: a[1])haha2&#x3D;max(range(10),key&#x3D;lambda a:a&gt;3) print(haha0) #输出zaprint(haha1) #输出azprint(haha2) #输出4 以haha0为例子：我们传入az，za，为了方便解释称之为虚拟比较，但是因为我们引入了lambda表达式，所以，我们实际上比较的是，az中的第一位a和za中第一位的z，由ascii码表可以知道a是小于z的，所以在这里最大的是z，那么我们返回的就是z的虚拟比较变量，也就是本来的za。 haha2的用法十分少见，实际上比较的是:F F F T T T T T T T ( False 和 True ) T是肯定比F大的，但是一堆True哪里能互相比较大小呢，所以就输出第一个True值的虚拟比较变量，也就是4 max中带有lambda的这个写法的意义在于代码变得更简洁 假如我们有一个字典，里面记录着人名和相应年龄，现在我们想要在里面筛选出年龄最大的那个人的一条字典记录123x&#x3D;&#123;&quot;老王&quot; :18 , &quot;小李&quot;:99&#125;haha3&#x3D;max(x.items(), key&#x3D;lambda a: a[1])print(haha3) #输出(&#39;小李&#39;, 99) 要注意使用字典的话一定要x.items()，不能直接输入x值，达不到我们想要的效果 其实我们大可不必这么写，直接从字典中提取出年龄列表进行比较：123456x&#x3D;&#123;&quot;老王&quot; :18 , &quot;小李&quot;:99&#125;y&#x3D;[]for name,age in x.items(): y.append(age)haha4&#x3D;max(y)print(haha4) 只是这样写是比较麻烦以及浪费内存的不是么？我想这就是max函数中设置lambda表达式的意义 再举两个例子： 取第一维123num &#x3D; [(1,2.5), (1.5, 3.2), (1.3, 4.0), (2.2, 1.8)]y,z &#x3D; max(num, key&#x3D;lambda x:x[0])print(y, z) #结果为2.2 1.8 取第二维123num &#x3D; [(1,2.5), (1.5, 3.2), (1.3, 4.0), (2.2, 1.8)]y,z &#x3D; max(num, key&#x3D;lambda x:x[1])print(y, z) #结果为1.3 4.0","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"}]},{"title":"LEETCODE5/PYTHON解法/最长回文串","slug":"LEETCODE5-PYTHON解法-最长回文串","date":"2020-06-03T07:59:23.000Z","updated":"2020-06-03T08:58:05.988Z","comments":true,"path":"2020/06/03/LEETCODE5-PYTHON解法-最长回文串/","link":"","permalink":"http://liuhaotian.top/2020/06/03/LEETCODE5-PYTHON%E8%A7%A3%E6%B3%95-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/","excerpt":"","text":"5. 最长回文子串题解1234567891011121314class Solution: def longestPalindrome(self, s: str) -&gt; str: p &#x3D; &#39;&#39; for i in range(len(s)): p1 &#x3D; self.get_palindrome(s, i, i+1) p2 &#x3D; self.get_palindrome(s, i, i) p &#x3D; max([p, p1, p2], key&#x3D;lambda x: len(x)) return p def get_palindrome(self, s: str, l: int, r: int) -&gt; str: while l &gt;&#x3D; 0 and r &lt; len(s) and s[l] &#x3D;&#x3D; s[r]: l -&#x3D; 1 r +&#x3D; 1 return s[l+1:r]","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"}]},{"title":"LEETCODE4/PYTHON解法/寻找两个正序数组的中位数","slug":"LEETCODE4-PYTHON解法-寻找两个正序数组的中位数","date":"2020-06-03T07:26:04.000Z","updated":"2020-06-03T07:56:53.724Z","comments":true,"path":"2020/06/03/LEETCODE4-PYTHON解法-寻找两个正序数组的中位数/","link":"","permalink":"http://liuhaotian.top/2020/06/03/LEETCODE4-PYTHON%E8%A7%A3%E6%B3%95-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"4.寻找两个正序数组的中位数题解12345678910class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: totalList &#x3D; nums1 + nums2 totalList.sort() if len(totalList) % 2 &#x3D;&#x3D;0: i &#x3D; totalList[len(totalList)&#x2F;&#x2F;2] j &#x3D; totalList[len(totalList)&#x2F;&#x2F;2 - 1] return (i+j)&#x2F;2 else: return totalList[len(totalList)&#x2F;&#x2F;2]","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"sort","slug":"sort","permalink":"http://liuhaotian.top/tags/sort/"}]},{"title":"LEETCODE3/PYTHON解法/无重复字符的最长子串","slug":"LEETCODE3-PYTHON解法-无重复字符的最长子串","date":"2020-06-03T07:07:21.000Z","updated":"2020-06-03T07:21:25.882Z","comments":true,"path":"2020/06/03/LEETCODE3-PYTHON解法-无重复字符的最长子串/","link":"","permalink":"http://liuhaotian.top/2020/06/03/LEETCODE3-PYTHON%E8%A7%A3%E6%B3%95-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"3.无重复字符的最长子串题解123456789101112131415class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: d &#x3D; &#123;&#125; p1 &#x3D; p2 &#x3D; m &#x3D; 0 while p2 &lt; len(s): if s[p2] not in d: d[s[p2]] &#x3D; True p2 +&#x3D; 1 m &#x3D; max(len(d), m) else: del d[s[p1]] p1 +&#x3D; 1 return m","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"window","slug":"window","permalink":"http://liuhaotian.top/tags/window/"}]},{"title":"LEETCODE2/PYTHON解法/两数相加","slug":"LEETCODE2-PYTHON解法-两数相加","date":"2020-06-03T06:49:05.000Z","updated":"2020-06-03T07:04:46.813Z","comments":true,"path":"2020/06/03/LEETCODE2-PYTHON解法-两数相加/","link":"","permalink":"http://liuhaotian.top/2020/06/03/LEETCODE2-PYTHON%E8%A7%A3%E6%B3%95-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"2.两数相加题解123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val &#x3D; x# self.next &#x3D; Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: dummy &#x3D; cur &#x3D;ListNode(0) carry &#x3D; 0 while l1 or l2 or carry: if l1: carry +&#x3D; l1.val l1 &#x3D; l1.next if l2: carry +&#x3D; l2.val l2 &#x3D; l2.next cur.next &#x3D; ListNode(carry%10) cur &#x3D; cur.next carry &#x2F;&#x2F;&#x3D;10 return dummy.next","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"ListNode","slug":"ListNode","permalink":"http://liuhaotian.top/tags/ListNode/"}]},{"title":"计算机网络基础总结(2)","slug":"计算机网络基础总结-2","date":"2020-06-03T02:11:49.000Z","updated":"2020-06-03T06:46:46.859Z","comments":true,"path":"2020/06/03/计算机网络基础总结-2/","link":"","permalink":"http://liuhaotian.top/2020/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-2/","excerpt":"","text":"计算机网络基础总结(2)1.","categories":[],"tags":[]},{"title":"LEETCODE1/PYTHON解法/两数之和","slug":"LEETCODE1-PYTHON解法-两数之和","date":"2020-06-03T01:27:56.000Z","updated":"2020-06-03T01:39:02.599Z","comments":true,"path":"2020/06/03/LEETCODE1-PYTHON解法-两数之和/","link":"","permalink":"http://liuhaotian.top/2020/06/03/LEETCODE1-PYTHON%E8%A7%A3%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"1.两数之和题解12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dic &#x3D; &#123;&#125; for i in range(len(nums)): if nums[i] in dic: return [dic[nums[i]], i] else: dic[target - nums[i]] &#x3D; i","categories":[{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"}],"tags":[{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"hash","slug":"hash","permalink":"http://liuhaotian.top/tags/hash/"}]},{"title":"计算机网络基础总结(1)","slug":"计算机网络基础总结-1","date":"2020-06-02T13:44:17.000Z","updated":"2020-06-02T16:24:51.310Z","comments":true,"path":"2020/06/02/计算机网络基础总结-1/","link":"","permalink":"http://liuhaotian.top/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-1/","excerpt":"","text":"计算机网络基础总结(1) 局域网：覆盖范围小、自己花钱买设备、带宽固定、自己维护、100米、10M 100M 1000M广域网：距离远、花钱租带宽Internet：由ISP组成、有自己的机房、对网民提供访问Internet连接 ISP：Internet服务提供商（Internet service provide） DNS：把网站域名解析成IP地址 子网掩码：告诉计算机哪里是网络部分，哪里是主机部分 路由器的作用是在不同网段转发数据 计算机的网卡有mac地址（物理地址），全球唯一，mac地址在计算机出场时已经被固定在网卡中：48位二进制（12位十六进制） 计算机访问过程： 先把要访问的域名发送给DNS服务器，DNS服务器把域名解析成IP地址返回 数据包由数据、原IP地址、目标IP地址组成 数据帧由数据、原IP地址、目标IP地址、此时的mac地址、下一个目的地的mac地址组成 计算机发送数据帧后，数据帧在运输的过程中两个mac地址不断变化，因此不断重新封装，但是数据包没变 数据帧在运输过程中不断经过路由器，路由器看数据包中的IP地址，决定下一步走哪个mac地址 目标服务器收到请求后，往计算机回传数据，会把数据切割成小块，并给每一块编号，然后取一部分放到目标服务器的缓存当中，再然后在缓存中取出一块，加上此服务器IP地址、目标计算机IP地址、此时的mac地址、下一个目的地的mac开始发送，发送后，此数据块不会被缓存区删除，因为发送的过程中可能会丢失，当目标计算机收到此数据块放到计算机中的缓存区后，发送请求接受下一个数据块的消息到此服务器时，此数据块才会在缓存区被删除 当计算机的缓存满了时，会读取，然后再存缓存 第一张图说明： 第二张图说明： OSI参考模型（国际标准把计算机通信进行的定义） 应用层：所有能产生网络流量的程序 表示层：在传输之前是否进行加密或压缩处理、传的是二进制还是ASCII码 会话层：电脑和某服务器建立起的联系，比如电影前进后退进、查木马都是会话层的体现 netstat -n 命令可在终端查看此电脑建立的会话 传输层：可靠传输（比如某服务器传输数据到计算机、把数据分块传输，如果发送了某一块之后没收到请求下一块的信息，就会接着发送这个数据块，防止数据块丢失）、流量控制（比如服务器发送数据太快了，则计算机发消息告诉服务器调整发送速度）、不可靠传输（比如DNS解析域名，一个数据包就能说明问题与得到答案，不需要建立会话） 网络层：负责选择最佳路径、规划IP地址 数据链路层：帧的开始和结束、透明传输（将数据中与开头或结尾表示相同的部分进行转义）、差错校验（检错错误，数据中多加一部分数据进行校验，但不纠错，只检查，错误的就扔掉，纠错是在传输层进行） 物理层：接口标准、电器标准、如何在物理链路上传输更快的速度 每一层都是一个较为独立的模块，每一个模块变化都不会影响其他的模块；但每一层都有关系：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层-&gt;人（-&gt;代表xx为xx提供服务） 网络出现故障，应该从最底层物理层往上一层一层进行检查 物理层故障：查看连接状态、查看发送和接收的数据包 数据链路层故障：mac地址冲突、ADSL欠费、网速没办法协商一致、计算机连接到错误的VLAN(虚拟局域网) 网络层故障：配置了错误的IP地址、子网掩码、配置错误的网关、路由器没有配置到达目标网络的路由、数据有没有通过各个网关到达指定位置 应用层故障：应用程序配置错误 打开终端输入命令ping一个网址，若数据有来有回，则证明网通了 OSI参考模型和网络安全 物理层安全 数据链路层安全：ADSL账号密码、VLAN、交换机端口绑定mac地址 网络层安全：在路由器上时使用ACL控制数据包流量、防火墙 应用层安全：开发的应用程序没漏洞","categories":[{"name":"计算机网络基础","slug":"计算机网络基础","permalink":"http://liuhaotian.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络基础——韩立刚视频总结","slug":"计算机网络基础——韩立刚视频总结","permalink":"http://liuhaotian.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9F%A9%E7%AB%8B%E5%88%9A%E8%A7%86%E9%A2%91%E6%80%BB%E7%BB%93/"}]},{"title":"API之lowerer_bound/upper_bound用法","slug":"API之lowerer-bound-upper-bound用法","date":"2020-06-02T06:22:27.000Z","updated":"2020-06-02T07:32:57.445Z","comments":true,"path":"2020/06/02/API之lowerer-bound-upper-bound用法/","link":"","permalink":"http://liuhaotian.top/2020/06/02/API%E4%B9%8Blowerer-bound-upper-bound%E7%94%A8%E6%B3%95/","excerpt":"","text":"API之lowerer_bound/upper_bound用法lower_bound()lower_bound(beg, end, val, comp) 参数： 一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是数组的首地址，只是用于比较的“首”地址） 一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址） 就是一个要二分查找的那个数 greater&lt;int&gt;()代表降序，less&lt;int&gt;()代表升序，默认是升序，也就是数组元素从小到大排列 返回值: 返回值就是返回第一次出现大于等于那个要查找的数的地址 注意： 返回值是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组的数组名，即这个数组的首地址,只有这样才代表那个要查找的数字的下标 那就是要大于等于那个数，等于好理解，大于怎么理解呢，比如说我并没有找到那个数，加入一个的数组里边就有5个数，分别是1,1,1,3,5,而我需要找的那个数就是2，怎么返回呢？就是返回那个第一个大于2的数的地址，就是返回3的地址，那么再有一组数据就是5个数1,1,1,3,3，还是需要找寻2，那么该返回什么呢？那就是第一个3的地址 示例：1234567891011#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int k, n &#x3D; 10;int a[10] &#x3D; &#123;1, 1, 1, 3, 3, 5, 5, 5, 5, 6&#125;;int main() &#123; for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; while (scanf(&quot;%d&quot;, &amp;k)) &#123; cout &lt;&lt; k &lt;&lt; &quot;的第一个大于等于它的位置在&quot; &lt;&lt; ((lower_bound(a, a + n, k)) - a) + 1 &lt;&lt; endl; &#125;&#125;结果：123451 1 1 3 3 5 5 5 5 6 33的第一个大于等于它的位置在455的第一个大于等于它的位置在6 upper_bound()upper_bound函数的用法lower_bound函数的用法相似，不过这个唯一的不同就是返回的是第一个比我要找的那个数大的数的地址，注意，这里并没有等于，也就是说如果在5个数1,1,2,2,4，里边寻找3，那么就会返回4的地址 示例：1234567891011#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int k, n &#x3D; 10;int a[10] &#x3D; &#123;1, 1, 1, 3, 3, 5, 5, 5, 5, 6&#125;;int main() &#123; for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; while (scanf(&quot;%d&quot;, &amp;k)) &#123; cout &lt;&lt; k &lt;&lt; &quot;的第一个大于它的位置在&quot; &lt;&lt; ((upper_bound(a, a + n, k)) - a) + 1 &lt;&lt; endl; &#125;&#125;结果：123451 1 1 3 3 5 5 5 5 6 55的第一个大于它的位置在1011的第一个大于它的位置在4 set和map中的upper_bound/lower_bound和上述一样的功能，不过其本身class内的放法比调用用外部的upper_bound/lower_bound效率高 灵活使用123map&lt;int, int&gt; spfs;auto spf &#x3D; spfs.upper_bound(cows[i].second);spf--; 这就实现了找小于等于cows[i].second的数中最大值的功能","categories":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/categories/C-C-%E5%B8%B8%E7%94%A8API/"}],"tags":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/tags/C-C-%E5%B8%B8%E7%94%A8API/"}]},{"title":"0x07贪心","slug":"0x07贪心","date":"2020-06-02T05:16:30.000Z","updated":"2020-06-02T12:39:45.401Z","comments":true,"path":"2020/06/02/0x07贪心/","link":"","permalink":"http://liuhaotian.top/2020/06/02/0x07%E8%B4%AA%E5%BF%83/","excerpt":"","text":"0x07贪心基础知识贪心是一种在每次决策时采取当前意义下最优策略的算法，因此，使用贪心法要求问题的整体最优性可以由局部最优性导出。贪心算法的正确性需要证明，常见的证明手段有： 微扰（邻项交换）证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果的变差，经常用于以“排序”为贪心策略的证明 范围缩放证明任何对局部最优策略作用范围的扩展都不会造成整体结果的变差 决策包容性证明在任意局面下，做出局部最优策略以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略的可能性包含其他所有策略提供的可能性 反证法 数学归纳法 我们通过几道例题来介绍贪心算法的应用 ACWING110.防晒按照minSPF递减的顺序把奶牛排序，依次考虑每头奶牛 对于每头奶牛，扫描一遍所有的防晒霜，在这头奶牛能用（能用指的是该防晒霜的强度符合这头奶牛的范围，并且瓶数还有剩余）的防晒霜里找SPF值最大的使用 以上算法的贪心策略是在满足条件的前提下每次选择SPF最大的防晒霜，这个策略正确的原因是：我们考虑这一步策略的作用范围扩展到后续其他奶牛之后产生的影响。每瓶防晒霜是否可用，会被minSPF和maxSPF两个条件限制，因为奶牛已经按照minSPF递减排序，所以每一个不低于当前奶牛minSPF值的防晒霜，都不会低于后面其他奶牛的minSPF。也就是说，对于当前奶牛可用的任意两瓶防晒霜x和y，如果SFP[X]&lt;SFP[y]，那么后面的奶牛只可能出现三种情况之一 x和y都能用 x和y都不能用 x能用，y不能用 因此当前奶牛选择较大的y去用，对于整体的影响肯定比选择较小的x去用要好，另外，每头奶牛对答案的贡献至多是1，即使让当前奶牛放弃日光浴，留下防晒霜给后面的某一头奶牛去用，对答案的贡献也不会更大，综上所述，尽量满足当前的奶牛，并选择SPF值尽量大的防晒霜是一个正确的贪心策略 1234567891011121314151617181920212223242526272829303132#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 2510;typedef pair&lt;int, int&gt; PII;int n, m;PII cows[N];int main() &#123; cin &gt;&gt; n &gt;&gt; m; map&lt;int, int&gt; spfs; for (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second; for (int i &#x3D; 0; i &lt; m; i++) &#123; int spf, cover; cin &gt;&gt; spf &gt;&gt; cover; spfs[spf] +&#x3D; cover; &#125; sort(cows, cows + n); int res &#x3D; 0; spfs[0] &#x3D; spfs[1001] &#x3D; 1; for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123; auto spf &#x3D; spfs.upper_bound(cows[i].second); spf--; if (spf-&gt;first &gt;&#x3D; cows[i].first) &#123; res++; if (--spf-&gt;second &#x3D;&#x3D; 0) spfs.erase(spf); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; ACWING111.畜栏预定按照开始吃草的时间把牛排序，用小根堆维护所有畜栏中最后一头牛结束吃草的时间的最小值，每循环到一头牛，如果这头牛的吃草开始时间比这个小根堆的堆顶大，则把这个牛插入到这个小根堆堆顶对应的畜栏中，再重新维护小根堆；如果小根堆的堆顶比这头牛的开始吃草时间大，则新建一个畜栏，插入到小根堆中 这种策略成功的原因在于：把每个畜栏的时间都充分利用，如果存在多个畜栏可以存放此牛，则选择最后一头牛结束吃草时间最小的畜栏，这样可以充分利用每个畜栏的时间；把每个牛的开始吃草时间从小到大排序的原因是，这样就可以让后面的牛插入在畜栏的后面，如果不排序，则每个畜栏前面可能有时间空隙放牛，这是不符合要求的，很难做出来 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 50010;int n;int id[N];pair&lt;PII, int&gt; cows[N];int main() &#123; cin &gt;&gt; n; for (int i &#x3D; 0; i &lt; n; i++) &#123; cin &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second; cows[i].second &#x3D; i; &#125; sort(cows, cows + n); priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap; for (int i &#x3D; 0; i &lt; n; i++) &#123; if (heap.empty() || heap.top().first &gt;&#x3D; cows[i].first.first) &#123; id[cows[i].second] &#x3D; heap.size() + 1; heap.push(&#123;cows[i].first.second, heap.size() + 1&#125;); &#125; else &#123; auto stall &#x3D; heap.top(); heap.pop(); stall.first &#x3D; cows[i].first.second; id[cows[i].second] &#x3D; stall.second; heap.push(stall); &#125; &#125; cout &lt;&lt; heap.size() &lt;&lt; endl; for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; id[i] &lt;&lt; endl; return 0;&#125; 未完待续","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/tags/ACM/"}]},{"title":"python基础总结——mosh版本","slug":"python基础总结——mosh版本","date":"2020-06-01T10:33:39.000Z","updated":"2020-06-02T00:57:19.329Z","comments":true,"path":"2020/06/01/python基础总结——mosh版本/","link":"","permalink":"http://liuhaotian.top/2020/06/01/python%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94mosh%E7%89%88%E6%9C%AC/","excerpt":"","text":"PYTHON视频讲解(MOSH)总结和C/C++的区别 python的print是一个函数，其中代表换行的参数默认换行，所以每次执行一次print都会自动换行 python的bool值是False和True，首字母大写，而C/C++的bool类型值是false和true，首字母小写 python的输出函数是print，而C的输出语句是printf python的输入语句是input()，这个函数把括号内的东西输出，并接受输入的值，所以可以有如下写法name = input(&quot;what&#39;s your name&quot;) input把接收的值转化为字符串 10/3 = 3.333，这与C/C++不同10//3 = 3，这与C/C++相同3**2 = 9，C/C++中没有此用法 C++中的类与python中的类有一点区别假设都定义了School这个类 12345C++:School one;python:one &#x3D; School() 基础语法 type(变量) 打印变量的类型 三个引号&#39;&#39;&#39; &#39;&#39;&#39;，三引号中间的变量可以换行，此外还有双引号和单引号 1234567891011121314程序：email &#x3D; &#39;&#39;&#39;Hello!This is Fu JANG &#39;s blog.Welcome to u.&#39;&#39;&#39;print(email)结果：Hello!This is Fu JANG &#39;s blog.Welcome to u.进程已结束,退出代码0 对于第二点的代码（三引号）email[0]就是H，email[-1]就是换行符，email[-2]就是.，而对于以下的代码： 123456程序：email &#x3D; &#39;Hello&#39;print(email[-1])结果：o [0:3]左闭右开[0:] 0到末尾[:3]与第一个等效[:] 全部 f&#39;{变量名}’ 占位符，程序会用对应变量的值去填充大括号 len() 返回字符串的长度 .upper()把字符串中字母全部转 为大写，但不改变原字符串.lower()把字符串中字母全部转为小写，但不改变原字符串.title()把字符串中单词首字母字母全部转为大写，但不改变原字符串 .find(&#39;&#39;)找到这个字符在字符串中的第一个索引 若&#39;&#39;中为一串字符，则返回第一个字符的索引 若&#39;&#39;中的字符在字符串中不存在，则返回-1 .replace(&#39;原&#39;, &#39;新&#39;) 若字符串中没有原字符，则不替换 &#39; &#39; in 变量 返回一个布尔值，代表该字符是否在此变量中 round()四舍五入abs()取绝对值 引用模块 12345678程序：import mathprint(math.ceil(2.9)) 封print(math.floor(2.9)) 底结果：32 if语句：if:elif:else: 逻辑运算符：and or not while循环，当条件不符合时，执行else，break的程序不执行elsewhile:else: range(10) 0到9range(5,10) 5到9range(5,10,2) 5,7,9 123456789101112131415代码：for item in range(10): print(item)结果：0123456789 列表：方括号 1[1,2,3] 二维列表 12345[ [1,2,3], [4,5,6], [7,8,9]] 列表定义的方法.append() 在最后面插入 .insert(0,10) 在索引为0的位置加10 .remove(5) 删除第一个5 .clear() 清空列表 .pop() 删最后 .index(5) 传第一个5的索引 .count(5) 传5的个数 .sort() 不返回值，从小到大排序 .reverse() 从大到小排序 .copy() 复制 (,,) 元组 不可变.count() 计数.index() 传索引 压缩属性 12m &#x3D; (1,2,3)x, y, z &#x3D; m 字典 1234567891011121314程序：customer &#x3D; &#123; &quot;name&quot; : &quot;FuJANG&quot;, &quot;sex&quot; : &quot;man&quot;, &quot;address&quot; : &quot;China&quot;, &quot;age&quot; : 6, &quot;is_handsome&quot; : True&#125;print(customer[&quot;name&quot;])结果：FuJANG进程已结束,退出代码0 字典定义的方法.get(&quot; &quot;) 若键不存在则返回None.get(&quot;key&quot;, &quot;value&quot;) 提供一个默认的值，并不修改字典，当在字典中对应的key存在时，默认值无效可用此形式更改、添加字典[&quot; &quot;] = &quot; &quot; 表示形式列表[ , , ]元组( , , )字典{ , , } abc = &quot;字符串”for ch in abc:遍历字符串中的所有字符abc.split(&quot;空格&quot;) 根据空格分割字符串中的单词并储存在一个列表中 函数与模块 定义一个函数 每个函数后最好加上两个空行（标准格式），先定义函数后才可引用，()中可以加参数，如(name),调用时需要传一个值如(&quot;Mosh&quot;)，关键字参数一般放在最后 没有return的函数默认返回None 当return x, y时，python把x, y解释为一个元组(x, y) 12def 函数名(): 内容 用try...expect来处理异常错误 1234try： ×××expect 错误类型: ××× class定义一个类，首字母大写，不用下划线 def定义一个函数，首字母小写，用下划线链接 1234567891011121314class Point: def ×××(self, ×××): ××× def ×××用类声明对象point1 &#x3D; Point()调用定义的方法point1.×××()可以在程序的任何位置设置属性，属性没有必要一定在类里定义point1.属性名 &#x3D; 10 python中的构造函数 1234567class Point: def __init__(self, x, y): self.x &#x3D; x self.y &#x3D; ypoint1 &#x3D; Point(10, 20) 继承：当一个类中没有任何东西时，为了规范格式，通常加一个pass 123456789101112class Normal: def walk(self): ×××class Dog(Normal): passclass Cat(Normal): def bark(self): print(&quot;×××&quot;) 调用模块 12345678import hellohello.×××()from hello import ××××××()import hello as hehe.×××() 建立一个包 1234567891011① New → Directory → __init__.py② New → Python Packageimport 包.文件包.文件.函数()from 包.文件 import 函数函数()from 包 import 文件文件.函数() 内置模块的调用举例 12345# randint 为闭区间import randomrandom.random() 随机跳出一个0和1间的数字random.randint(10, 20) 10到20间的一个整数值random.choice(numbers) 假如numbers是一个列表，则随机跳出列表中的一个元素 内置模块与下载模块python中有内置模块，当找不到想使用的模块时，可以去pypi.org寻找相应的模块下载命令，然后在终端上用命令下载相应的模块","categories":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"}],"tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"}]},{"title":"0x04二分","slug":"0x04二分","date":"2020-05-31T10:05:30.000Z","updated":"2020-05-31T10:49:10.522Z","comments":true,"path":"2020/05/31/0x04二分/","link":"","permalink":"http://liuhaotian.top/2020/05/31/0x04%E4%BA%8C%E5%88%86/","excerpt":"","text":"0x04二分基础知识二分的基础的用法是在单调序列或单调函数中进行查找，因此当问题的答案具有单调性时，就可以通过二分把求解问题转换为判定（根据复杂度理论，判定的难度小于求解），进一步地，我们还可以扩展到通过三分法去解决单峰函数的极值以及相关问题 对于整数域上的二分，需要注意中止边界、左右区间取舍时的开闭情况，避免漏掉答案或者造成死循环；对于实数域上的二分，需要注意精度问题 整数集合上的二分本文章的写法保证最终答案处于闭区间[l,r]以内，循环以l=r结束，每次二分的中间值mid会归属于左半段与右半段二者之一 模板如下： 在单调递增序列a中查找&gt;=x的数中最小的一个（x或x的后继）12345while (l &lt; r) &#123; int mid &#x3D; (l + r) &gt;&gt; 1; if (a[mid] &gt;&#x3D; x) r &#x3D; mid; else l &#x3D; mid + 1;&#125;return a[l];在单调递增序列a中查找&lt;=x的数中最大的一个（x或x的前驱）12345while (l &lt; r) &#123; int mid &#x3D; (l + r + 1) &gt;&gt; 1; if (a[mid] &lt;&#x3D; x) l &#x3D; mid; else r &#x3D; mid - 1;&#125;return a[l]; 如上面两段代码所示，这种二分写法可能会有两种形式：1.缩小范围时，r=mid， l=mid+1，取中间值时，mid=(l+r)&gt;&gt;12.缩小范围时，l=mid， r=mid-1，取中间值时，mid=(l+r+1)&gt;&gt;1如果不对mid的取法加以区分，假如第二段代码也采用mid=(l+r)&gt;&gt;1，那么当r-l等于1时，就有mid=(l+r)&gt;&gt;1=l，接下来若进入l=mid分支，可行区间未缩小，造成死循环；若进入r=mid-1分支，造成l&gt;r，循环不能以l=r结束；相反若mid=(l+r+1)&gt;&gt;1 ，则第二段代码则正确得到结果。因此对两个形式采用配套的mid取法是必要的。此外还要注意：我们在二分实现中采用了右移运算符&gt;&gt;1，而不是整数除法/2。这是因为右移运算是向下取整，而整数除法是向0取整，在二分值域包含负数时后者不能正常工作。 我用一个例题来体现这两个模板的差别：ACWING789.数的范围1234567891011121314151617181920212223242526272829303132#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int MAXN &#x3D; 1e5 + 10;int nums[MAXN];int main() &#123; int n, q; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for (int i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); &#125; while (q--) &#123; int l &#x3D; 0, r &#x3D; n - 1; int x; scanf(&quot;%d&quot;, &amp;x); while (l &lt; r) &#123; int mid &#x3D; (l + r) &gt;&gt; 1; if (nums[mid] &gt;&#x3D; x) r &#x3D; mid; else l &#x3D; mid + 1; &#125; if (nums[l] !&#x3D; x) printf(&quot;-1 -1\\n&quot;); else &#123; cout &lt;&lt; l &lt;&lt; &quot; &quot;; int l &#x3D; 0, r &#x3D; n - 1; while (l &lt; r) &#123; int mid &#x3D; (l + r + 1) &gt;&gt; 1; if (nums[mid] &lt;&#x3D; x) l &#x3D; mid; else r &#x3D; mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; &#125; return 0;&#125;可以看出这两个模板的另一个区别：当目标值不止一个时，第一个模板是取到左边，也就是在单调递增序列a中查找&gt;=x的数中最小的一个；第二个模板是取到右边，也就是在单调递增序列a中查找&lt;=x的数中最大的一个；当目标值只有只有一个时，两个模板的结果没有差别 仔细分析这两种mid的取法，我们还发现：mid=(l+r)&gt;&gt;1不会取到r这个值，mid=(l+r+1)&gt;&gt;1不会取到l这个值，我们可以利用这一性质来处理无解的情况，把最初的二分区间分别扩大为[1,n+1]和[0,n]，把a数组的一个越界下标包含进来。如果最后二分终止于扩大后的这个越界下标上，则说明目标值不在a中；当然我们也可以直接看最终求得的l下标在a数组中对应的值是否为目标值 二分的终止条件就是l==r，该值就是答案所在位置 C++STL的lower_bound和upper_bound函数实现了在一个序列中二分查找某个整数x的后继 未完待续","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/tags/ACM/"}]},{"title":"CODEFORCES 1300 1360D.Buying Shovels","slug":"CODEFORCES1360D","date":"2020-05-31T09:20:46.000Z","updated":"2020-05-31T10:03:27.607Z","comments":true,"path":"2020/05/31/CODEFORCES1360D/","link":"","permalink":"http://liuhaotian.top/2020/05/31/CODEFORCES1360D/","excerpt":"","text":"1360D.Buying Shovels原题链接1360D.Buying Shovels 题目大意第一行输入测试数目 之后每一行为一组测试： 每组测试输入两个数：n和k 描述：有k种包裹，第i个包裹里有i个铲子，只能选择一种包裹，可选这个包裹无限次，要求选择的包裹数最少，并且铲子和等于n 解题思路根据数据范围可以看出是求质数问题，求n中的质数，要求此质数在k的范围内，n/此质数最小，意思就是选最大的可以除尽的包裹，得到的就是选择包裹数最少 解题代码123456789101112131415161718192021#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); int ans &#x3D; n; for (int i &#x3D; 1; i * i &lt;&#x3D; n; i++) &#123; if (n % i &#x3D;&#x3D; 0) &#123; if (i &lt;&#x3D; k) ans &#x3D; min(ans, n &#x2F; i); if (n &#x2F; i &lt;&#x3D; k) ans &#x3D; min(ans, i); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;","categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"}],"tags":[{"name":"acm/math","slug":"acm-math","permalink":"http://liuhaotian.top/tags/acm-math/"},{"name":"CODEFORCES1300","slug":"CODEFORCES1300","permalink":"http://liuhaotian.top/tags/CODEFORCES1300/"}]},{"title":"CODEFORCES 1100 1360C.Similar Pairs","slug":"CODEFORCES1360C","date":"2020-05-31T06:57:15.000Z","updated":"2020-05-31T10:03:09.795Z","comments":true,"path":"2020/05/31/CODEFORCES1360C/","link":"","permalink":"http://liuhaotian.top/2020/05/31/CODEFORCES1360C/","excerpt":"","text":"1360C.Similar Pairs原题链接1360C.Similar Pairs 题目大意第一行输入测试数目 之后每两行为一组测试： 第二行输入每组测试的元素个数 第三行输入每组的元素 描述：当两个数奇偶相同或者绝对值相差1则称这两个数为1组，每次测试给你偶数个数，问所有元素是否有与它配对的数 解题思路因为一共有偶数个数，所以当奇数元素个数为偶数时，偶数元素个数也一定为偶数，则一定可以两两配对；如果奇数元素个数和偶数元素个数都为奇数时，检查是否存在一个奇数和一个偶数相减的绝对值为1的情况，如果存在这种情况，则一定可以两两配对，如果不存在，则不能两两配对 解题代码123456789101112131415161718192021222324252627282930313233#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int nums[55];int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; memset(nums, 0, sizeof nums); int n; scanf(&quot;%d&quot;, &amp;n); int sum &#x3D; 0; for (int i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;nums[i]); if (nums[i] % 2) sum++; &#125; if (sum % 2 &#x3D;&#x3D; 0) printf(&quot;YES\\n&quot;); else &#123; sort(nums, nums+n); int flag &#x3D; 0; for (int i &#x3D; 1; i &lt; n; i++) &#123; if (abs(nums[i] - nums[i - 1] &#x3D;&#x3D; 1)) &#123; printf(&quot;YES\\n&quot;); flag &#x3D; 1; break; &#125; &#125; if (flag &#x3D;&#x3D; 0) printf(&quot;NO\\n&quot;); &#125; &#125; return 0;&#125;","categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"}],"tags":[{"name":"acm/greedy","slug":"acm-greedy","permalink":"http://liuhaotian.top/tags/acm-greedy/"},{"name":"CODEFORCES1100","slug":"CODEFORCES1100","permalink":"http://liuhaotian.top/tags/CODEFORCES1100/"}]},{"title":"translate first day","slug":"translate-first-day","date":"2020-05-30T23:38:27.000Z","updated":"2020-05-30T23:55:04.554Z","comments":true,"path":"2020/05/31/translate-first-day/","link":"","permalink":"http://liuhaotian.top/2020/05/31/translate-first-day/","excerpt":"","text":"A week of distractions from Trump shows a leader in crisis(CNN)On Monday, as the nation marked Memorial Day, President Donald Trump mocked his campaign rival for wearing a face mask. On Wednesday, as the national death toll from coronavirus reached a wretched milestone, Trump and his family flew to Florida in an attempted focus on space travel. By Friday, as smoke was lifting in Minneapolis after a night of racial unrest, he announced the United States would withdraw from the World Health Organization. A day later, after another night of protests, he declared himself safe inside his heavily fortified mansion and insinuated his own supporters would rally outside that evening. In between, there was a dark suggestion of murder, false conspiracies about voting through the mail, a fight over where to hold his nominating convention and a dramatic escalation of ill will with the very social media platform that facilitated almost all the other diversions in the first place. Trump’s efforts to change the subject at moments of peril have been a hallmark of his entire career in politics and, when successful, a constant source of frustration for his rivals. But rarely have they appeared more blatant or off-key than now, as a battered nation emerges from a pandemic that has left more than 100,000 dead and as racial unrest brews again.That it is all happening five months before Trump faces an election in which polls show him trailing only heightens the sense of a leader in crisis, even as he insists he has a handle on both matters and attempts to proceed as planned with his presidency. Trump, cognizant of his precarious political position, has retrenched. Unwilling or unable to strike a unifying tone, Trump lashed out Saturday morning when he criticized the Democratic mayors of Washington and Minneapolis while appearing to summon his own supporters to rally outside the White House. After announcing his was safe, warning he was protected by “vicious dogs” and “ominous weapons,” Trump provided a play-by-play of Friday evening’s protests, of which he said he’d “watched every move.” Trump wrote: “Tonight, I understand, is MAGA NIGHT AT THE WHITE HOUSE???” Advisers insist Trump is focused on reviving the country after three months of pandemic that have led, along with the six-figure death toll, to record levels of unemployment and entire industries shuttered. Trump has aggressively pushed for states to reopen even when they don’t necessarily meet the parameters set out by his task force, which has seen its meetings sharply curtailed and its health experts’ public roles reduced. At the same time, Trump has sought over the past week to shine the presidential spotlight into dustier corners filled with festering racial grievances and antique conspiracies, all of which have been debunked. He has waged feuds old and new and unveiled strategically timed policy announcements at a moment when his leadership is being questioned. The events that unfolded after the President issued a tweet early Friday laden with racist overtones underscored the degree to which he has used inflammatory statements to ignite controversy and enthuse his supporters, even as he denied later that those were his intentions. Aides spent Friday debating whether Trump should address the situation in Minnesota during a planned appearance in the Rose Garden, which had been called to announce new actions against China and the US withdrawal from the World Health Organization. Some of his advisers encouraged him to speak about Minnesota because his election-year rival had already delivered an address on the topic. Others were more skeptical, convinced Trump would only face more questions about his tweet that used a phrase first uttered by a Miami police chief in 1967 to describe a crackdown in black neighborhoods. More than 12 hours after tweeting “when the looting starts, the shooting starts” as images of Minneapolis fire and riots played on cable news, Trump insisted on Twitter that his message was not, in fact, a reference to brutal civil rights-era police tactics. But he ignored the topic in the Rose Garden, choosing instead to focus on China and retreating to the Oval Office as reporters shouted questions. It was only around 5 p.m. ET — after a full day of public silence — that Trump announced he’d spoken with the family of George Floyd, the black man who had died after being pinned to the ground by his neck by a white police officer. “It certainly looked like there was no excuse for it,” he said of the violent arrest during a roundtable event meant to focus on coronavirus. The episode followed Trump’s longtime model of igniting controversy before retreating hours later. If anything, leaving his message lingering without explanation was a diversion in itself and another example of Trump’s inability — or unwillingness — to put aside the divisive itch he’s long cultivated. The role of national consoler has never come easily to Trump, nor have attempts at unifying a country riven by politics and ideology. In many instances he’s simply shown no interest in assuming the tone or accepting the responsibilities that US presidents have shouldered throughout history. He doesn’t believe it’s up to him to demonstrate responsible mask-wearing, and he retweeted a message earlier this week that appeared to mock former Vice President Joe Biden’s mask-and-aviators ensemble. Most of the country may say Trump should wear a mask in public — a Quinnipiac University poll this week put the figure at 67% — but among white men the number stands only at 49%, enough for his stance to pass political muster with his most reliable bloc of supporters. As coronavirus began ravaging parts of the country, he did declare himself a wartime President waging battle against the “invisible enemy.” But with war comes death — in this case, more US deaths than the Vietnam and Korean wars combined — and Trump was slow to acknowledge the 100,000 milestone reached midweek. He was aboard Air Force One when the death toll officially ticked into six digits, returning to Washington after his plans to witness the first manned US space launch in nearly a decade had been thwarted by the weather. He had hoped that the trip, with his entire family in tow, would help shift a national storyline from the miserable pandemic toward a more optimistic one of scientific potential. But the launch was scrubbed when thunderstorms rolled in and Trump was forced to return to Washington. The President didn’t address the grim figure as he returned to the White House with the first lady on Wednesday. He finally tweeted about it on Thursday morning, deeming it “a very sad milestone.” But he did not make time to address it in person. Instead, he has wielded sinister conspiracies and false allegations. He’s railed against vote-by-mail, which many governors are seeking to expand amid a highly contagious viral pandemic and which has not proved to be rife with fraud. Despite his issues with the practice, Trump himself voted by mail in February, even though he was in Florida — the state where he votes — on the day that early voting locations opened and drove past one that’s across from his golf course at least six times. He has actively worked to relitigate the circumstances that led to Robert Mueller’s Russia investigation, including this week, when he fan-danced around the still-unnamed allegation against his predecessor Barack Obama. On Friday evening, his newly installed director of national intelligence appeared to further the cause by releasing the transcripts of phone calls between Trump’s onetime national security adviser and the then-Russian ambassador to the United States. The darkest of Trump’s fixations remains the unfounded insinuation that a morning cable news host played a role in killing a young aide almost two decades ago, a blatant falsehood that led this week to pleas from the young woman’s widower for Twitter to disallow the messages. The social media giant did not block those messages but did attempt to fact-check his claims about vote-by-mail, a move that set Trump off and led to a hurried effort inside the White House to finalize an executive order few believe will withstand legal scrutiny and that could, potentially, cause even more regulation of the President’s tweets. Hours after he signed it, Twitter slapped a warning on his Minnesota tweet, saying it glorified violence. At one time, Trump used his once-a-week campaign rallies to unleash the vitriol and paranoia that his supporters love and that he believes are the very characteristics that led to his unlikely victory in 2016. Rallies are out of the question for now — though aides say they’re looking to revive them sooner rather than later. This story has been updated with additional developments.","categories":[{"name":"TRANSLATE","slug":"TRANSLATE","permalink":"http://liuhaotian.top/categories/TRANSLATE/"}],"tags":[{"name":"TRANSLATE","slug":"TRANSLATE","permalink":"http://liuhaotian.top/tags/TRANSLATE/"}]},{"title":"CODEFORCES 800 1360B.Honest Coach","slug":"CODEFORCES1360B","date":"2020-05-30T11:35:09.000Z","updated":"2020-05-30T12:48:03.435Z","comments":true,"path":"2020/05/30/CODEFORCES1360B/","link":"","permalink":"http://liuhaotian.top/2020/05/30/CODEFORCES1360B/","excerpt":"","text":"1360B.Honest Coach原题链接1360B.Honest Coach 题目大意第一行输入测试数目 第二行输入队员个数 描述：把队员分成两队，每队最少为1人，求abs|第一个队的最大值减去第二个队的最小值|最小 解题思路贪心的思想，先排序，再贪心 解题代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; int n; scanf(&quot;%d&quot;, &amp;n); vector&lt;int&gt; nums(n); for (auto &amp;x : nums) &#123; scanf(&quot;%d&quot;, &amp;x); &#125; sort(nums.begin(), nums.end()); int result &#x3D; 0x3f3f3f3f; for (int i &#x3D; 1; i &lt; n; i++) &#123; result &#x3D; min(result, abs(nums[i] - nums[i - 1])); &#125; printf(&quot;%d\\n&quot;, result); &#125;&#125;","categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"}],"tags":[{"name":"CODEFORCES800","slug":"CODEFORCES800","permalink":"http://liuhaotian.top/tags/CODEFORCES800/"},{"name":"acm/greedy","slug":"acm-greedy","permalink":"http://liuhaotian.top/tags/acm-greedy/"}]},{"title":"API之stringstream用法","slug":"API之stringstream用法","date":"2020-05-30T02:06:47.000Z","updated":"2020-05-30T03:11:16.954Z","comments":true,"path":"2020/05/30/API之stringstream用法/","link":"","permalink":"http://liuhaotian.top/2020/05/30/API%E4%B9%8Bstringstream%E7%94%A8%E6%B3%95/","excerpt":"","text":"API之stringstream用法本文主要介绍 C++ 中 stringstream 类的常见用法。 1.概述&lt;sstream&gt;定义了三个类：istringstream、ostringstream和stringstream，分别用来进行流的输入、输出和输入输出操作。本文以stringstream为主，介绍流的输入和输出操作 &lt;sstream&gt;主要用来进行数据类型转换，由于&lt;sstream&gt;使用string对象来代替字符数组（snprintf方式），就避免缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符的问题。简单说，相比c库的数据类型转换而言，&lt;sstream&gt;更加安全、自动和直接 2.代码示例2.1数据类型转换这里展示一个代码示例，该示例介绍了将int类型转换为string类型的过程。示例代码（stringstream_test1.cpp）如下：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() &#123; stringstream sstream; string strResult; int nValue &#x3D; 1000; &#x2F;&#x2F; 将int类型的值放入输入流中 sstream &lt;&lt; nValue; &#x2F;&#x2F; 从sstream中抽取前面插入的int类型的值，赋给string类型 sstream &gt;&gt; strResult; cout &lt;&lt; &quot;[cout]strResult is: &quot; &lt;&lt; strResult &lt;&lt; endl; printf(&quot;[printf]strResult is: %s\\n&quot;, strResult.c_str()); return 0;&#125;结果如下：12[cout]strResult is: 1000 [printf]strResult is: 1000 2.2多个字符串拼接本示例介绍在stringstream中存放多个字符串，实现多个字符串拼接的目的（其实完全可以使用 string类实现），同时，介绍stringstream的清空方法。示例代码（stringstream_test2.cpp）如下： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() &#123; stringstream sstream; &#x2F;&#x2F; 将多个字符串放入 sstream 中 sstream &lt;&lt; &quot;first&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;string,&quot;; sstream &lt;&lt; &quot; second string&quot;; cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl; &#x2F;&#x2F; 清空 sstream sstream.str(&quot;&quot;); sstream &lt;&lt; &quot;third string&quot;; cout &lt;&lt; &quot;After clear, strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl; return 0;&#125; 结果如下：12strResult is: first string, second stringAfter clear, strResult is: third string 从上述代码执行结果能够知道： 可以使用str()方法，将stringstream类型转换为string类型 可以将多个字符串放入stringstream中，实现字符串的拼接目的 如果想清空stringstream，必须使用sstream.str(&quot;&quot;); 方式:clear()方法适用于进行多次数据类型转换的场景。详见示例2.3 2.3stringstream的清空清空stringstream有两种方法：clear()方法以及str(&quot;&quot;)方法，这两种方法有不同的使用场景。str(&quot;&quot;)方法的使用场景，在上面的示例中已经介绍了，这里介绍clear()方法的使用场景。示例代码（stringstream_test3.cpp）如下： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; stringstream sstream; int first, second; &#x2F;&#x2F; 插入字符串 sstream &lt;&lt; &quot;456&quot;; &#x2F;&#x2F; 转换为int类型 sstream &gt;&gt; first; cout &lt;&lt; first &lt;&lt; endl; &#x2F;&#x2F; 在进行多次类型转换前，必须先运行clear() sstream.clear(); &#x2F;&#x2F; 插入bool值 sstream &lt;&lt; true; &#x2F;&#x2F; 转换为int类型 sstream &gt;&gt; second; cout &lt;&lt; second &lt;&lt; endl; return 0;&#125; 结果如下：124561 注意：在本示例涉及的场景下（多次数据类型转换），必须使用clear()方法清空stringstream，不使用clear()方法或使用str(&quot;&quot;)方法，都不能得到数据类型转换的正确结果。下图分别是未使用clear()方法、使用str(&quot;&quot;)方法时的运行结果： 1234545641970084560 2.4测试1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main() &#123; stringstream sstream; &#x2F;&#x2F; 将多个字符串放入 sstream 中 sstream &lt;&lt; &quot;firstiiii&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;string,&quot;; sstream &lt;&lt; &quot; second string&quot;; string a, b; sstream &gt;&gt; a; cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; a &lt;&lt; endl; sstream &gt;&gt; a; cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; sstream.str(); return 0;&#125; 结果如下：123strResult is: firstiiiistrResult is: string,firstiiii string, second string由此可知，我们可以用它来分割字符串中的单词 3.例题LEETCODE1455. 检查单词是否为句中其他单词的前缀 123456789101112class Solution &#123; public: int isPrefixOfWord(string sentence, string searchWord) &#123; stringstream ssin(sentence); string word; for (int i &#x3D; 1; ssin &gt;&gt; word; i++) if (word.substr(0, searchWord.size()) &#x3D;&#x3D; searchWord) return i; return -1; &#125;&#125;;","categories":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/categories/C-C-%E5%B8%B8%E7%94%A8API/"}],"tags":[{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/tags/C-C-%E5%B8%B8%E7%94%A8API/"}]},{"title":"0x02递推与递归","slug":"0x02递推与递归","date":"2020-05-30T00:39:58.000Z","updated":"2020-05-30T04:14:30.400Z","comments":true,"path":"2020/05/30/0x02递推与递归/","link":"","permalink":"http://liuhaotian.top/2020/05/30/0x02%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/","excerpt":"","text":"0x02递推与递归基础知识一个实际问题的各种可能情况构成的集合通常称为“状态空间”，而程序的运行则是对状态空间的遍历 对于一个待求解的问题，当它局限在某处边界、某个小范围或者某种特殊情况下时，其答案往往是已知的。如果能够将该解答的应用场景扩大到原问题的状态空间，并且扩展过程的每个步骤具有相似性，就可以考虑使用递推或者递归求解 以已知的“问题边界”为起点向“原问题”正向推导的扩展方式就是递推。然而在很多时候，推导的路线难以确定，这时以“原问题”为起点尝试寻找把状态空间缩小到已知的“问题边界”路线，再通过该路线反向回溯的遍历方式就是递归 使用递推或递归要求“原问题”与“问题边界”之间的每个变换步骤具有相似性，这样我们才能设计一段程序来实现该步骤，将其重复作用于问题之中。换句话说，程序在每个步骤上应该面对相同种类的问题，这些问题都是原问题的一个子问题，可能仅在规模或者某些限制条件上有所区别，并且能够使用“求解原问题的程序”进行求解 对于递归算法，有了上面这个前提，我们就可以让程序在每个变换步骤中执行三个操作： 缩小问题状态空间的规模。这意味着程序尝试寻找在“原问题”与“问题边界”之间的变换路线，并向正在探索的路线迈出一步 尝试求解规模缩小以后的问题，结果可能是成功，也可能是失败 如果成功，即找到了规模缩小后的问题的答案，那么将答案扩展到当前问题；如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直至最终确定当前问题无法继续求解 以上三个操作有两点特别关键：一是“如何尝试求解规模缩小以后的问题”。因为规模缩小以后的问题是原问题的一个子问题，所以我们可以把它视为一个新的原问题，由相同的程序进行求解，这就是所谓的“自身调用自身”；二是如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“回溯时还原现场”，关于递归与回溯，举一道简单的例题 LEETCODES1457. 二叉树中的伪回文路径1234567891011121314151617181920212223242526272829303132&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123; public: unordered_map&lt;int, int&gt; cnt; int pseudoPalindromicPaths(TreeNode* root) &#123; cnt[root-&gt;val]++; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; int t &#x3D; 0; for (auto item : cnt) if (item.second % 2) t++; cnt[root-&gt;val]--; return t &lt;&#x3D; 1; &#125; int res &#x3D; 0; if (root-&gt;left) res +&#x3D; pseudoPalindromicPaths(root-&gt;left); if (root-&gt;right) res +&#x3D; pseudoPalindromicPaths(root-&gt;right); cnt[root-&gt;val]--; return res; &#125;&#125;; y总原话：从这道题中我们可以看出回溯时还原现场的要求，每一次return之前都要记得恢复，有两次return，所以两次都要记得恢复。我们要记住一点：如果进来的时候修改了，那么在退出之前就应该恢复 重申：如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“回溯时还原现场” 递归总结可以看到，递归程序的基本单元是由“缩小”、“求解”、“扩展”组成的一种变换步骤，只是在“求解”时因为问题的相似性，不断重复使用了这样一种变换步骤，直至在一致的问题边界上直接确定答案。对于其中任意一条从“原问题”到“边界问题”的变换路线，横向来看，它跳的每一层是一次递归程序的执行；纵向来看，它的左右两边分别是寻找路线和沿其推导的流程。为了保证每层的“缩小”与“拓展”能够衔接在同一形式的问题上，“求解”操作自然要保证在执行前后程序面对的问题的状态是相同的，这也就是“还原现场”的必要性所在 递推与递归的简单应用在使用枚举算法蛮力探索问题的整个”状态空间“时，经常需要递归。按照规模大小，有如下的几种常见的枚举形式和遍历方式： 枚举形式 状态空间规模 一般遍历方式 多项式 n^k k为常数 循环(for)、递推 指数 k^n k为常数 递归、位运算 排列 n! 递归、C++next_permutation 组合 C_n^m 递归+减枝 递归的机器实现一台典型的32位计算机采用“堆栈结构”来实现函数调用，它在汇编语言中，把函数所需的第k个、第k-1个，……，第1个参数依次入栈，然后执行call(address)指令。该指令把返回地址（当前语句的下一条语句地址）入栈，然后跳转到address位置的语句。在函数返回时，它执行ret指令。该指令把返回地址出栈，并跳转到该地址继续执行 对于函数中定义的C++局部变量，在每次执行call与ret指令时，也会在栈中相应的保存与复原，而作用范围超过该函数的变量，以及通过new和malloc函数动态分配的空间则保存在另一块成为堆的结构中。栈指针、返回值、局部的运算会借助CPU的“寄存器”完成 由此我们得知： 局部变量在每层递归中都占有一份空间，声明过多或递归过深就会超出”栈“所能存储的范围，造成栈溢出 非局部变量对于各层递归都共享一份空间，需要及时维护、还原现场，以防止在各层递归之间存储和读取的数据相互影响 了解了递归的及其实现之后，我们就可以使用模拟的方法，把递归程序改写为非递归程序。具体来说，我们可以用一个数组来模拟栈，使用变量来模拟栈指针和返回值，使用switch/case或者goto/label来模拟语句跳转 分治分治法把一个问题划分成若干个规模更小的同类子问题，对这些子问题递归求解，然后在回溯时通过它们推导出原问题的解","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/tags/ACM/"}]},{"title":"0x01位运算例题","slug":"0x01位运算例题","date":"2020-05-29T01:00:46.000Z","updated":"2020-05-29T05:49:50.919Z","comments":true,"path":"2020/05/29/0x01位运算例题/","link":"","permalink":"http://liuhaotian.top/2020/05/29/0x01%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BE%8B%E9%A2%98/","excerpt":"","text":"0x01位运算例题 点击每道题题目即可获取原题链接 a^b分析long long可以表示的最大值为922 3372 0368 5477 5807unsigned long long可以表示的最大值为1844 6744 0737 0955 1615 由此观之a^b大于ULL类型可以表示的最大值，所以要用快速幂的思想来求解这道题。 且取模的性质如下 (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p) % p (a b) % p = (a % p b % p) % p a ^ b % p = ((a % p)^b) % p 代码12345678910111213141516#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int power(int a, int b, int c) &#123; int ans &#x3D; 1 % c; for (; b; b &gt;&gt;&#x3D; 1) &#123; if (b &amp; 1) ans &#x3D; (long long)ans * a % c; a &#x3D; (long long)a * a % c; &#125; return ans;&#125;int main() &#123; int a, b, p; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;p); int ans &#x3D; power(a, b, p); printf(&quot;%d&quot;, ans);&#125; 复杂度我们可以用b&amp;1运算表示b的二进制下的最低位，并用b&gt;&gt;1来舍去最低位。在递归的过程中把&gt;&gt;和&amp;结合，其时间复杂度为O(logb) 64位整数乘法代码1234567891011121314151617#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long LL;LL power(LL a, LL b, LL c) &#123; LL ans &#x3D; 0; for (; b; b &gt;&gt;&#x3D; 1) &#123; if (b &amp; 1) ans &#x3D; (ans + a) % c; a &#x3D; a * 2 % c; &#125; return ans;&#125;int main() &#123; LL a, b, p; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p); LL ans &#x3D; power(a, b, p); printf(&quot;%lld&quot;, ans);&#125; 复杂度我们可以用b&amp;1运算表示b的二进制下的最低位，并用b&gt;&gt;1来舍去最低位。在递归的过程中把&gt;&gt;和&amp;结合，其时间复杂度为O(logb)，与上一题不同的是位数问题，但是每次%p之后都能保证不超过2*10^18，在long long的范围内 最短Hamilton路径分析我们可以采用朴素算法,其时间复杂度为O(n*n!)，n!为枚举n个点的全排列，n代表枚举路径的长度求得结果，这个算法的时间复杂度太高，不符合。而我们可以用二进制状态压缩DP来把时间复杂度优化到O((n^2)*(2^n)),我们用F[i,j]表示点被经过的状态对应二进制数i，且目前处于点j的最短路径 在起点时F[1,0]=0，即目前处于点0且只经过了点0的最短路径为0。为方便起见，我们将数组中其他元素设为无穷大，最终目的是求F[(1&lt;&lt;n),n-1]的值，即经过所有点且最终处于n-1的最短路径 在任意时刻，有公式F[i,j]=min(F[i,j],F[i^(1&lt;&lt;j),k]+weight[k,j])，根据分析可得k一定是倒数第二个经过的点。我们枚举k，当k对应在i的二进制为1时，我们讨论这种情况并比较 代码1234567891011121314151617181920212223#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 20, M &#x3D; 1 &lt;&lt; 20;int weight[N][N], F[M][N];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i &#x3D; 0; i &lt; n; i++) for (int j &#x3D; 0; j &lt; n; j++) scanf(&quot;%d&quot;, &amp;weight[i][j]); memset(F, 0x3f, sizeof F); F[1][0] &#x3D; 0; for (int i &#x3D; 1; i &lt; 1 &lt;&lt; n; i++) for (int j &#x3D; 0; j &lt; n; j++) if (i &gt;&gt; j &amp; 1) for (int k &#x3D; 0; k &lt; n; k++) if ((i ^ 1 &lt;&lt; j) &gt;&gt; k &amp; 1) F[i][j] &#x3D; min(F[i][j], F[i ^ 1 &lt;&lt; j][k] + weight[k][j]); printf(&quot;%d&quot;, F[(1 &lt;&lt; n) - 1][n - 1]);&#125; 还差一题，未完待续","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/tags/ACM/"}]},{"title":"CODEFORCES 800 1360A.Minimal Square","slug":"CODEFORCES1360A","date":"2020-05-28T10:07:07.000Z","updated":"2020-05-28T10:45:59.408Z","comments":true,"path":"2020/05/28/CODEFORCES1360A/","link":"","permalink":"http://liuhaotian.top/2020/05/28/CODEFORCES1360A/","excerpt":"","text":"1360A.Minimal Square原题链接1360A.Minimal Square 题目大意第一行输入测试数目 从第二行开始依次输入每个测试样例的a和b 描述：a代表长，b代表宽，要求输出一个正方形的最小面积，这个正方形把两个相同的长方形(样例输入构成的长方形)覆盖，且这两个长方形不重合，每个长方形的边与正方形平行 解题思路求出长和宽的最小值乘以2，之后将所得的值与长和宽比较得出的最大值作为目标正方形的边长，再输出面积 解题代码1234567891011121314#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int temp &#x3D; min(a, b); int side &#x3D; 2 * temp; int s &#x3D; pow(max(side, max(a, b)), 2); printf(&quot;%d\\n&quot;, s); &#125;&#125;","categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"}],"tags":[{"name":"CODEFORCES800","slug":"CODEFORCES800","permalink":"http://liuhaotian.top/tags/CODEFORCES800/"},{"name":"acm/math","slug":"acm-math","permalink":"http://liuhaotian.top/tags/acm-math/"}]},{"title":"0x01位运算","slug":"0x01位运算","date":"2020-05-28T04:52:08.000Z","updated":"2020-05-28T09:12:19.550Z","comments":true,"path":"2020/05/28/0x01位运算/","link":"","permalink":"http://liuhaotian.top/2020/05/28/0x01%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"0x01 位 运 算基础知识 用xor表示异或运算，在m位二进制数中，通常称最低位为0位，从右到左依此类推，最高位为m-1位。 |-1|的原码为00000001|-1|的反码为11111110-1的补码为11111111，十六进制表示为0xff8位二进制对应的最大值127的十六进制表示为0x7f在计算机中数字以其补码的形式保存，正数的补码等于其原码，负数的补码等于其对应正数的原码取反码再+1 对于32位二进制数C(设十进制的值为S)，其按位取反得到的编码~C对应的十进制的值为-1-S(正负都满足此规律) 补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在32位补码下做最高位不进位的二进制加减法运算。发生算术溢出时，32位无符号整数相当于自动对2^32取模，这也解释了有符号整数溢出时为何会出现负数的现象。 在算法竞赛中常用十六进制来表示一个常数，这样书写需要八个字符。| 10进制 | 16进制 || :-: | :-: || 21 4748 3647 | 0x7f ff ff ff || 10 6110 9567 | 0x3f 3f 3f 3f || -1 | 0xff ff ff ff | 4个字节的int表示的最大值为21 4748 36474个字节的unsigned int表示的最大值为42 9496 7295 0x3f 3f 3f 3f是一个很有用的值，它满足两个条件：其一，整数的两倍不超过int能表示的最大正整数其二，二进制下每八位都相同因此，我们可以用memset(a, 0x3f, sizeof a)来给a数组的每一个元素都赋值为正无穷，虽然0x7f能给每一个元素赋值成最大，但是为了避免溢出情况，推荐用0x3f。 1 &lt;&lt; n = 2^n, n &lt;&lt; 1 = 2nn &gt;&gt; 1 = n / 2.0 向下取整需要注意的是，整数做/运算执行的是向0取整(-3) &gt;&gt; 1 = -2, (-3) / 2 = -1 除非特殊提示，我们默认右移采用的是算术右移的实现方式 逻辑右移不考虑符号位，右移一位，左边补零即可。 算术右移考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。 所以算术右移也可以进行有符号位的除法,右移n位就等于除2的n次方。 例如，8位二进制数11001101分别右移一位。 逻辑右移就是[0]1100110 算术右移就是[1]1100110 状态压缩二进制状态压缩是指将一个长度为m的bool数组用一个m位二进制整数表示并存储的方法，利用如下操作实现对原bool数组对应下标元素的存取。 取出整数n的第k位：(n&gt;&gt;k)&amp;1 取出整数n的后k位(0到k-1位)：((1&lt;&lt;K)-1)&amp;n 把整数n的第k位反转：(1&lt;&lt;k) nor n 把整数n的第k位赋值为1：(1&lt;&lt;k)|n 把整数n的第k位赋值为0：(~(1&lt;&lt;k))&amp;n 当m不大时，我们可以使用一个整数存储，当m很大时，我们可以用若干个整数存储(int数组)，也可以用C++STL为我们提供的bitset实现。 成对变换通过计算可发现，对于非负整数n: 当n为偶数时，n xor 1 = n + 1 当n为奇数时，n xor 1 = n - 1 因此0与1, 2与3, 4与5 … 关于xor 1运算构成成对变换。 这一性质经常用于图论邻接表中边集的存储。在具有无向边(双向边)的图中把一对正反方向的边分别存储在邻接表数组的第n与n+1位置(其中n为偶数)，就可以通过xor 1的运算获得与当前边(x,y)反向的边(y,x)的存储位置。 lowbit运算lowbit(n)定义为非负整数n在二进制表示下“最低位的1及其后边所有的0”构成的数值。 例子：lowbit(10)=2 其原理为：lowbit(n)=n&amp;(~n-1)=n&amp;(-n) lowbit运算配合Hash可以找出整数二进制下所有是1的位，所花费的时间与1的个数同级。为了达到这个目的，我们只需要不断把n赋值为n-lowbit(n)直至n=0。我们可以把每次减去的数(其一定为2的幂)求log得到对应的1所在的位数，因为C++math.h库中的log函数复杂度常数较大，所以我们可以预处理一个数组，通过Hash的方法代替log运算。 此外lowbit运算也是树状数组中的一个基本运算。","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/tags/ACM/"}]},{"title":"HEXO+BUTTERFLY搭建骚气且实用的个人网站","slug":"HEXO-BUTTERFLY搭建骚气且实用的个人网站","date":"2020-05-27T03:01:58.000Z","updated":"2020-05-27T05:39:36.250Z","comments":true,"path":"2020/05/27/HEXO-BUTTERFLY搭建骚气且实用的个人网站/","link":"","permalink":"http://liuhaotian.top/2020/05/27/HEXO-BUTTERFLY%E6%90%AD%E5%BB%BA%E9%AA%9A%E6%B0%94%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/","excerpt":"","text":"YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS. 引子最近狂刷codeforces，但是逐渐发现自身一个问题，那就是刷过的题虽然在当天感觉很明白，但是隔一天，隔两天，就发现自己再遇到此题时又是一翻鏖战，这就是说明自己做过的题吸收的效率不够高，于是我就打算做一道题总结一道题。那么问题来了，在哪里总结呢？ 首先排除的是微信公众号，众所周知，微信公众号只能是自己分享东西的平台，而在这上面总结知识点就会引出很多问题，其一，每篇文章都要排版，其二，我的粉丝未必合此文章的胃口，其三，每天只能发布一篇文章，大大限制了自己的总结内容与时间分配。 那么诸如csdn、博客园、掘金、知乎这种东西呢？也有很多不方便的地方，比如文章左右侧的广告，实在影响人的心情，此外还有审核等等的制约，思前想后，我决定自己开辟一个个人网站。 当然不能从无到有手动开辟，自己能力有限，而且我的目的也是总结，总不能让自己以后把大把的时间浪费到维护网站上面去。于是我听从了大佬的建议，采用hexo+github的方式，hexo开辟网站，托管到github上面去。 花里胡哨的页面也是最吸引我的原因之一，我采用了butterfly的主题，绝对美炸天！ 过程过程当然是心酸+心酸+心酸，心态险些被搞没。至于搭建网站的教程，实话实说，看了n多篇技术总结，都号称史上最全，到最后还是觉得看官方文档最省事。 当然自己也找到了一些好的文章，在此列出来希望对大家有帮助： hexo安装文章： Hexo+Butterfly+Github+Coding搭建个人博客 hexo官方文档 butterfly主题系列文章： hexo-theme-butterfly 安装文档(一)快速开始 hexo-theme-butterfly 安装文档(二)主题页面 hexo-theme-butterfly 安装文档(三)主题配置 hexo-theme-butterfly 安装文档(四)主题问答、打赏名单 hexo-theme-butterfly 安装文档(五)更新日誌 收益没日没夜的折腾了两天，总能从其中学到什么：其一，当然是收获了又骚又实用的好网站；其二，学会了git+github的基本使用，常见的git命令也记得很熟；其三，收获了一种精神——永不放弃，哪有什么一帆风顺，加油，骚年！ 不足自己的网站弄的也不是很成熟，还有很多功能没有上线，比如日历、赞赏等，自己没有买域名，只是托管到github上。 欢迎我的个人网站","categories":[{"name":"博客搭建历程","slug":"博客搭建历程","permalink":"http://liuhaotian.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"}],"tags":[{"name":"微信公众号文章——随笔","slug":"微信公众号文章——随笔","permalink":"http://liuhaotian.top/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://liuhaotian.top/categories/CODEFORCES/"},{"name":"LEETCODE/PYTHON","slug":"LEETCODE-PYTHON","permalink":"http://liuhaotian.top/categories/LEETCODE-PYTHON/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/categories/PYTHON/"},{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/categories/C-C-%E5%B8%B8%E7%94%A8API/"},{"name":"LEETCODE周赛","slug":"LEETCODE周赛","permalink":"http://liuhaotian.top/categories/LEETCODE%E5%91%A8%E8%B5%9B/"},{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://liuhaotian.top/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"},{"name":"计算机网络基础","slug":"计算机网络基础","permalink":"http://liuhaotian.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"name":"TRANSLATE","slug":"TRANSLATE","permalink":"http://liuhaotian.top/categories/TRANSLATE/"},{"name":"博客搭建历程","slug":"博客搭建历程","permalink":"http://liuhaotian.top/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"}],"tags":[{"name":"CODEFORCES/div2","slug":"CODEFORCES-div2","permalink":"http://liuhaotian.top/tags/CODEFORCES-div2/"},{"name":"LEETCODE","slug":"LEETCODE","permalink":"http://liuhaotian.top/tags/LEETCODE/"},{"name":"PYTHON","slug":"PYTHON","permalink":"http://liuhaotian.top/tags/PYTHON/"},{"name":"dp","slug":"dp","permalink":"http://liuhaotian.top/tags/dp/"},{"name":"string","slug":"string","permalink":"http://liuhaotian.top/tags/string/"},{"name":"math","slug":"math","permalink":"http://liuhaotian.top/tags/math/"},{"name":"C/C++常用API","slug":"C-C-常用API","permalink":"http://liuhaotian.top/tags/C-C-%E5%B8%B8%E7%94%A8API/"},{"name":"LEETCODE周赛","slug":"LEETCODE周赛","permalink":"http://liuhaotian.top/tags/LEETCODE%E5%91%A8%E8%B5%9B/"},{"name":"ACM","slug":"ACM","permalink":"http://liuhaotian.top/tags/ACM/"},{"name":"sort","slug":"sort","permalink":"http://liuhaotian.top/tags/sort/"},{"name":"window","slug":"window","permalink":"http://liuhaotian.top/tags/window/"},{"name":"ListNode","slug":"ListNode","permalink":"http://liuhaotian.top/tags/ListNode/"},{"name":"hash","slug":"hash","permalink":"http://liuhaotian.top/tags/hash/"},{"name":"计算机网络基础——韩立刚视频总结","slug":"计算机网络基础——韩立刚视频总结","permalink":"http://liuhaotian.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9F%A9%E7%AB%8B%E5%88%9A%E8%A7%86%E9%A2%91%E6%80%BB%E7%BB%93/"},{"name":"acm/math","slug":"acm-math","permalink":"http://liuhaotian.top/tags/acm-math/"},{"name":"CODEFORCES1300","slug":"CODEFORCES1300","permalink":"http://liuhaotian.top/tags/CODEFORCES1300/"},{"name":"acm/greedy","slug":"acm-greedy","permalink":"http://liuhaotian.top/tags/acm-greedy/"},{"name":"CODEFORCES1100","slug":"CODEFORCES1100","permalink":"http://liuhaotian.top/tags/CODEFORCES1100/"},{"name":"TRANSLATE","slug":"TRANSLATE","permalink":"http://liuhaotian.top/tags/TRANSLATE/"},{"name":"CODEFORCES800","slug":"CODEFORCES800","permalink":"http://liuhaotian.top/tags/CODEFORCES800/"},{"name":"微信公众号文章——随笔","slug":"微信公众号文章——随笔","permalink":"http://liuhaotian.top/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94%E9%9A%8F%E7%AC%94/"}]}
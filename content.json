{"meta":{"title":"福江 の いえ","subtitle":"富江江江江","description":"一只孜孜不倦的程序猿，立志把分享变成一种习惯！","author":"Fu JANG","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2020-05-27T09:20:50.000Z","updated":"2020-05-27T10:06:02.559Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"征婚启事我是个普普通通的大一学生，来自普普通通的大学，有着普普通通的生活，不知不觉已经19了，最大的梦想是找个女朋友！ 不过要实现找个妞陪我的梦想好难好难，所以我退而求其次，希望自己未来可以过一个好生活，然后再找个妞，曲线救国哈哈哈。 不过未来想活的好就得有money呀，虽然俗气了一些。但是毕竟贫贱夫妻百事哀嘛，所以为了给将来的老婆买包，我要努力努力努力努力努力努力！！！ 最近想努力奋斗，然后在ACM或者蓝桥杯中拿个好名次，and now自己同时在学习编程知识(后端开发)，不过学业荒废了好久emmmmm… 联系方式热烈欢迎女同学来找我玩儿！！五大三粗并且要请教问题的汉子就不要加了emmmm我怕入坑… QQ： 2235749416 微信： a13019949398 日常热爱超喜欢你的名字、天气之子、大鱼海棠，因为女主都好温柔啊~ 还喜欢听音乐，温柔中带一点点忧郁那种类型，emmmm,当然也喜欢敲代码…还有我超级老实，一个本分的孩子就是我啦! 个人性格也很多愁善感，超级善变，泪点超低。就叨咕这么多啦~ 附图一张"},{"title":"分类","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T04:57:46.858Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T05:16:52.491Z","comments":true,"path":"comments/index.html","permalink":"http://yoursite.com/comments/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T13:39:16.948Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":"想分享友情链接的小伙伴留言即可~"},{"title":"标签","date":"2020-05-26T05:00:55.000Z","updated":"2020-05-27T04:58:17.182Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"音乐","date":"2020-05-27T11:17:35.000Z","updated":"2020-05-27T12:07:16.641Z","comments":false,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":""}],"posts":[{"title":"0x01位运算例题","slug":"0x01位运算例题","date":"2020-05-29T01:00:46.000Z","updated":"2020-05-29T05:49:50.919Z","comments":true,"path":"2020/05/29/0x01位运算例题/","link":"","permalink":"http://yoursite.com/2020/05/29/0x01%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BE%8B%E9%A2%98/","excerpt":"","text":"0x01位运算例题 点击每道题题目即可获取原题链接 a^b分析long long可以表示的最大值为922 3372 0368 5477 5807unsigned long long可以表示的最大值为1844 6744 0737 0955 1615 由此观之a^b大于ULL类型可以表示的最大值，所以要用快速幂的思想来求解这道题。 且取模的性质如下 (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p) % p (a * b) % p = (a % p * b % p) % p a ^ b % p = ((a % p)^b) % p 代码12345678910111213141516#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int power(int a, int b, int c) &#123; int ans &#x3D; 1 % c; for (; b; b &gt;&gt;&#x3D; 1) &#123; if (b &amp; 1) ans &#x3D; (long long)ans * a % c; a &#x3D; (long long)a * a % c; &#125; return ans;&#125;int main() &#123; int a, b, p; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;p); int ans &#x3D; power(a, b, p); printf(&quot;%d&quot;, ans);&#125; 复杂度我们可以用b&amp;1运算表示b的二进制下的最低位，并用b&gt;&gt;1来舍去最低位。在递归的过程中把&gt;&gt;和&amp;结合，其时间复杂度为O(logb) 64位整数乘法代码1234567891011121314151617#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long LL;LL power(LL a, LL b, LL c) &#123; LL ans &#x3D; 0; for (; b; b &gt;&gt;&#x3D; 1) &#123; if (b &amp; 1) ans &#x3D; (ans + a) % c; a &#x3D; a * 2 % c; &#125; return ans;&#125;int main() &#123; LL a, b, p; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p); LL ans &#x3D; power(a, b, p); printf(&quot;%lld&quot;, ans);&#125; 复杂度我们可以用b&amp;1运算表示b的二进制下的最低位，并用b&gt;&gt;1来舍去最低位。在递归的过程中把&gt;&gt;和&amp;结合，其时间复杂度为O(logb)，与上一题不同的是位数问题，但是每次%p之后都能保证不超过2*10^18，在long long的范围内 最短Hamilton路径分析我们可以采用朴素算法,其时间复杂度为O(n*n!)，n!为枚举n个点的全排列，n代表枚举路径的长度求得结果，这个算法的时间复杂度太高，不符合。而我们可以用二进制状态压缩DP来把时间复杂度优化到O((n^2)*(2^n)),我们用F[i,j]表示点被经过的状态对应二进制数i，且目前处于点j的最短路径 在起点时F[1,0]=0，即目前处于点0且只经过了点0的最短路径为0。为方便起见，我们将数组中其他元素设为无穷大，最终目的是求F[(1&lt;&lt;n),n-1]的值，即经过所有点且最终处于n-1的最短路径 在任意时刻，有公式F[i,j]=min(F[i,j],F[i^(1&lt;&lt;j),k]+weight[k,j])，根据分析可得k一定是倒数第二个经过的点。我们枚举k，当k对应在i的二进制为1时，我们讨论这种情况并比较 代码1234567891011121314151617181920212223#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 20, M &#x3D; 1 &lt;&lt; 20;int weight[N][N], F[M][N];int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i &#x3D; 0; i &lt; n; i++) for (int j &#x3D; 0; j &lt; n; j++) scanf(&quot;%d&quot;, &amp;weight[i][j]); memset(F, 0x3f, sizeof F); F[1][0] &#x3D; 0; for (int i &#x3D; 1; i &lt; 1 &lt;&lt; n; i++) for (int j &#x3D; 0; j &lt; n; j++) if (i &gt;&gt; j &amp; 1) for (int k &#x3D; 0; k &lt; n; k++) if ((i ^ 1 &lt;&lt; j) &gt;&gt; k &amp; 1) F[i][j] &#x3D; min(F[i][j], F[i ^ 1 &lt;&lt; j][k] + weight[k][j]); printf(&quot;%d&quot;, F[(1 &lt;&lt; n) - 1][n - 1]);&#125; 还差一题，未完待续","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"CODEFORCES 800 1360A.Minimal Square","slug":"CODEFORCES1360A","date":"2020-05-28T10:07:07.000Z","updated":"2020-05-28T10:45:59.408Z","comments":true,"path":"2020/05/28/CODEFORCES1360A/","link":"","permalink":"http://yoursite.com/2020/05/28/CODEFORCES1360A/","excerpt":"","text":"1360A.Minimal Square原题链接1360A.Minimal Square 题目大意第一行输入测试数目 从第二行开始依次输入每个测试样例的a和b 描述：a代表长，b代表宽，要求输出一个正方形的最小面积，这个正方形把两个相同的长方形(样例输入构成的长方形)覆盖，且这两个长方形不重合，每个长方形的边与正方形平行 解题思路求出长和宽的最小值乘以2，之后将所得的值与长和宽比较得出的最大值作为目标正方形的边长，再输出面积 解题代码1234567891011121314#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int temp &#x3D; min(a, b); int side &#x3D; 2 * temp; int s &#x3D; pow(max(side, max(a, b)), 2); printf(&quot;%d\\n&quot;, s); &#125;&#125;","categories":[{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://yoursite.com/categories/CODEFORCES/"}],"tags":[{"name":"CODEFORCES800","slug":"CODEFORCES800","permalink":"http://yoursite.com/tags/CODEFORCES800/"},{"name":"acm/math","slug":"acm-math","permalink":"http://yoursite.com/tags/acm-math/"}]},{"title":"0x01位运算","slug":"0x01位运算","date":"2020-05-28T04:52:08.000Z","updated":"2020-05-28T09:12:19.550Z","comments":true,"path":"2020/05/28/0x01位运算/","link":"","permalink":"http://yoursite.com/2020/05/28/0x01%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"0x01 位 运 算基础知识 用xor表示异或运算，在m位二进制数中，通常称最低位为0位，从右到左依此类推，最高位为m-1位。 |-1|的原码为00000001|-1|的反码为11111110-1的补码为11111111，十六进制表示为0xff8位二进制对应的最大值127的十六进制表示为0x7f在计算机中数字以其补码的形式保存，正数的补码等于其原码，负数的补码等于其对应正数的原码取反码再+1 对于32位二进制数C(设十进制的值为S)，其按位取反得到的编码~C对应的十进制的值为-1-S(正负都满足此规律) 补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在32位补码下做最高位不进位的二进制加减法运算。发生算术溢出时，32位无符号整数相当于自动对2^32取模，这也解释了有符号整数溢出时为何会出现负数的现象。 在算法竞赛中常用十六进制来表示一个常数，这样书写需要八个字符。 10进制 16进制 21 4748 3647 0x7f ff ff ff 10 6110 9567 0x3f 3f 3f 3f -1 0xff ff ff ff 4个字节的int表示的最大值为21 4748 36474个字节的unsigned int表示的最大值为42 9496 7295 0x3f 3f 3f 3f是一个很有用的值，它满足两个条件：其一，整数的两倍不超过int能表示的最大正整数其二，二进制下每八位都相同因此，我们可以用memset(a, 0x3f, sizeof a)来给a数组的每一个元素都赋值为正无穷，虽然0x7f能给每一个元素赋值成最大，但是为了避免溢出情况，推荐用0x3f。 1 &lt;&lt; n = 2^n, n &lt;&lt; 1 = 2nn &gt;&gt; 1 = n / 2.0 向下取整需要注意的是，整数做/运算执行的是向0取整(-3) &gt;&gt; 1 = -2, (-3) / 2 = -1 除非特殊提示，我们默认右移采用的是算术右移的实现方式 逻辑右移不考虑符号位，右移一位，左边补零即可。 算术右移考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。 所以算术右移也可以进行有符号位的除法,右移n位就等于除2的n次方。 例如，8位二进制数11001101分别右移一位。 逻辑右移就是[0]1100110 算术右移就是[1]1100110 状态压缩二进制状态压缩是指将一个长度为m的bool数组用一个m位二进制整数表示并存储的方法，利用如下操作实现对原bool数组对应下标元素的存取。 取出整数n的第k位：(n&gt;&gt;k)&amp;1 取出整数n的后k位(0到k-1位)：((1&lt;&lt;K)-1)&amp;n 把整数n的第k位反转：(1&lt;&lt;k) nor n 把整数n的第k位赋值为1：(1&lt;&lt;k)|n 把整数n的第k位赋值为0：(~(1&lt;&lt;k))&amp;n 当m不大时，我们可以使用一个整数存储，当m很大时，我们可以用若干个整数存储(int数组)，也可以用C++STL为我们提供的bitset实现。 成对变换通过计算可发现，对于非负整数n: 当n为偶数时，n xor 1 = n + 1 当n为奇数时，n xor 1 = n - 1 因此0与1, 2与3, 4与5 … 关于xor 1运算构成成对变换。 这一性质经常用于图论邻接表中边集的存储。在具有无向边(双向边)的图中把一对正反方向的边分别存储在邻接表数组的第n与n+1位置(其中n为偶数)，就可以通过xor 1的运算获得与当前边(x,y)反向的边(y,x)的存储位置。 lowbit运算lowbit(n)定义为非负整数n在二进制表示下“最低位的1及其后边所有的0”构成的数值。 例子：lowbit(10)=2 其原理为：lowbit(n)=n&amp;(~n-1)=n&amp;(-n) lowbit运算配合Hash可以找出整数二进制下所有是1的位，所花费的时间与1的个数同级。为了达到这个目的，我们只需要不断把n赋值为n-lowbit(n)直至n=0。我们可以把每次减去的数(其一定为2的幂)求log得到对应的1所在的位数，因为C++math.h库中的log函数复杂度常数较大，所以我们可以预处理一个数组，通过Hash的方法代替log运算。 此外lowbit运算也是树状数组中的一个基本运算。","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"HEXO+BUTTERFLY搭建骚气且实用的个人网站","slug":"HEXO-BUTTERFLY搭建骚气且实用的个人网站","date":"2020-05-27T03:01:58.000Z","updated":"2020-05-27T05:39:36.250Z","comments":true,"path":"2020/05/27/HEXO-BUTTERFLY搭建骚气且实用的个人网站/","link":"","permalink":"http://yoursite.com/2020/05/27/HEXO-BUTTERFLY%E6%90%AD%E5%BB%BA%E9%AA%9A%E6%B0%94%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/","excerpt":"","text":"YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS. 引子最近狂刷codeforces，但是逐渐发现自身一个问题，那就是刷过的题虽然在当天感觉很明白，但是隔一天，隔两天，就发现自己再遇到此题时又是一翻鏖战，这就是说明自己做过的题吸收的效率不够高，于是我就打算做一道题总结一道题。那么问题来了，在哪里总结呢？ 首先排除的是微信公众号，众所周知，微信公众号只能是自己分享东西的平台，而在这上面总结知识点就会引出很多问题，其一，每篇文章都要排版，其二，我的粉丝未必合此文章的胃口，其三，每天只能发布一篇文章，大大限制了自己的总结内容与时间分配。 那么诸如csdn、博客园、掘金、知乎这种东西呢？也有很多不方便的地方，比如文章左右侧的广告，实在影响人的心情，此外还有审核等等的制约，思前想后，我决定自己开辟一个个人网站。 当然不能从无到有手动开辟，自己能力有限，而且我的目的也是总结，总不能让自己以后把大把的时间浪费到维护网站上面去。于是我听从了大佬的建议，采用hexo+github的方式，hexo开辟网站，托管到github上面去。 花里胡哨的页面也是最吸引我的原因之一，我采用了butterfly的主题，绝对美炸天！ 过程过程当然是心酸+心酸+心酸，心态险些被搞没。至于搭建网站的教程，实话实说，看了n多篇技术总结，都号称史上最全，到最后还是觉得看官方文档最省事。 当然自己也找到了一些好的文章，在此列出来希望对大家有帮助： hexo安装文章： Hexo+Butterfly+Github+Coding搭建个人博客 hexo官方文档 butterfly主题系列文章： hexo-theme-butterfly 安装文档(一)快速开始 hexo-theme-butterfly 安装文档(二)主题页面 hexo-theme-butterfly 安装文档(三)主题配置 hexo-theme-butterfly 安装文档(四)主题问答、打赏名单 hexo-theme-butterfly 安装文档(五)更新日誌 收益没日没夜的折腾了两天，总能从其中学到什么：其一，当然是收获了又骚又实用的好网站；其二，学会了git+github的基本使用，常见的git命令也记得很熟；其三，收获了一种精神——永不放弃，哪有什么一帆风顺，加油，骚年！ 不足自己的网站弄的也不是很成熟，还有很多功能没有上线，比如日历、赞赏等，自己没有买域名，只是托管到github上。 欢迎我的个人网站","categories":[{"name":"博客搭建历程","slug":"博客搭建历程","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"}],"tags":[{"name":"微信公众号文章——随笔","slug":"微信公众号文章——随笔","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"},{"name":"CODEFORCES","slug":"CODEFORCES","permalink":"http://yoursite.com/categories/CODEFORCES/"},{"name":"博客搭建历程","slug":"博客搭建历程","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"},{"name":"CODEFORCES800","slug":"CODEFORCES800","permalink":"http://yoursite.com/tags/CODEFORCES800/"},{"name":"acm/math","slug":"acm-math","permalink":"http://yoursite.com/tags/acm-math/"},{"name":"微信公众号文章——随笔","slug":"微信公众号文章——随笔","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94%E9%9A%8F%E7%AC%94/"}]}
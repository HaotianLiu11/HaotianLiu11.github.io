<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0x01位运算例题</title>
    <url>/2020/05/29/0x01%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x01位运算例题"><a href="#0x01位运算例题" class="headerlink" title="0x01位运算例题"></a>0x01位运算例题</h1><blockquote>
<p>点击每道题题目即可获取原题链接</p>
</blockquote>
<h2 id="a-b"><a href="#a-b" class="headerlink" title="a^b"></a><a href="https://www.acwing.com/problem/content/91/" target="_blank" rel="noopener">a^b</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>long long</code>可以表示的最大值为<code>922 3372 0368 5477 5807</code><br><code>unsigned long long</code>可以表示的最大值为<code>1844 6744 0737 0955 1615</code>  </p>
<p>由此观之<code>a^b</code>大于<code>ULL</code>类型可以表示的最大值，所以要用快速幂的思想来求解这道题。</p>
<p><img src="https://ae01.alicdn.com/kf/H4fabba6e8a6644e88cb9ee4fe512f4ecH.jpg" alt=""><br>且取模的性质如下</p>
<ul>
<li>(a + b) % p = (a % p + b % p) % p</li>
<li>(a - b) % p = (a % p - b % p) % p </li>
<li>(a <em> b) % p = (a % p </em> b % p) % p </li>
<li>a ^ b % p = ((a % p)^b) % p </li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int power(int a, int b, int c) &#123;</span><br><span class="line">    int ans &#x3D; 1 % c;</span><br><span class="line">    for (; b; b &gt;&gt;&#x3D; 1) &#123;</span><br><span class="line">        if (b &amp; 1) ans &#x3D; (long long)ans * a % c;</span><br><span class="line">        a &#x3D; (long long)a * a % c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a, b, p;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    int ans &#x3D; power(a, b, p);</span><br><span class="line">    printf(&quot;%d&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>我们可以用<code>b&amp;1</code>运算表示<code>b</code>的二进制下的最低位，并用<code>b&gt;&gt;1</code>来舍去最低位。在递归的过程中把<code>&gt;&gt;</code>和<code>&amp;</code>结合，其时间复杂度为<code>O(logb)</code></p>
<h2 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title="64位整数乘法"></a><a href="https://www.acwing.com/problem/content/92/" target="_blank" rel="noopener">64位整数乘法</a></h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL power(LL a, LL b, LL c) &#123;</span><br><span class="line">    LL ans &#x3D; 0;</span><br><span class="line">    for (; b; b &gt;&gt;&#x3D; 1) &#123;</span><br><span class="line">        if (b &amp; 1) ans &#x3D; (ans + a) % c;</span><br><span class="line">        a &#x3D; a * 2 % c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    LL a, b, p;</span><br><span class="line">    scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    LL ans &#x3D; power(a, b, p);</span><br><span class="line">    printf(&quot;%lld&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>我们可以用<code>b&amp;1</code>运算表示<code>b</code>的二进制下的最低位，并用<code>b&gt;&gt;1</code>来舍去最低位。在递归的过程中把<code>&gt;&gt;</code>和<code>&amp;</code>结合，其时间复杂度为<code>O(logb)</code>，与上一题不同的是位数问题，但是每次<code>%p</code>之后都能保证不超过<code>2*10^18</code>，在<code>long long</code>的范围内</p>
<h2 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a><a href="https://www.acwing.com/problem/content/93/" target="_blank" rel="noopener">最短Hamilton路径</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们可以采用朴素算法,其时间复杂度为<code>O(n*n!)</code>，<code>n!</code>为枚举<code>n</code>个点的全排列，<code>n</code>代表枚举路径的长度求得结果，这个算法的时间复杂度太高，不符合。而我们可以用二进制状态压缩<code>DP</code>来把时间复杂度优化到<code>O((n^2)*(2^n))</code>,我们用<code>F[i,j]</code>表示点被经过的状态对应二进制数<code>i</code>，且目前处于点<code>j</code>的最短路径   </p>
<p>在起点时<code>F[1,0]=0</code>，即目前处于点<code>0</code>且只经过了点<code>0</code>的最短路径为<code>0</code>。为方便起见，我们将数组中其他元素设为无穷大，最终目的是求<code>F[(1&lt;&lt;n),n-1]</code>的值，即经过所有点且最终处于<code>n-1</code>的最短路径</p>
<p>在任意时刻，有公式<code>F[i,j]=min(F[i,j],F[i^(1&lt;&lt;j),k]+weight[k,j])</code>，根据分析可得<code>k</code>一定是倒数第二个经过的点。我们枚举<code>k</code>，当<code>k</code>对应在<code>i</code>的二进制为<code>1</code>时，我们讨论这种情况并比较</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N &#x3D; 20, M &#x3D; 1 &lt;&lt; 20;</span><br><span class="line">int weight[N][N], F[M][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;weight[i][j]);</span><br><span class="line"></span><br><span class="line">    memset(F, 0x3f, sizeof F);</span><br><span class="line">    F[1][0] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; 1 &lt;&lt; n; i++)</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">            if (i &gt;&gt; j &amp; 1)</span><br><span class="line">                for (int k &#x3D; 0; k &lt; n; k++)</span><br><span class="line">                    if ((i ^ 1 &lt;&lt; j) &gt;&gt; k &amp; 1)</span><br><span class="line">                        F[i][j] &#x3D; min(F[i][j], F[i ^ 1 &lt;&lt; j][k] + weight[k][j]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;, F[(1 &lt;&lt; n) - 1][n - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还差一题，未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hdd96bb61417945ca90a15b8b5b98b5a1g.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x01位运算</title>
    <url>/2020/05/28/0x01%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x01-位-运-算"><a href="#0x01-位-运-算" class="headerlink" title="0x01 位 运 算"></a>0x01 位 运 算</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>用<code>xor</code>表示异或运算，在<code>m</code>位二进制数中，通常称最低位为<code>0</code>位，从右到左依此类推，最高位为<code>m-1</code>位。</p>
</li>
<li><p><code>|-1|</code>的原码为<code>00000001</code><br><code>|-1|</code>的反码为<code>11111110</code><br><code>-1</code>的补码为<code>11111111</code>，十六进制表示为<code>0xff</code><br><code>8</code>位二进制对应的最大值<code>127</code>的十六进制表示为<code>0x7f</code><br>在计算机中数字以其补码的形式保存，正数的补码等于其原码，负数的补码等于其对应正数的原码取反码再<code>+1</code></p>
</li>
<li><p>对于<code>32</code>位二进制数<code>C</code>(设十进制的值为<code>S</code>)，其按位取反得到的编码<code>~C</code>对应的十进制的值为<code>-1-S</code>(正负都满足此规律)</p>
</li>
<li><p>补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在<code>32</code>位补码下做最高位不进位的二进制加减法运算。发生算术溢出时，<code>32</code>位无符号整数相当于自动对<code>2^32</code>取模，这也解释了有符号整数溢出时为何会出现负数的现象。</p>
</li>
<li><p>在算法竞赛中常用十六进制来表示一个常数，这样书写需要八个字符。<br>| 10进制 | 16进制 |<br>| :-: | :-: |<br>| 21 4748 3647 | 0x7f ff ff ff |<br>| 10 6110 9567 | 0x3f 3f 3f 3f |<br>| -1 | 0xff ff ff ff | </p>
</li>
<li><p><code>4</code>个字节的<code>int</code>表示的最大值为<code>21 4748 3647</code><br><code>4</code>个字节的<code>unsigned int</code>表示的最大值为<code>42 9496 7295</code> </p>
</li>
<li><p><code>0x3f 3f 3f 3f</code>是一个很有用的值，它满足两个条件：<br>其一，整数的两倍不超过int能表示的最大正整数<br>其二，二进制下每八位都相同<br>因此，我们可以用<code>memset(a, 0x3f, sizeof a)</code>来给<code>a</code>数组的每一个元素都赋值为正无穷，虽然<code>0x7f</code>能给每一个元素赋值成最大，但是为了避免溢出情况，推荐用<code>0x3f</code>。</p>
<ol>
<li><code>1 &lt;&lt; n = 2^n, n &lt;&lt; 1 = 2n</code><br><code>n &gt;&gt; 1 = n / 2.0 向下取整</code><br>需要注意的是，整数做<code>/</code>运算执行的是向<code>0</code>取整<br><code>(-3) &gt;&gt; 1 = -2, (-3) / 2 = -1</code></li>
</ol>
</li>
<li><p>除非特殊提示，我们默认右移采用的是算术右移的实现方式</p>
<blockquote>
<p>逻辑右移不考虑符号位，右移一位，左边补零即可。<br> 算术右移考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。<br> 所以算术右移也可以进行有符号位的除法,右移n位就等于除2的n次方。<br> 例如，8位二进制数11001101分别右移一位。<br> 逻辑右移就是[0]1100110<br> 算术右移就是[1]1100110  </p>
</blockquote>
</li>
</ol>
<h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><p>二进制状态压缩是指将一个长度为<code>m</code>的<code>bool</code>数组用一个<code>m</code>位二进制整数表示并存储的方法，利用如下操作实现对原<code>bool</code>数组对应下标元素的存取。  </p>
<ol>
<li>取出整数<code>n</code>的第<code>k</code>位：<code>(n&gt;&gt;k)&amp;1</code></li>
<li>取出整数<code>n</code>的后<code>k</code>位<code>(0到k-1位)</code>：<code>((1&lt;&lt;K)-1)&amp;n</code></li>
<li>把整数<code>n</code>的第<code>k</code>位反转：<code>(1&lt;&lt;k) nor n</code></li>
<li>把整数<code>n</code>的第<code>k</code>位赋值为<code>1</code>：<code>(1&lt;&lt;k)|n</code>  </li>
<li>把整数<code>n</code>的第<code>k</code>位赋值为<code>0</code>：<code>(~(1&lt;&lt;k))&amp;n</code>  </li>
</ol>
<p>当<code>m</code>不大时，我们可以使用一个整数存储，当m很大时，我们可以用若干个整数存储<code>(int数组)</code>，也可以用<code>C++STL</code>为我们提供的<code>bitset</code>实现。</p>
<h2 id="成对变换"><a href="#成对变换" class="headerlink" title="成对变换"></a>成对变换</h2><p>通过计算可发现，对于非负整数<code>n</code>:  </p>
<ol>
<li>当<code>n</code>为偶数时，<code>n xor 1 = n + 1</code></li>
<li>当<code>n</code>为奇数时，<code>n xor 1 = n - 1</code></li>
</ol>
<p>因此<code>0与1</code>, <code>2与3</code>, <code>4与5</code> … 关于<code>xor 1</code>运算构成成对变换。  </p>
<p>这一性质经常用于图论邻接表中边集的存储。在具有无向边(双向边)的图中把一对正反方向的边分别存储在邻接表数组的第<code>n</code>与<code>n+1</code>位置(其中<code>n</code>为偶数)，就可以通过<code>xor 1</code>的运算获得与当前边<code>(x,y)</code>反向的边<code>(y,x)</code>的存储位置。</p>
<h2 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h2><p><code>lowbit(n)</code>定义为非负整数<code>n</code>在二进制表示下“最低位的1及其后边所有的0”构成的数值。  </p>
<p>例子：<code>lowbit(10)=2</code>  </p>
<p>其原理为：<code>lowbit(n)=n&amp;(~n-1)=n&amp;(-n)</code></p>
<p><code>lowbit</code>运算配合<code>Hash</code>可以找出整数二进制下所有是<code>1</code>的位，所花费的时间与<code>1</code>的个数同级。为了达到这个目的，我们只需要不断把<code>n</code>赋值为<code>n-lowbit(n)</code>直至<code>n=0</code>。我们可以把每次减去的数(其一定为2的幂)求<code>log</code>得到对应的<code>1</code>所在的位数，因为<code>C++math.h</code>库中的<code>log</code>函数复杂度常数较大，所以我们可以预处理一个数组，通过<code>Hash</code>的方法代替<code>log</code>运算。  </p>
<p>此外<code>lowbit</code>运算也是树状数组中的一个基本运算。</p>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x02递推与递归</title>
    <url>/2020/05/30/0x02%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x02递推与递归"><a href="#0x02递推与递归" class="headerlink" title="0x02递推与递归"></a>0x02递推与递归</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>一个实际问题的各种可能情况构成的集合通常称为“状态空间”，而程序的运行则是对状态空间的遍历</p>
<p>对于一个待求解的问题，当它局限在某处边界、某个小范围或者某种特殊情况下时，其答案往往是已知的。如果能够将该解答的应用场景扩大到原问题的状态空间，并且扩展过程的每个步骤具有相似性，就可以考虑使用递推或者递归求解</p>
<p>以已知的“问题边界”为起点向“原问题”正向推导的扩展方式就是递推。然而在很多时候，推导的路线难以确定，这时以“原问题”为起点尝试寻找把状态空间缩小到已知的“问题边界”路线，再通过该路线反向回溯的遍历方式就是递归  </p>
<p>使用递推或递归要求“原问题”与“问题边界”之间的每个变换步骤具有相似性，这样我们才能设计一段程序来实现该步骤，将其重复作用于问题之中。换句话说，程序在每个步骤上应该面对相同种类的问题，这些问题都是原问题的一个子问题，可能仅在规模或者某些限制条件上有所区别，并且能够使用“求解原问题的程序”进行求解</p>
<p>对于递归算法，有了上面这个前提，我们就可以让程序在每个变换步骤中执行三个操作：</p>
<ol>
<li>缩小问题状态空间的规模。这意味着程序尝试寻找在“原问题”与“问题边界”之间的变换路线，并向正在探索的路线迈出一步</li>
<li>尝试求解规模缩小以后的问题，结果可能是成功，也可能是失败</li>
<li>如果成功，即找到了规模缩小后的问题的答案，那么将答案扩展到当前问题；如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直至最终确定当前问题无法继续求解</li>
</ol>
<p>以上三个操作有两点特别关键：一是“如何尝试求解规模缩小以后的问题”。因为规模缩小以后的问题是原问题的一个子问题，所以我们可以把它视为一个新的原问题，由相同的程序进行求解，这就是所谓的“<strong>自身调用自身</strong>”；二是如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“<strong>回溯时还原现场</strong>”，关于递归与回溯，举一道简单的例题</p>
<h3 id="LEETCODES1457-二叉树中的伪回文路径"><a href="#LEETCODES1457-二叉树中的伪回文路径" class="headerlink" title="LEETCODES1457. 二叉树中的伪回文路径"></a><a href="https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">LEETCODES1457. 二叉树中的伪回文路径</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">    unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">    int pseudoPalindromicPaths(TreeNode* root) &#123;</span><br><span class="line">        cnt[root-&gt;val]++;</span><br><span class="line">        if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            int t &#x3D; 0;</span><br><span class="line">            for (auto item : cnt)</span><br><span class="line">                if (item.second % 2)</span><br><span class="line">                    t++;</span><br><span class="line">            cnt[root-&gt;val]--;</span><br><span class="line">            return t &lt;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        if (root-&gt;left) res +&#x3D; pseudoPalindromicPaths(root-&gt;left);</span><br><span class="line">        if (root-&gt;right) res +&#x3D; pseudoPalindromicPaths(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        cnt[root-&gt;val]--;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>y总原话：从这道题中我们可以看出<code>回溯时还原现场</code>的要求，每一次<code>return</code>之前都要记得恢复，有两次<code>return</code>，所以两次都要记得恢复。我们要记住一点：如果进来的时候修改了，那么在退出之前就应该恢复  </p>
</blockquote>
<p>重申：如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“<strong>回溯时还原现场</strong>”</p>
<h2 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a>递归总结</h2><p>可以看到，递归程序的基本单元是由“缩小”、“求解”、“扩展”组成的一种变换步骤，只是在“求解”时因为问题的相似性，不断重复使用了这样一种变换步骤，直至在一致的问题边界上直接确定答案。对于其中任意一条从“原问题”到“边界问题”的变换路线，横向来看，它跳的每一层是一次递归程序的执行；纵向来看，它的左右两边分别是寻找路线和沿其推导的流程。为了保证每层的“缩小”与“拓展”能够衔接在同一形式的问题上，“求解”操作自然要保证在执行前后程序面对的问题的状态是相同的，这也就是“还原现场”的必要性所在</p>
<h2 id="递推与递归的简单应用"><a href="#递推与递归的简单应用" class="headerlink" title="递推与递归的简单应用"></a>递推与递归的简单应用</h2><p>在使用枚举算法蛮力探索问题的整个”状态空间“时，经常需要递归。按照规模大小，有如下的几种常见的枚举形式和遍历方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">枚举形式</th>
<th style="text-align:center">状态空间规模</th>
<th style="text-align:center">一般遍历方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">多项式</td>
<td style="text-align:center">n^k k为常数</td>
<td style="text-align:center">循环(for)、递推</td>
</tr>
<tr>
<td style="text-align:center">指数</td>
<td style="text-align:center">k^n k为常数</td>
<td style="text-align:center">递归、位运算</td>
</tr>
<tr>
<td style="text-align:center">排列</td>
<td style="text-align:center">n!</td>
<td style="text-align:center">递归、C++next_permutation</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">C_n^m</td>
<td style="text-align:center">递归+减枝</td>
</tr>
</tbody>
</table>
</div>
<h2 id="递归的机器实现"><a href="#递归的机器实现" class="headerlink" title="递归的机器实现"></a>递归的机器实现</h2><p>一台典型的<code>32</code>位计算机采用“堆栈结构”来实现函数调用，它在汇编语言中，把函数所需的第<code>k</code>个、第<code>k-1</code>个，……，第<code>1</code>个参数依次入栈，然后执行<code>call(address)</code>指令。该指令把返回地址（当前语句的下一条语句地址）入栈，然后跳转到<code>address</code>位置的语句。在函数返回时，它执行<code>ret</code>指令。该指令把返回地址出栈，并跳转到该地址继续执行</p>
<p>对于函数中定义的<code>C++</code>局部变量，在每次执行<code>call</code>与<code>ret</code>指令时，也会在栈中相应的保存与复原，而作用范围超过该函数的变量，以及通过<code>new</code>和<code>malloc</code>函数动态分配的空间则保存在另一块成为<code>堆</code>的结构中。栈指针、返回值、局部的运算会借助<code>CPU</code>的“寄存器”完成</p>
<p>由此我们得知：</p>
<ol>
<li>局部变量在每层递归中都占有一份空间，声明过多或递归过深就会超出”栈“所能存储的范围，造成栈溢出</li>
<li>非局部变量对于各层递归都共享一份空间，需要及时维护、还原现场，以防止在各层递归之间存储和读取的数据相互影响</li>
</ol>
<p>了解了递归的及其实现之后，我们就可以使用模拟的方法，把递归程序改写为非递归程序。具体来说，我们可以用一个数组来模拟栈，使用变量来模拟栈指针和返回值，使用<code>switch/case</code>或者<code>goto/label</code>来模拟语句跳转</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治法把一个问题划分成若干个规模更小的同类子问题，对这些子问题递归求解，然后在回溯时通过它们推导出原问题的解</p>
<p><img src="https://ae01.alicdn.com/kf/H66237f88bb294f1db97200f8cd552ddbd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 800 1360A.Minimal Square</title>
    <url>/2020/05/28/CODEFORCES1360A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360A-Minimal-Square"><a href="#1360A-Minimal-Square" class="headerlink" title="1360A.Minimal Square"></a>1360A.Minimal Square</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="http://codeforces.com/problemset/problem/1360/A" target="_blank" rel="noopener">1360A.Minimal Square</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>从第二行开始依次输入每个测试样例的<code>a</code>和<code>b</code></p>
<p><strong>描述</strong>：<code>a</code>代表长，<code>b</code>代表宽，要求输出一个正方形的最小面积，这个正方形把两个相同的长方形(样例输入构成的长方形)覆盖，且这两个长方形不重合，每个长方形的边与正方形平行</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>求出长和宽的最小值乘以<code>2</code>，之后将所得的值与长和宽比较得出的最大值作为目标正方形的边长，再输出面积</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        int temp &#x3D; min(a, b);</span><br><span class="line">        int side &#x3D; 2 * temp;</span><br><span class="line">        int s &#x3D; pow(max(side, max(a, b)), 2);</span><br><span class="line">        printf(&quot;%d\n&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES800</tag>
        <tag>acm/math</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO+BUTTERFLY搭建骚气且实用的个人网站</title>
    <url>/2020/05/27/HEXO-BUTTERFLY%E6%90%AD%E5%BB%BA%E9%AA%9A%E6%B0%94%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS.</p>
</blockquote>
<hr>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近狂刷<code>codeforces</code>，但是逐渐发现自身一个问题，那就是刷过的题虽然在当天感觉很明白，但是隔一天，隔两天，就发现自己再遇到此题时又是一翻鏖战，这就是说明自己做过的题吸收的效率不够高，于是我就打算做一道题总结一道题。那么问题来了，在哪里总结呢？</p>
<p>首先排除的是微信公众号，众所周知，微信公众号只能是自己分享东西的平台，而在这上面总结知识点就会引出很多问题，其一，每篇文章都要排版，其二，我的粉丝未必合此文章的胃口，其三，每天只能发布一篇文章，大大限制了自己的总结内容与时间分配。</p>
<p>那么诸如<code>csdn</code>、博客园、掘金、知乎这种东西呢？也有很多不方便的地方，比如文章左右侧的广告，实在影响人的心情，此外还有审核等等的制约，思前想后，我决定自己开辟一个个人网站。</p>
<p>当然不能从无到有手动开辟，自己能力有限，而且我的目的也是总结，总不能让自己以后把大把的时间浪费到维护网站上面去。于是我听从了大佬的建议，采用<code>hexo+github</code>的方式，<code>hexo</code>开辟网站，托管到<code>github</code>上面去。</p>
<p>花里胡哨的页面也是最吸引我的原因之一，我采用了<code>butterfly</code>的主题，绝对美炸天！</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程当然是心酸+心酸+心酸，心态险些被搞没。至于搭建网站的教程，实话实说，看了n多篇技术总结，都号称史上最全，到最后还是觉得看官方文档最省事。</p>
<p>当然自己也找到了一些好的文章，在此列出来希望对大家有帮助：</p>
<p><code>hexo</code>安装文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/a1a4ebf0e5fc" target="_blank" rel="noopener">Hexo+Butterfly+Github+Coding搭建个人博客</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="noopener">hexo官方文档</a></li>
</ul>
<p><code>butterfly</code>主题系列文章：</p>
<ol>
<li><a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(一)快速开始</a></li>
<li><a href="https://jerryc.me/posts/dc584b87/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(二)主题页面</a></li>
<li><a href="https://jerryc.me/posts/4aa8abbe/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(三)主题配置</a></li>
<li><a href="https://jerryc.me/posts/98d20436/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(四)主题问答、打赏名单</a></li>
<li><a href="https://jerryc.me/posts/198a4240/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(五)更新日誌</a></li>
</ol>
<h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><p>没日没夜的折腾了两天，总能从其中学到什么：其一，当然是收获了又骚又实用的好网站；其二，学会了<code>git</code>+<code>github</code>的基本使用，常见的<code>git</code>命令也记得很熟；其三，收获了一种精神——永不放弃，哪有什么一帆风顺，加油，骚年！</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>自己的网站弄的也不是很成熟，还有很多功能没有上线，比如日历、赞赏等，自己没有买域名，只是托管到<code>github</code>上。</p>
<h2 id="欢迎"><a href="#欢迎" class="headerlink" title="欢迎"></a>欢迎</h2><p><a href="https://haotianliu11.github.io/" target="_blank" rel="noopener">我的个人网站</a></p>
<hr>
<p><img src="https://imgkr.cn-bj.ufileos.com/148c824d-4eb8-48d3-9825-51625347b0f0.png" alt=""></p>
]]></content>
      <categories>
        <category>博客搭建历程</category>
      </categories>
      <tags>
        <tag>微信公众号文章——随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 800 1360B.Honest Coach</title>
    <url>/2020/05/30/CODEFORCES1360B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360B-Honest-Coach"><a href="#1360B-Honest-Coach" class="headerlink" title="1360B.Honest Coach"></a>1360B.Honest Coach</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/problemset/problem/1360/B?csrf_token=6ef612f8a17a9c506cca94a69af1a61e" target="_blank" rel="noopener">1360B.Honest Coach</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>第二行输入队员个数</p>
<p><strong>描述</strong>：把队员分成两队，每队最少为<code>1</code>人，求<code>abs</code>|第一个队的最大值减去第二个队的最小值|最小</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心的思想，先排序，再贪心</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        vector&lt;int&gt; nums(n);</span><br><span class="line">        for (auto &amp;x : nums) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">		&#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int result &#x3D; 0x3f3f3f3f;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            result &#x3D; min(result, abs(nums[i] - nums[i - 1]));</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES800</tag>
        <tag>acm/greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>API之stringstream用法</title>
    <url>/2020/05/30/API%E4%B9%8Bstringstream%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之stringstream用法"><a href="#API之stringstream用法" class="headerlink" title="API之stringstream用法"></a>API之stringstream用法</h1><p>本文主要介绍 C++ 中 stringstream 类的常见用法。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><code>&lt;sstream&gt;</code>定义了三个类：<code>istringstream</code>、<code>ostringstream</code>和<code>stringstream</code>，分别用来进行流的输入、输出和输入输出操作。本文以<code>stringstream</code>为主，介绍流的输入和输出操作</p>
<p><code>&lt;sstream&gt;</code>主要用来进行数据类型转换，由于<code>&lt;sstream&gt;</code>使用<code>string</code>对象来代替字符数组（<code>snprintf</code>方式），就避免缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符的问题。简单说，相比c库的数据类型转换而言，<code>&lt;sstream&gt;</code>更加安全、自动和直接</p>
<h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h2><h3 id="2-1数据类型转换"><a href="#2-1数据类型转换" class="headerlink" title="2.1数据类型转换"></a>2.1数据类型转换</h3><p>这里展示一个代码示例，该示例介绍了将<code>int</code>类型转换为<code>string</code>类型的过程。示例代码（<code>stringstream_test1.cpp</code>）如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    string strResult;</span><br><span class="line">    int nValue &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将int类型的值放入输入流中</span><br><span class="line">    sstream &lt;&lt; nValue;</span><br><span class="line">    &#x2F;&#x2F; 从sstream中抽取前面插入的int类型的值，赋给string类型</span><br><span class="line">    sstream &gt;&gt; strResult;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;[cout]strResult is: &quot; &lt;&lt; strResult &lt;&lt; endl;</span><br><span class="line">    printf(&quot;[printf]strResult is: %s\n&quot;, strResult.c_str());</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[cout]strResult is: 1000   </span><br><span class="line">[printf]strResult is: 1000</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2多个字符串拼接"><a href="#2-2多个字符串拼接" class="headerlink" title="2.2多个字符串拼接"></a>2.2多个字符串拼接</h3><p>本示例介绍在<code>stringstream</code>中存放多个字符串，实现多个字符串拼接的目的（其实完全可以使用 <code>string</code>类实现），同时，介绍<code>stringstream</code>的清空方法。示例代码（<code>stringstream_test2.cpp</code>）如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将多个字符串放入 sstream 中</span><br><span class="line">    sstream &lt;&lt; &quot;first&quot;</span><br><span class="line">            &lt;&lt; &quot; &quot;</span><br><span class="line">            &lt;&lt; &quot;string,&quot;;</span><br><span class="line">    sstream &lt;&lt; &quot; second string&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 清空 sstream</span><br><span class="line">    sstream.str(&quot;&quot;);</span><br><span class="line">    sstream &lt;&lt; &quot;third string&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;After clear, strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strResult is: first string, second string</span><br><span class="line">After clear, strResult is: third string</span><br></pre></td></tr></table></figure></p>
<p>从上述代码执行结果能够知道：</p>
<ul>
<li>可以使用<code>str()</code>方法，将<code>stringstream</code>类型转换为<code>string</code>类型</li>
<li>可以将多个字符串放入<code>stringstream</code>中，实现字符串的拼接目的</li>
<li>如果想清空<code>stringstream</code>，必须使用<code>sstream.str(&quot;&quot;)</code>; 方式:<code>clear()</code>方法适用于进行多次数据类型转换的场景。详见示例<code>2.3</code></li>
</ul>
<h3 id="2-3stringstream的清空"><a href="#2-3stringstream的清空" class="headerlink" title="2.3stringstream的清空"></a>2.3stringstream的清空</h3><p>清空<code>stringstream</code>有两种方法：<code>clear()</code>方法以及<code>str(&quot;&quot;)</code>方法，这两种方法有不同的使用场景。<code>str(&quot;&quot;)</code>方法的使用场景，在上面的示例中已经介绍了，这里介绍<code>clear()</code>方法的使用场景。示例代码（<code>stringstream_test3.cpp</code>）如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    int first, second;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插入字符串</span><br><span class="line">    sstream &lt;&lt; &quot;456&quot;;</span><br><span class="line">    &#x2F;&#x2F; 转换为int类型</span><br><span class="line">    sstream &gt;&gt; first;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在进行多次类型转换前，必须先运行clear()</span><br><span class="line">    sstream.clear();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插入bool值</span><br><span class="line">    sstream &lt;&lt; true;</span><br><span class="line">    &#x2F;&#x2F; 转换为int类型</span><br><span class="line">    sstream &gt;&gt; second;</span><br><span class="line">    cout &lt;&lt; second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">456</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>注意：在本示例涉及的场景下（多次数据类型转换），必须使用<code>clear()</code>方法清空<code>stringstream</code>，不使用<code>clear()</code>方法或使用<code>str(&quot;&quot;)</code>方法，都不能得到数据类型转换的正确结果。下图分别是未使用<code>clear()</code>方法、使用<code>str(&quot;&quot;)</code>方法时的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">456</span><br><span class="line">4197008</span><br><span class="line"></span><br><span class="line">456</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="2-4测试"><a href="#2-4测试" class="headerlink" title="2.4测试"></a>2.4测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将多个字符串放入 sstream 中</span><br><span class="line">    sstream &lt;&lt; &quot;firstiiii&quot;</span><br><span class="line">            &lt;&lt; &quot; &quot;</span><br><span class="line">            &lt;&lt; &quot;string,&quot;;</span><br><span class="line">    sstream &lt;&lt; &quot; second string&quot;;</span><br><span class="line">    string a, b;</span><br><span class="line">    sstream &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    sstream &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sstream.str();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strResult is: firstiiii</span><br><span class="line">strResult is: string,</span><br><span class="line">firstiiii string, second string</span><br></pre></td></tr></table></figure><br>由此可知，我们可以用它来分割字符串中的单词</p>
<h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h2><p><a href="https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">LEETCODE1455. 检查单词是否为句中其他单词的前缀</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">    int isPrefixOfWord(string sentence, string searchWord) &#123;</span><br><span class="line">        stringstream ssin(sentence);</span><br><span class="line"></span><br><span class="line">        string word;</span><br><span class="line">        for (int i &#x3D; 1; ssin &gt;&gt; word; i++)</span><br><span class="line">            if (word.substr(0, searchWord.size()) &#x3D;&#x3D; searchWord)</span><br><span class="line">                return i;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H0b4d4cb9ed5441f7b122f043b18076c9H.jpg" alt=""></p>
]]></content>
      <categories>
        <category>C/C++常用API</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
</search>

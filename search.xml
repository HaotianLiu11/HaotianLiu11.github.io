<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0x01位运算</title>
    <url>/2020/05/28/0x01%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x01-位-运-算"><a href="#0x01-位-运-算" class="headerlink" title="0x01 位 运 算"></a>0x01 位 运 算</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>用<code>xor</code>表示异或运算，在<code>m</code>位二进制数中，通常称最低位为<code>0</code>位，从右到左依此类推，最高位为<code>m-1</code>位。</p>
</li>
<li><p><code>|-1|</code>的原码为<code>00000001</code><br><code>|-1|</code>的反码为<code>11111110</code><br><code>-1</code>的补码为<code>11111111</code>，十六进制表示为<code>0xff</code><br><code>8</code>位二进制对应的最大值<code>127</code>的十六进制表示为<code>0x7f</code><br>在计算机中数字以其补码的形式保存，正数的补码等于其原码，负数的补码等于其对应正数的原码取反码再<code>+1</code></p>
</li>
<li><p>对于<code>32</code>位二进制数<code>C</code>(设十进制的值为<code>S</code>)，其按位取反得到的编码<code>~C</code>对应的十进制的值为<code>-1-S</code>(正负都满足此规律)</p>
</li>
<li><p>补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在<code>32</code>位补码下做最高位不进位的二进制加减法运算。发生算术溢出时，<code>32</code>位无符号整数相当于自动对<code>2^32</code>取模，这也解释了有符号整数溢出时为何会出现负数的现象。</p>
</li>
<li><p>在算法竞赛中常用十六进制来表示一个常数，这样书写需要八个字符。<br>| 10进制 | 16进制 |<br>| :-: | :-: |<br>| 21 4748 3647 | 0x7f ff ff ff |<br>| 10 6110 9567 | 0x3f 3f 3f 3f |<br>| -1 | 0xff ff ff ff | </p>
</li>
<li><p><code>4</code>个字节的<code>int</code>表示的最大值为<code>21 4748 3647</code><br><code>4</code>个字节的<code>unsigned int</code>表示的最大值为<code>42 9496 7295</code> </p>
</li>
<li><p><code>0x3f 3f 3f 3f</code>是一个很有用的值，它满足两个条件：<br>其一，整数的两倍不超过int能表示的最大正整数<br>其二，二进制下每八位都相同<br>因此，我们可以用<code>memset(a, 0x3f, sizeof a)</code>来给<code>a</code>数组的每一个元素都赋值为正无穷，虽然<code>0x7f</code>能给每一个元素赋值成最大，但是为了避免溢出情况，推荐用<code>0x3f</code>。</p>
<ol>
<li><code>1 &lt;&lt; n = 2^n, n &lt;&lt; 1 = 2n</code><br><code>n &gt;&gt; 1 = n / 2.0 向下取整</code><br>需要注意的是，整数做<code>/</code>运算执行的是向<code>0</code>取整<br><code>(-3) &gt;&gt; 1 = -2, (-3) / 2 = -1</code></li>
</ol>
</li>
<li><p>除非特殊提示，我们默认右移采用的是算术右移的实现方式</p>
<blockquote>
<p>逻辑右移不考虑符号位，右移一位，左边补零即可。<br> 算术右移考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。<br> 所以算术右移也可以进行有符号位的除法,右移n位就等于除2的n次方。<br> 例如，8位二进制数11001101分别右移一位。<br> 逻辑右移就是[0]1100110<br> 算术右移就是[1]1100110  </p>
</blockquote>
</li>
</ol>
<h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><p>二进制状态压缩是指将一个长度为<code>m</code>的<code>bool</code>数组用一个<code>m</code>位二进制整数表示并存储的方法，利用如下操作实现对原<code>bool</code>数组对应下标元素的存取。  </p>
<ol>
<li>取出整数<code>n</code>的第<code>k</code>位：<code>(n&gt;&gt;k)&amp;1</code></li>
<li>取出整数<code>n</code>的后<code>k</code>位<code>(0到k-1位)</code>：<code>((1&lt;&lt;K)-1)&amp;n</code></li>
<li>把整数<code>n</code>的第<code>k</code>位反转：<code>(1&lt;&lt;k) nor n</code></li>
<li>把整数<code>n</code>的第<code>k</code>位赋值为<code>1</code>：<code>(1&lt;&lt;k)|n</code>  </li>
<li>把整数<code>n</code>的第<code>k</code>位赋值为<code>0</code>：<code>(~(1&lt;&lt;k))&amp;n</code>  </li>
</ol>
<p>当<code>m</code>不大时，我们可以使用一个整数存储，当m很大时，我们可以用若干个整数存储<code>(int数组)</code>，也可以用<code>C++STL</code>为我们提供的<code>bitset</code>实现。</p>
<h2 id="成对变换"><a href="#成对变换" class="headerlink" title="成对变换"></a>成对变换</h2><p>通过计算可发现，对于非负整数<code>n</code>:  </p>
<ol>
<li>当<code>n</code>为偶数时，<code>n xor 1 = n + 1</code></li>
<li>当<code>n</code>为奇数时，<code>n xor 1 = n - 1</code></li>
</ol>
<p>因此<code>0与1</code>, <code>2与3</code>, <code>4与5</code> … 关于<code>xor 1</code>运算构成成对变换。  </p>
<p>这一性质经常用于图论邻接表中边集的存储。在具有无向边(双向边)的图中把一对正反方向的边分别存储在邻接表数组的第<code>n</code>与<code>n+1</code>位置(其中<code>n</code>为偶数)，就可以通过<code>xor 1</code>的运算获得与当前边<code>(x,y)</code>反向的边<code>(y,x)</code>的存储位置。</p>
<h2 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h2><p><code>lowbit(n)</code>定义为非负整数<code>n</code>在二进制表示下“最低位的1及其后边所有的0”构成的数值。  </p>
<p>例子：<code>lowbit(10)=2</code>  </p>
<p>其原理为：<code>lowbit(n)=n&amp;(~n-1)=n&amp;(-n)</code></p>
<p><code>lowbit</code>运算配合<code>Hash</code>可以找出整数二进制下所有是<code>1</code>的位，所花费的时间与<code>1</code>的个数同级。为了达到这个目的，我们只需要不断把<code>n</code>赋值为<code>n-lowbit(n)</code>直至<code>n=0</code>。我们可以把每次减去的数(其一定为2的幂)求<code>log</code>得到对应的<code>1</code>所在的位数，因为<code>C++math.h</code>库中的<code>log</code>函数复杂度常数较大，所以我们可以预处理一个数组，通过<code>Hash</code>的方法代替<code>log</code>运算。  </p>
<p>此外<code>lowbit</code>运算也是树状数组中的一个基本运算。</p>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x01位运算例题</title>
    <url>/2020/05/29/0x01%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x01位运算例题"><a href="#0x01位运算例题" class="headerlink" title="0x01位运算例题"></a>0x01位运算例题</h1><blockquote>
<p>点击每道题题目即可获取原题链接</p>
</blockquote>
<h2 id="a-b"><a href="#a-b" class="headerlink" title="a^b"></a><a href="https://www.acwing.com/problem/content/91/" target="_blank" rel="noopener">a^b</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>long long</code>可以表示的最大值为<code>922 3372 0368 5477 5807</code><br><code>unsigned long long</code>可以表示的最大值为<code>1844 6744 0737 0955 1615</code>  </p>
<p>由此观之<code>a^b</code>大于<code>ULL</code>类型可以表示的最大值，所以要用快速幂的思想来求解这道题。</p>
<p><img src="https://ae01.alicdn.com/kf/H4fabba6e8a6644e88cb9ee4fe512f4ecH.jpg" alt=""><br>且取模的性质如下</p>
<ul>
<li>(a + b) % p = (a % p + b % p) % p</li>
<li>(a - b) % p = (a % p - b % p) % p </li>
<li>(a <em> b) % p = (a % p </em> b % p) % p </li>
<li>a ^ b % p = ((a % p)^b) % p </li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> % c;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (<span class="keyword">long</span> <span class="keyword">long</span>)ans * a % c;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    <span class="keyword">int</span> ans = power(a, b, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>我们可以用<code>b&amp;1</code>运算表示<code>b</code>的二进制下的最低位，并用<code>b&gt;&gt;1</code>来舍去最低位。在递归的过程中把<code>&gt;&gt;</code>和<code>&amp;</code>结合，其时间复杂度为<code>O(logb)</code></p>
<h2 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title="64位整数乘法"></a><a href="https://www.acwing.com/problem/content/92/" target="_blank" rel="noopener">64位整数乘法</a></h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">power</span><span class="params">(LL a, LL b, LL c)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans + a) % c;</span><br><span class="line">        a = a * <span class="number">2</span> % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL a, b, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    LL ans = power(a, b, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>我们可以用<code>b&amp;1</code>运算表示<code>b</code>的二进制下的最低位，并用<code>b&gt;&gt;1</code>来舍去最低位。在递归的过程中把<code>&gt;&gt;</code>和<code>&amp;</code>结合，其时间复杂度为<code>O(logb)</code>，与上一题不同的是位数问题，但是每次<code>%p</code>之后都能保证不超过<code>2*10^18</code>，在<code>long long</code>的范围内</p>
<h2 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a><a href="https://www.acwing.com/problem/content/93/" target="_blank" rel="noopener">最短Hamilton路径</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们可以采用朴素算法,其时间复杂度为<code>O(n*n!)</code>，<code>n!</code>为枚举<code>n</code>个点的全排列，<code>n</code>代表枚举路径的长度求得结果，这个算法的时间复杂度太高，不符合。而我们可以用二进制状态压缩<code>DP</code>来把时间复杂度优化到<code>O((n^2)*(2^n))</code>,我们用<code>F[i,j]</code>表示点被经过的状态对应二进制数<code>i</code>，且目前处于点<code>j</code>的最短路径   </p>
<p>在起点时<code>F[1,0]=0</code>，即目前处于点<code>0</code>且只经过了点<code>0</code>的最短路径为<code>0</code>。为方便起见，我们将数组中其他元素设为无穷大，最终目的是求<code>F[(1&lt;&lt;n),n-1]</code>的值，即经过所有点且最终处于<code>n-1</code>的最短路径</p>
<p>在任意时刻，有公式<code>F[i,j]=min(F[i,j],F[i^(1&lt;&lt;j),k]+weight[k,j])</code>，根据分析可得<code>k</code>一定是倒数第二个经过的点。我们枚举<code>k</code>，当<code>k</code>对应在<code>i</code>的二进制为<code>1</code>时，我们讨论这种情况并比较</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> weight[N][N], F[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;weight[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">    F[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="keyword">if</span> ((i ^ <span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        F[i][j] = <span class="built_in">min</span>(F[i][j], F[i ^ <span class="number">1</span> &lt;&lt; j][k] + weight[k][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, F[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还差一题，未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hdd96bb61417945ca90a15b8b5b98b5a1g.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x02递推与递归</title>
    <url>/2020/05/30/0x02%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x02递推与递归"><a href="#0x02递推与递归" class="headerlink" title="0x02递推与递归"></a>0x02递推与递归</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>一个实际问题的各种可能情况构成的集合通常称为“状态空间”，而程序的运行则是对状态空间的遍历</p>
<p>对于一个待求解的问题，当它局限在某处边界、某个小范围或者某种特殊情况下时，其答案往往是已知的。如果能够将该解答的应用场景扩大到原问题的状态空间，并且扩展过程的每个步骤具有相似性，就可以考虑使用递推或者递归求解</p>
<p>以已知的“问题边界”为起点向“原问题”正向推导的扩展方式就是递推。然而在很多时候，推导的路线难以确定，这时以“原问题”为起点尝试寻找把状态空间缩小到已知的“问题边界”路线，再通过该路线反向回溯的遍历方式就是递归  </p>
<p>使用递推或递归要求“原问题”与“问题边界”之间的每个变换步骤具有相似性，这样我们才能设计一段程序来实现该步骤，将其重复作用于问题之中。换句话说，程序在每个步骤上应该面对相同种类的问题，这些问题都是原问题的一个子问题，可能仅在规模或者某些限制条件上有所区别，并且能够使用“求解原问题的程序”进行求解</p>
<p>对于递归算法，有了上面这个前提，我们就可以让程序在每个变换步骤中执行三个操作：</p>
<ol>
<li>缩小问题状态空间的规模。这意味着程序尝试寻找在“原问题”与“问题边界”之间的变换路线，并向正在探索的路线迈出一步</li>
<li>尝试求解规模缩小以后的问题，结果可能是成功，也可能是失败</li>
<li>如果成功，即找到了规模缩小后的问题的答案，那么将答案扩展到当前问题；如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直至最终确定当前问题无法继续求解</li>
</ol>
<p>以上三个操作有两点特别关键：一是“如何尝试求解规模缩小以后的问题”。因为规模缩小以后的问题是原问题的一个子问题，所以我们可以把它视为一个新的原问题，由相同的程序进行求解，这就是所谓的“<strong>自身调用自身</strong>”；二是如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“<strong>回溯时还原现场</strong>”，关于递归与回溯，举一道简单的例题</p>
<h3 id="LEETCODES1457-二叉树中的伪回文路径"><a href="#LEETCODES1457-二叉树中的伪回文路径" class="headerlink" title="LEETCODES1457. 二叉树中的伪回文路径"></a><a href="https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">LEETCODES1457. 二叉树中的伪回文路径</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        cnt[root-&gt;val]++;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> item : cnt)</span><br><span class="line">                <span class="keyword">if</span> (item.second % <span class="number">2</span>)</span><br><span class="line">                    t++;</span><br><span class="line">            cnt[root-&gt;val]--;</span><br><span class="line">            <span class="keyword">return</span> t &lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) res += pseudoPalindromicPaths(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) res += pseudoPalindromicPaths(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        cnt[root-&gt;val]--;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>y总原话：从这道题中我们可以看出<code>回溯时还原现场</code>的要求，每一次<code>return</code>之前都要记得恢复，有两次<code>return</code>，所以两次都要记得恢复。我们要记住一点：如果进来的时候修改了，那么在退出之前就应该恢复  </p>
</blockquote>
<p>重申：如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“<strong>回溯时还原现场</strong>”</p>
<h2 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a>递归总结</h2><p>可以看到，递归程序的基本单元是由“缩小”、“求解”、“扩展”组成的一种变换步骤，只是在“求解”时因为问题的相似性，不断重复使用了这样一种变换步骤，直至在一致的问题边界上直接确定答案。对于其中任意一条从“原问题”到“边界问题”的变换路线，横向来看，它跳的每一层是一次递归程序的执行；纵向来看，它的左右两边分别是寻找路线和沿其推导的流程。为了保证每层的“缩小”与“拓展”能够衔接在同一形式的问题上，“求解”操作自然要保证在执行前后程序面对的问题的状态是相同的，这也就是“还原现场”的必要性所在</p>
<h2 id="递推与递归的简单应用"><a href="#递推与递归的简单应用" class="headerlink" title="递推与递归的简单应用"></a>递推与递归的简单应用</h2><p>在使用枚举算法蛮力探索问题的整个”状态空间“时，经常需要递归。按照规模大小，有如下的几种常见的枚举形式和遍历方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">枚举形式</th>
<th style="text-align:center">状态空间规模</th>
<th style="text-align:center">一般遍历方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">多项式</td>
<td style="text-align:center">n^k k为常数</td>
<td style="text-align:center">循环(for)、递推</td>
</tr>
<tr>
<td style="text-align:center">指数</td>
<td style="text-align:center">k^n k为常数</td>
<td style="text-align:center">递归、位运算</td>
</tr>
<tr>
<td style="text-align:center">排列</td>
<td style="text-align:center">n!</td>
<td style="text-align:center">递归、C++next_permutation</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">C_n^m</td>
<td style="text-align:center">递归+减枝</td>
</tr>
</tbody>
</table>
</div>
<h2 id="递归的机器实现"><a href="#递归的机器实现" class="headerlink" title="递归的机器实现"></a>递归的机器实现</h2><p>一台典型的<code>32</code>位计算机采用“堆栈结构”来实现函数调用，它在汇编语言中，把函数所需的第<code>k</code>个、第<code>k-1</code>个，……，第<code>1</code>个参数依次入栈，然后执行<code>call(address)</code>指令。该指令把返回地址（当前语句的下一条语句地址）入栈，然后跳转到<code>address</code>位置的语句。在函数返回时，它执行<code>ret</code>指令。该指令把返回地址出栈，并跳转到该地址继续执行</p>
<p>对于函数中定义的<code>C++</code>局部变量，在每次执行<code>call</code>与<code>ret</code>指令时，也会在栈中相应的保存与复原，而作用范围超过该函数的变量，以及通过<code>new</code>和<code>malloc</code>函数动态分配的空间则保存在另一块成为<code>堆</code>的结构中。栈指针、返回值、局部的运算会借助<code>CPU</code>的“寄存器”完成</p>
<p>由此我们得知：</p>
<ol>
<li>局部变量在每层递归中都占有一份空间，声明过多或递归过深就会超出”栈“所能存储的范围，造成栈溢出</li>
<li>非局部变量对于各层递归都共享一份空间，需要及时维护、还原现场，以防止在各层递归之间存储和读取的数据相互影响</li>
</ol>
<p>了解了递归的及其实现之后，我们就可以使用模拟的方法，把递归程序改写为非递归程序。具体来说，我们可以用一个数组来模拟栈，使用变量来模拟栈指针和返回值，使用<code>switch/case</code>或者<code>goto/label</code>来模拟语句跳转</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治法把一个问题划分成若干个规模更小的同类子问题，对这些子问题递归求解，然后在回溯时通过它们推导出原问题的解</p>
<p><img src="https://ae01.alicdn.com/kf/H66237f88bb294f1db97200f8cd552ddbd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x11栈</title>
    <url>/2020/06/06/0x11%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x11栈"><a href="#0x11栈" class="headerlink" title="0x11栈"></a>0x11栈</h1><h2 id="ACWING41-包含min函数的栈"><a href="#ACWING41-包含min函数的栈" class="headerlink" title="ACWING41.包含min函数的栈"></a><a href="https://www.acwing.com/problem/content/90/" target="_blank" rel="noopener">ACWING41.包含min函数的栈</a></h2><p>栈结构原本就支持<code>O(1)</code>的入栈、出栈操作，但不支持查询最小值的操作。一个比较直接的思路是，我们知道二叉堆是一种支持插入、取出堆顶、查询最小值的数据结构，如果在维护一个栈的同时再维护一个存储同样元素的二叉堆，就可以支持题目中要求的操作，然而，它的时间复杂度是<code>O(logN)</code>，如果我们只用一个变量记录最小值，当发生出栈操作时，如果最小值恰好被出栈，就无法得知新的最小值是什么。这启发我们使用一个线性结构来保存历史上每个时刻的最小值，这样我们就可以在出栈后进行还原   </p>
<p>我们建立两个栈，栈<code>A</code>存储原本的数据、栈<code>B</code>用单调栈来实现，当我们向栈中压入一个数时，如果该数 ≤ 单调栈的栈顶元素，则将该数同时压入单调栈中；否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数，这样所有操作的时间复杂度都是<code>O(1)</code>    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minvalue;</span><br><span class="line"></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minvalue.empty() || x &lt;= minvalue.top()) minvalue.push(x);</span><br><span class="line">        value.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minvalue.top() == value.top()) minvalue.pop();</span><br><span class="line">        value.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minvalue.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="ACWING128-编辑器"><a href="#ACWING128-编辑器" class="headerlink" title="ACWING128.编辑器"></a><a href="https://www.acwing.com/problem/content/130/" target="_blank" rel="noopener">ACWING128.编辑器</a></h2><p>本题的特殊点在于，<code>I D L R</code>四种操作都在光标位置处发生，并且操作完成后光标至多移动一个位置，根据这种“始终在序列中间某个指定位置进行修改”的性质，我们不难想到一个对顶栈的做法  </p>
<p>建立两个栈，栈<code>L</code>存储从序列开头到当前光标位置的这一段子序列，栈<code>R</code>存储从当前光标位置到序列结尾的这一段子序列，二者都以光标所在的那一端作为栈顶，这两个栈合起来就保存了整个序列。因为查询操作的<code>K</code>不超过光标位置，所以我们用一个动态数组<code>F</code>维护栈<code>L</code>的前缀和最大值即可，通过这两个对顶栈，我们在<code>O(1)</code>的时间内实现了每种操作和询问    </p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N], ll, rr;</span><br><span class="line"><span class="keyword">int</span> f[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    l[++ll] = x;</span><br><span class="line">    sum[ll] = sum[ll - <span class="number">1</span>] + x;</span><br><span class="line">    f[ll] = <span class="built_in">max</span>(f[ll - <span class="number">1</span>], sum[ll]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">char</span> ops[<span class="number">2</span>];</span><br><span class="line">    f[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">if</span> (*ops == <span class="string">'I'</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*ops == <span class="string">'D'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ll) ll--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*ops == <span class="string">'L'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ll) r[++rr] = l[ll--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*ops == <span class="string">'R'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rr) add(r[rr--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; f[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING129-火车进栈"><a href="#ACWING129-火车进栈" class="headerlink" title="ACWING129. 火车进栈"></a><a href="https://www.acwing.com/problem/content/131/" target="_blank" rel="noopener">ACWING129. 火车进栈</a></h2><p>题目要求按字典序输出前<code>20</code>种顺序，我们来看大部分的状态，都可以进行两种操作：第一种，栈顶元素输出；第二种，下一个数字进栈，当我们按照顺序把元素依次进栈时，下一次进栈的元素一定大于栈中的元素和输出的元素，所以为了输出字典序，我们先进行出栈操作，后进行进栈操作，用深搜的过程中，我们需要维护四种<code>state</code>，第一个是输出的元素，第二个是栈中的元素，第三个是未进栈的元素，第四个是已经输出的序列的数量（等于<code>20</code>停止）    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, remain = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!remain) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        remain--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : path) <span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        path.push_back(stk.top());</span><br><span class="line">        stk.pop();</span><br><span class="line">        dfs(u);</span><br><span class="line">        stk.push(path.back());</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        stk.push(u);</span><br><span class="line">        dfs(u + <span class="number">1</span>);</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING130-火车进出栈问题"><a href="#ACWING130-火车进出栈问题" class="headerlink" title="ACWING130.火车进出栈问题"></a><a href="https://www.acwing.com/problem/content/132/" target="_blank" rel="noopener">ACWING130.火车进出栈问题</a></h2><blockquote>
<p>我被这题搞死了，未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hd768bd7dd9b74f66abfafe1c877ce715C.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x06倍增</title>
    <url>/2020/06/03/0x06%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x06倍增"><a href="#0x06倍增" class="headerlink" title="0x06倍增"></a>0x06倍增</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>倍增，字面意思就是“成倍的增长”。这是指我们在进行递推时，如果状态空间很大，通常的线性递推无法满足时间与空间复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间中在<code>2</code>的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过“任意整数可以表示成若干个<code>2</code>的次幂项的和”这一性质 ，使用之前求出的代表值拼成所需的值。所以使用倍增算法也要求我们递推的问题的状态空间关于<code>2</code>的次幂具有可划分性  </p>
<p>“倍增”与“二进制划分”两个思想相互结合，降低了求解很多问题的时间与空间复杂度。我们之前学习的快速幂其实就是“倍增”与“二进制划分”思想的一种体现。在此文章中，我们研究序列上的倍增问题，包括求解<code>RMQ</code>（区间最值）问题的<code>ST</code>算法，关于求解最近公共祖先<code>LCA</code>等在树上的倍增应用，我将在后续文章进行探讨   </p>
<p>试想这样一个问题：给定一个长度为<code>N</code>的数列<code>A</code>，然后进行若干次询问，每次给定一个整数<code>T</code>，求出最大的<code>k</code>，满足数列<code>A</code>中前<code>k</code>个数的和小于等于<code>T</code>。你的算法必须是在线的（必须即时回答每一个询问，不能等待收到所有询问后再统一处理），假设<code>T</code>小于等于数组<code>A</code>中所有数的和  </p>
<p>朴素做法当然是从前向后枚举<code>K</code>，每次询问花费的时间与答案的大小有关，最坏情况为<code>O(N)</code>  </p>
<p>如果我们能够先花费<code>O(N)</code>的时间预处理<code>A</code>数组的前缀和数组<code>S</code>，就可以二分<code>K</code>的位置，比较<code>S[K]</code>与<code>T</code>的大小来确定二分上下界的变化，每次询问花费的时间都是<code>O(logN)</code>。这个算法在平均情况下表现很好，但是它的缺点是如果每次询问给定的整数<code>T</code>都非常小，造成答案<code>K</code>也非常小，那么该算法可能还不如从前往后枚举更优（因为假如每次只怼前<code>3</code>个，此时<code>O(log)</code>的算法可能不如<code>O(3)</code>的好）   </p>
<p>我们可以设计这样一种倍增算法：  </p>
<ol>
<li>令<code>p=1</code>，<code>k=0</code>，<code>sum=0</code>  </li>
<li>比较<code>A</code>数组中<code>k</code>之后的<code>p</code>个数的和与<code>T</code>的关系，也就是说，如果<code>sum+S[k+p]-S[k]&lt;=T</code>，则令<code>sum+=S[k+p]-S[k]</code>，<code>k+=p</code>，<code>p*=2</code>，即累加上<code>p</code>个数的和，然后把<code>p</code>的跨度增长一倍，如果<code>sum+S[k+p]-S[k]&gt;T</code>，则另<code>p/=2</code>  </li>
<li>重复上一步，直至<code>p</code>的值变为<code>0</code>，此时<code>k</code>就是答案  </li>
</ol>
<p>这个算法始终在答案大小的范围内实施“倍增”与“二进制划分”的思想，通过若干长度为<code>2</code>的次幂的区间拼成最后的<code>k</code>，时间复杂度级别为答案的对数，能够应对<code>T</code>的各种大小情况  </p>
<h2 id="ACWING109-天才ACM"><a href="#ACWING109-天才ACM" class="headerlink" title="ACWING109.天才ACM"></a><a href="https://www.acwing.com/problem/content/111/" target="_blank" rel="noopener">ACWING109.天才ACM</a></h2><p>首先，对于一个集合<code>S</code>，显然应该取<code>S</code>中最大的<code>M</code>个数和最小的<code>M</code>个数，最大的和最小的构成一对、次大和次小构成一对…这样求出的校验值最大。而为了让数组<code>A</code>分成的段数最少，每一段都应该在校验值不超过<code>T</code>的情况下，尽量包含更多的数，所以我们从头开始对<code>A</code>进行分段，让每一段尽量长，到达结尾时分成的段数就是答案   </p>
<p>于是，需要解决的问题是：当确定一个左端点<code>L</code>之后，右端点<code>R</code>在满足<code>A[L]到A[R]</code>的校验值不超过<code>T</code>的前提下，最大能取到多少   </p>
<p>求长度为<code>N</code>的一段校验值需要排序配对，时间复杂度为<code>O(NlogN)</code>。当校验值上限<code>T</code>比较小时，如果在整个<code>L到N</code>的区间二分右端点<code>R</code>，二分第一步就要检验<code>(N-L)/2</code>这么长的一段，最终右端点<code>R</code>却可能只扩展了一点儿，浪费了很多时间。与上一道题目一样，我们需要一个与右端点<code>R</code>扩展的长度相适应的算法———倍增   </p>
<p>可以采用与上一题类似的倍增过程：  </p>
<ol>
<li>初始化<code>p=1</code>，<code>R=L</code></li>
<li>求出<code>[L,R+p]</code>这一段区间的校验值，若检验值小于等于<code>T</code>，则<code>R+=P</code>，<code>p*=2</code>，否则<code>P/=2</code>   </li>
<li>重复上一步，直到<code>p</code>的值变为<code>0</code>，此时<code>R</code>即为所求  </li>
</ol>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir(i, a, b) for (int i = a; i &lt;= b; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(a) (a) * (a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                  \</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);              \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p[N], ans, l, r;</span><br><span class="line">ll b[N], a[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid, k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">            b[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b[k++] = a[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid)</span><br><span class="line">        b[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    fir(i, mid, r)</span><br><span class="line">        a[i] = p[i];</span><br><span class="line">    sort(a + mid, a + r + <span class="number">1</span>);</span><br><span class="line">    merge(l, mid, r);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r - l + <span class="number">1</span> &gt;&gt; <span class="number">1</span> &amp;&amp; i &lt;= m; i++)</span><br><span class="line">        sum += sqr(b[r - i + <span class="number">1</span>] - b[l + i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">            a[i] = b[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    l = r = <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    fir(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    l = r = <span class="number">1</span>;</span><br><span class="line">    a[l] = p[l];</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n)</span><br><span class="line">        <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">            ans++;</span><br><span class="line">            l = (++r);</span><br><span class="line">            a[l] = p[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r + len &lt;= n &amp;&amp; check(l, r + <span class="number">1</span>, r + len)) &#123;</span><br><span class="line">            r += len;</span><br><span class="line">            len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == n)</span><br><span class="line">        ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        work();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这题的代码差点儿把我杀死，不写了，未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hef994b8d2de64cc38bd77fc14c753637d.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x07贪心</title>
    <url>/2020/06/02/0x07%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x07贪心"><a href="#0x07贪心" class="headerlink" title="0x07贪心"></a>0x07贪心</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>贪心是一种在每次决策时采取当前意义下最优策略的算法，因此，使用贪心法要求问题的整体最优性可以由局部最优性导出。贪心算法的正确性需要证明，常见的证明手段有：  </p>
<ol>
<li>微扰（邻项交换）<br>证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果的变差，经常用于以“排序”为贪心策略的证明</li>
<li>范围缩放<br>证明任何对局部最优策略作用范围的扩展都不会造成整体结果的变差  </li>
<li>决策包容性<br>证明在任意局面下，做出局部最优策略以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略的可能性包含其他所有策略提供的可能性  </li>
<li>反证法</li>
<li>数学归纳法</li>
</ol>
<blockquote>
<p>我们通过几道例题来介绍贪心算法的应用</p>
</blockquote>
<h2 id="ACWING110-防晒"><a href="#ACWING110-防晒" class="headerlink" title="ACWING110.防晒"></a><a href="https://www.acwing.com/problem/content/112/" target="_blank" rel="noopener">ACWING110.防晒</a></h2><p>按照<code>minSPF</code>递减的顺序把奶牛排序，依次考虑每头奶牛  </p>
<p>对于每头奶牛，扫描一遍所有的防晒霜，在这头奶牛能用（能用指的是该防晒霜的强度符合这头奶牛的范围，并且瓶数还有剩余）的防晒霜里找<code>SPF</code>值最大的使用  </p>
<p>以上算法的贪心策略是在满足条件的前提下每次选择<code>SPF</code>最大的防晒霜，这个策略正确的原因是：我们考虑这一步策略的作用范围扩展到后续其他奶牛之后产生的影响。每瓶防晒霜是否可用，会被<code>minSPF</code>和<code>maxSPF</code>两个条件限制，因为奶牛已经按照<code>minSPF</code>递减排序，所以每一个不低于当前奶牛<code>minSPF</code>值的防晒霜，都不会低于后面其他奶牛的<code>minSPF</code>。也就是说，对于当前奶牛可用的任意两瓶防晒霜<code>x</code>和<code>y</code>，如果<code>SFP[X]&lt;SFP[y]</code>，那么后面的奶牛只可能出现三种情况之一  </p>
<ol>
<li><p><code>x</code>和<code>y</code>都能用<br><img src="https://ae01.alicdn.com/kf/H2cc96d8dff754e51a734da64de4234dd0.jpg" alt=""></p>
</li>
<li><p><code>x</code>和<code>y</code>都不能用<br><img src="https://ae01.alicdn.com/kf/H9ee214eba1ab4d3db7de671fcec790cfN.jpg" alt=""></p>
</li>
<li><p><code>x</code>能用，<code>y</code>不能用<br><img src="https://ae01.alicdn.com/kf/H956b6a5e4b7743629416b5c1c262da0bn.jpg" alt=""></p>
</li>
</ol>
<p>因此当前奶牛选择较大的<code>y</code>去用，对于整体的影响肯定比选择较小的<code>x</code>去用要好，另外，每头奶牛对答案的贡献至多是<code>1</code>，即使让当前奶牛放弃日光浴，留下防晒霜给后面的某一头奶牛去用，对答案的贡献也不会更大，综上所述，尽量满足当前的奶牛，并选择<code>SPF</code>值尽量大的防晒霜是一个正确的贪心策略</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2510</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">PII cows[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; spfs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; cows[i].first &gt;&gt; cows[i].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> spf, cover;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; spf &gt;&gt; cover;</span><br><span class="line">        spfs[spf] += cover;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows, cows + n);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    spfs[<span class="number">0</span>] = spfs[<span class="number">1001</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">auto</span> spf = spfs.upper_bound(cows[i].second);</span><br><span class="line">        spf--;</span><br><span class="line">        <span class="keyword">if</span> (spf-&gt;first &gt;= cows[i].first) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (--spf-&gt;second == <span class="number">0</span>)</span><br><span class="line">                spfs.erase(spf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING111-畜栏预定"><a href="#ACWING111-畜栏预定" class="headerlink" title="ACWING111.畜栏预定"></a><a href="https://www.acwing.com/problem/content/113/" target="_blank" rel="noopener">ACWING111.畜栏预定</a></h2><p>按照开始吃草的时间把牛排序，用小根堆维护所有畜栏中最后一头牛结束吃草的时间的最小值，每循环到一头牛，如果这头牛的吃草开始时间比这个小根堆的堆顶大，则把这个牛插入到这个小根堆堆顶对应的畜栏中，再重新维护小根堆；如果小根堆的堆顶比这头牛的开始吃草时间大，则新建一个畜栏，插入到小根堆中</p>
<p>这种策略成功的原因在于：把每个畜栏的时间都充分利用，如果存在多个畜栏可以存放此牛，则选择最后一头牛结束吃草时间最小的畜栏，这样可以充分利用每个畜栏的时间；把每个牛的开始吃草时间从小到大排序的原因是，这样就可以让后面的牛插入在畜栏的后面，如果不排序，则每个畜栏前面可能有时间空隙放牛，这是不符合要求的，很难做出来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line">pair&lt;PII, <span class="keyword">int</span>&gt; cows[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second;</span><br><span class="line">        cows[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows, cows + n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.empty() || heap.top().first &gt;= cows[i].first.first) &#123;</span><br><span class="line">            id[cows[i].second] = heap.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            heap.push(&#123;cows[i].first.second, heap.<span class="built_in">size</span>() + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> stall = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            stall.first = cows[i].first.second;</span><br><span class="line">            id[cows[i].second] = stall.second;</span><br><span class="line">            heap.push(stall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; heap.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; id[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hef70c4f4a75e40738e47ea16124d9091W.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x04二分</title>
    <url>/2020/05/31/0x04%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x04二分"><a href="#0x04二分" class="headerlink" title="0x04二分"></a>0x04二分</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>二分的基础的用法是在单调序列或单调函数中进行查找，因此当问题的答案具有单调性时，就可以通过二分把求解问题转换为判定（根据复杂度理论，判定的难度小于求解），进一步地，我们还可以扩展到通过三分法去解决单峰函数的极值以及相关问题</p>
<p>对于整数域上的二分，需要注意中止边界、左右区间取舍时的开闭情况，避免漏掉答案或者造成死循环；对于实数域上的二分，需要注意精度问题</p>
<h2 id="整数集合上的二分"><a href="#整数集合上的二分" class="headerlink" title="整数集合上的二分"></a>整数集合上的二分</h2><p>本文章的写法保证最终答案处于闭区间<code>[l,r]</code>以内，循环以<code>l=r</code>结束，每次二分的中间值<code>mid</code>会归属于左半段与右半段二者之一</p>
<p><strong>模板如下</strong>：</p>
<p>在单调递增序列<code>a</code>中查找<code>&gt;=x</code>的数中最小的一个（<code>x</code>或<code>x</code>的后继）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= x) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[l];</span><br></pre></td></tr></table></figure><br>在单调递增序列<code>a</code>中查找<code>&lt;=x</code>的数中最大的一个（<code>x</code>或<code>x</code>的前驱）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt;= x) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[l];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如上面两段代码所示，这种二分写法可能会有两种形式：<br>1.缩小范围时，<code>r=mid</code>， <code>l=mid+1</code>，取中间值时，<code>mid=(l+r)&gt;&gt;1</code><br>2.缩小范围时，<code>l=mid</code>， <code>r=mid-1</code>，取中间值时，<code>mid=(l+r+1)&gt;&gt;1</code><br>如果不对<code>mid</code>的取法加以区分，假如第二段代码也采用<code>mid=(l+r)&gt;&gt;1</code>，那么当<code>r-l</code>等于<code>1</code>时，就有<code>mid=(l+r)&gt;&gt;1=l</code>，接下来若进入<code>l=mid</code>分支，可行区间未缩小，造成死循环；若进入<code>r=mid-1</code>分支，造成<code>l&gt;r</code>，循环不能以<code>l=r</code>结束；相反若<code>mid=(l+r+1)&gt;&gt;1</code> ，则第二段代码则正确得到结果。因此对两个形式采用配套的<code>mid</code>取法是必要的。此外还要注意：我们在二分实现中采用了右移运算符<code>&gt;&gt;1</code>，而不是整数除法<code>/2</code>。这是因为右移运算是向下取整，而整数除法是向<code>0</code>取整，在二分值域包含负数时后者不能正常工作。</p>
</blockquote>
<p><strong>我用一个例题来体现这两个模板的差别</strong>：<br><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">ACWING789.数的范围</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> nums[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= x) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != x) <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt;= x) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出这两个模板的另一个区别：当目标值不止一个时，第一个模板是取到左边，也就是在单调递增序列<code>a</code>中查找<code>&gt;=x</code>的数中最小的一个；第二个模板是取到右边，也就是在单调递增序列<code>a</code>中查找<code>&lt;=x</code>的数中最大的一个；当目标值只有只有一个时，两个模板的结果没有差别  </p>
<p>仔细分析这两种<code>mid</code>的取法，我们还发现：<code>mid=(l+r)&gt;&gt;1</code>不会取到<code>r</code>这个值，<code>mid=(l+r+1)&gt;&gt;1</code>不会取到<code>l</code>这个值，我们可以利用这一性质来处理无解的情况，把最初的二分区间分别扩大为<code>[1,n+1]</code>和<code>[0,n]</code>，把<code>a</code>数组的一个越界下标包含进来。如果最后二分终止于扩大后的这个越界下标上，则说明目标值不在<code>a</code>中；当然我们也可以直接看最终求得的<code>l</code>下标在<code>a</code>数组中对应的值是否为目标值  </p>
<p>二分的终止条件就是<code>l==r</code>，该值就是答案所在位置</p>
<p><code>C++STL</code>的<code>lower_bound</code>和<code>upper_bound</code>函数实现了在一个序列中二分查找某个整数<code>x</code>的后继</p>
<blockquote>
<p>未完待续</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x13链表与邻接表</title>
    <url>/2020/06/11/0x13%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>API之lowerer_bound/upper_bound用法</title>
    <url>/2020/06/02/API%E4%B9%8Blowerer-bound-upper-bound%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之lowerer-bound-upper-bound用法"><a href="#API之lowerer-bound-upper-bound用法" class="headerlink" title="API之lowerer_bound/upper_bound用法"></a>API之lowerer_bound/upper_bound用法</h1><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound()"></a>lower_bound()</h2><p><code>lower_bound(beg, end, val, comp)</code>  </p>
<p><strong>参数</strong>：</p>
<ol>
<li><p>一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是数组的首地址，只是用于比较的“首”地址）</p>
</li>
<li><p>一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）</p>
</li>
<li><p>就是一个要二分查找的那个数</p>
</li>
<li><p><code>greater&lt;int&gt;()</code>代表降序，<code>less&lt;int&gt;()</code>代表升序，默认是升序，也就是数组元素从小到大排列</p>
</li>
</ol>
<p><strong>返回值</strong>:</p>
<p>返回值就是返回第一次出现大于等于那个要查找的数的地址</p>
<p><strong>注意</strong>：</p>
<ol>
<li><p>返回值是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组的数组名，即这个数组的首地址,只有这样才代表那个要查找的数字的下标</p>
</li>
<li><p>那就是要大于等于那个数，等于好理解，大于怎么理解呢，比如说我并没有找到那个数，加入一个的数组里边就有5个数，分别是1,1,1,3,5,而我需要找的那个数就是2，怎么返回呢？就是返回那个第一个大于2的数的地址，就是返回3的地址，那么再有一组数据就是5个数1,1,1,3,3，还是需要找寻2，那么该返回什么呢？那就是第一个3的地址</p>
</li>
</ol>
<p><strong>示例</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k, n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">"的第一个大于等于它的位置在"</span> &lt;&lt; ((lower_bound(a, a + n, k)) - a) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>结果</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 3 3 5 5 5 5 6 </span><br><span class="line">3</span><br><span class="line">3的第一个大于等于它的位置在4</span><br><span class="line">5</span><br><span class="line">5的第一个大于等于它的位置在6</span><br></pre></td></tr></table></figure></p>
<h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound()"></a>upper_bound()</h2><p><code>upper_bound</code>函数的用法<code>lower_bound</code>函数的用法相似，不过这个唯一的不同就是返回的是第一个比我要找的那个数大的数的地址，注意，这里并没有等于，也就是说如果在5个数1,1,2,2,4，里边寻找3，那么就会返回4的地址</p>
<p><strong>示例</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k, n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">"的第一个大于它的位置在"</span> &lt;&lt; ((upper_bound(a, a + n, k)) - a) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>结果</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 3 3 5 5 5 5 6 </span><br><span class="line">5</span><br><span class="line">5的第一个大于它的位置在10</span><br><span class="line">1</span><br><span class="line">1的第一个大于它的位置在4</span><br></pre></td></tr></table></figure></p>
<h2 id="set和map中的upper-bound-lower-bound"><a href="#set和map中的upper-bound-lower-bound" class="headerlink" title="set和map中的upper_bound/lower_bound"></a>set和map中的upper_bound/lower_bound</h2><p>和上述一样的功能，不过其本身<code>class</code>内的放法比调用用外部的<code>upper_bound/lower_bound</code>效率高</p>
<h2 id="灵活使用"><a href="#灵活使用" class="headerlink" title="灵活使用"></a>灵活使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; spfs;</span><br><span class="line"><span class="keyword">auto</span> spf = spfs.upper_bound(cows[i].second);</span><br><span class="line">spf--;</span><br></pre></td></tr></table></figure>
<p>这就实现了找小于等于<code>cows[i].second</code>的数中最大值的功能</p>
]]></content>
      <categories>
        <category>C/C++常用API</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>0x21树与图的遍历</title>
    <url>/2020/06/11/0x21%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>0x16Trie</title>
    <url>/2020/06/07/0x16Trie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x16Trie"><a href="#0x16Trie" class="headerlink" title="0x16Trie"></a>0x16Trie</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><code>Trie</code>（字典树）是一种实现字符串快速检索的多叉树结构。<code>Trie</code>的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符<code>C</code>，就沿着当前节点的<code>C</code>字符指针，走到该指针指向的节点。下面我们来详细讨论<code>Trie</code>的基本操作过程   </p>
<ol>
<li>初始化<br>一棵空<code>Trie</code>仅包含一个根节点，该点的字符指针均指向空</li>
<li>插入<br>当需要插入一个字符串<code>S</code>时，我们令一个指针<code>P</code>起初指向根节点，然后依次扫描<code>S</code>中的每个字符<code>C</code>：<ol>
<li>若<code>P</code>的<code>C</code>字符指针指向一个已经存在的节点<code>Q</code>，则令<code>P=Q</code></li>
<li>若<code>P</code>的<code>C</code>字符指针指向空，则新建一个节点<code>Q</code>，令<code>P</code>的<code>C</code>字符指针指向<code>Q</code>，然后令<code>P=Q</code></li>
<li>当<code>S</code>中的字符扫描完毕时，在当前<code>P</code>节点上标记它是一个字符串的末尾</li>
</ol>
</li>
<li>检索<br>当需要检索一个字符串<code>S</code>在<code>Trie</code>中是否存在时，我们另一个指针<code>P</code>起初指向根节点，然后依次扫描<code>S</code>中的每个字符<code>C</code><ol>
<li>若<code>P</code>的<code>C</code>字符指针指向空，则说明<code>S</code>没有被插入过<code>Trie</code>，结束检索</li>
<li>若<code>P</code>的<code>C</code>字符指针指向一个已经存在的节点<code>Q</code>，则令<code>P=Q</code></li>
<li>当<code>S</code>中的字符串扫描完毕时，若当前节点<code>P</code>被标记为一个字符串的末尾，则说明<code>S</code>在<code>Trie</code>中存在，否则说明<code>S</code>没有被插入过<code>Trie</code></li>
</ol>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H77faad7230a142c39ea039f3c3c79af9Q.jpg" alt=""></p>
<p>在上图所示的例子中，需要插入和检索的字符串都由小写字母构成，所以<code>Trie</code>的每个节点具有<code>26</code>个字符指针，分别为<code>a</code>到<code>z</code>。上图展示了在一棵空树中依次插入<code>cab</code>、<code>cos</code>、<code>car</code>、<code>cat</code>、<code>cate</code>、<code>rain</code>后的<code>Trie</code>形态，绿色标记了单词的末尾节点。可以看出在<code>Trie</code>中，字符数据都体现在树的边（指针）上，树的节点仅保存一些额外信息，例如单词结尾标记等，其空间复杂度是<code>O(NC)</code>，其中<code>N</code>是节点个数，<code>C</code>是字符集的大小  </p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// idx为节点的编号</span></span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING142-前缀统计"><a href="#ACWING142-前缀统计" class="headerlink" title="ACWING142.前缀统计"></a><a href="https://www.acwing.com/problem/content/144/" target="_blank" rel="noopener">ACWING142.前缀统计</a></h2><p>把这<code>N</code>个字符串插入一棵<code>Trie</code>树，<code>Trie</code>树的每个节点上存储一个整数<code>cnt</code>，记录该节点是多少个字符串的末尾节点（为了处理插入重复字符串的情况，这里要记录个数，而不能只做结尾标记），对于每个询问，在<code>Trie</code>树中检索要查询的串的每个子串，在检索的过程中累加每次子串查询得到的<code>cnt</code>值，最后得到最终答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][temp]) son[p][temp] = ++idx;</span><br><span class="line">        p = son[p][temp];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][temp]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][temp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            ans += query(s.substr(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="143-最大异或对"><a href="#143-最大异或对" class="headerlink" title="143.最大异或对"></a><a href="https://www.acwing.com/problem/content/description/145/" target="_blank" rel="noopener">143.最大异或对</a></h2><p>我们首先想到的是朴素算法，暴力的在所有数中枚举两个数使这两个数做<code>XOR</code>运算的值最大，但是由于数据范围过大，这种算法是超时的，所以我们需要考虑其他思路   </p>
<p>朴素的算法是两层嵌套的<code>for</code>循环，我们可以优化朴素算法，借助<code>Trie</code>把第二层<code>for</code>循环从<code>O(N)</code>优化到<code>O(30)</code>，这样其时间复杂度就由<code>O(N*N)</code>变成了<code>O(30*N)</code>    </p>
<p>我们可以把每个整数看作其二进制位数为<code>31</code>的<code>01</code>字符串，当数值较小时在前补<code>0</code>（因为题目要求所有数大于<code>0</code>，而最高位存储的是符号位，所以最高位一定为<code>0</code>，做异或运算无意义，因此为<code>31</code>位），我们把把每个数的二进制串插入到<code>Tire</code>中（其中叶子节点为最低位），接下来假如第一重<code>for</code>循环枚举到<code>Ai</code>，那我们需要找到与<code>Ai</code>对应的整数，使其与<code>Ai</code>做异或运算的值最大，当我们从最高位开始找<code>Ai</code>对应的整数时，因为<code>XOR</code>运算“相同得<code>0</code>，不同得<code>1</code>”的性质，我们每次都希望找到与<code>Ai</code>对应位的相反的数（为<code>0</code>找<code>1</code>，为<code>1</code>找<code>0</code>），这样才能使两个数对应位做异或运算后为<code>1</code>，得到的值才尽可能大，如果“与<code>Ai</code>的当前为相反的字符指针”指向空节点，则只好访问与<code>Ai</code>当前位相同的字符指针，这样就可以找到所有数中和<code>Ai</code>做异或运算值最大的数   </p>
<p><img src="https://ae01.alicdn.com/kf/H75c88544d85c41b6a1c91b076ab0aa19J.jpg" alt=""></p>
<p>这就是这道题的思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">3100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[M][<span class="number">2</span>], a[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (son[p][!u]) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, search(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还差一道题</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hb792fbc57db34e61a8ee7483d8f04dd01.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>API之to_string用法</title>
    <url>/2020/06/04/API%E4%B9%8Bto-string%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之to-string用法"><a href="#API之to-string用法" class="headerlink" title="API之to_string用法"></a>API之to_string用法</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">float</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">double</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>将数值转化为字符串。返回对应的字符串。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> pi = <span class="string">"pi is "</span> + <span class="built_in">std</span>::to_string(<span class="number">3.1415926</span>);</span><br><span class="line">    <span class="built_in">string</span> perfect = to_string(<span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">7</span> + <span class="number">14</span>) + <span class="string">" is a perfect number"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; perfect &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi is 3.141593</span><br><span class="line">28 is a perfect number</span><br></pre></td></tr></table></figure><br><img src="https://ae01.alicdn.com/kf/H0b4d4cb9ed5441f7b122f043b18076c9H.jpg" alt=""></p>
]]></content>
      <categories>
        <category>C/C++常用API</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>API之stringstream用法</title>
    <url>/2020/05/30/API%E4%B9%8Bstringstream%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之stringstream用法"><a href="#API之stringstream用法" class="headerlink" title="API之stringstream用法"></a>API之stringstream用法</h1><p>本文主要介绍 C++ 中 stringstream 类的常见用法。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><code>&lt;sstream&gt;</code>定义了三个类：<code>istringstream</code>、<code>ostringstream</code>和<code>stringstream</code>，分别用来进行流的输入、输出和输入输出操作。本文以<code>stringstream</code>为主，介绍流的输入和输出操作</p>
<p><code>&lt;sstream&gt;</code>主要用来进行数据类型转换，由于<code>&lt;sstream&gt;</code>使用<code>string</code>对象来代替字符数组（<code>snprintf</code>方式），就避免缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符的问题。简单说，相比c库的数据类型转换而言，<code>&lt;sstream&gt;</code>更加安全、自动和直接</p>
<h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h2><h3 id="2-1数据类型转换"><a href="#2-1数据类型转换" class="headerlink" title="2.1数据类型转换"></a>2.1数据类型转换</h3><p>这里展示一个代码示例，该示例介绍了将<code>int</code>类型转换为<code>string</code>类型的过程。示例代码（<code>stringstream_test1.cpp</code>）如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line">    <span class="built_in">string</span> strResult;</span><br><span class="line">    <span class="keyword">int</span> nValue = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将int类型的值放入输入流中</span></span><br><span class="line">    sstream &lt;&lt; nValue;</span><br><span class="line">    <span class="comment">// 从sstream中抽取前面插入的int类型的值，赋给string类型</span></span><br><span class="line">    sstream &gt;&gt; strResult;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[cout]strResult is: "</span> &lt;&lt; strResult &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[printf]strResult is: %s\n"</span>, strResult.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[cout]strResult is: 1000   </span><br><span class="line">[printf]strResult is: 1000</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2多个字符串拼接"><a href="#2-2多个字符串拼接" class="headerlink" title="2.2多个字符串拼接"></a>2.2多个字符串拼接</h3><p>本示例介绍在<code>stringstream</code>中存放多个字符串，实现多个字符串拼接的目的（其实完全可以使用 <code>string</code>类实现），同时，介绍<code>stringstream</code>的清空方法。示例代码（<code>stringstream_test2.cpp</code>）如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">"first"</span></span><br><span class="line">            &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; <span class="string">"string,"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">" second string"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strResult is: "</span> &lt;&lt; sstream.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 sstream</span></span><br><span class="line">    sstream.str(<span class="string">""</span>);</span><br><span class="line">    sstream &lt;&lt; <span class="string">"third string"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After clear, strResult is: "</span> &lt;&lt; sstream.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strResult is: first string, second string</span><br><span class="line">After clear, strResult is: third string</span><br></pre></td></tr></table></figure></p>
<p>从上述代码执行结果能够知道：</p>
<ul>
<li>可以使用<code>str()</code>方法，将<code>stringstream</code>类型转换为<code>string</code>类型</li>
<li>可以将多个字符串放入<code>stringstream</code>中，实现字符串的拼接目的</li>
<li>如果想清空<code>stringstream</code>，必须使用<code>sstream.str(&quot;&quot;)</code>; 方式:<code>clear()</code>方法适用于进行多次数据类型转换的场景。详见示例<code>2.3</code></li>
</ul>
<h3 id="2-3stringstream的清空"><a href="#2-3stringstream的清空" class="headerlink" title="2.3stringstream的清空"></a>2.3stringstream的清空</h3><p>清空<code>stringstream</code>有两种方法：<code>clear()</code>方法以及<code>str(&quot;&quot;)</code>方法，这两种方法有不同的使用场景。<code>str(&quot;&quot;)</code>方法的使用场景，在上面的示例中已经介绍了，这里介绍<code>clear()</code>方法的使用场景。示例代码（<code>stringstream_test3.cpp</code>）如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line">    <span class="keyword">int</span> first, second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符串</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">"456"</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; first;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在进行多次类型转换前，必须先运行clear()</span></span><br><span class="line">    sstream.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入bool值</span></span><br><span class="line">    sstream &lt;&lt; <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; second;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">456</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>注意：在本示例涉及的场景下（多次数据类型转换），必须使用<code>clear()</code>方法清空<code>stringstream</code>，不使用<code>clear()</code>方法或使用<code>str(&quot;&quot;)</code>方法，都不能得到数据类型转换的正确结果。下图分别是未使用<code>clear()</code>方法、使用<code>str(&quot;&quot;)</code>方法时的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">456</span><br><span class="line">4197008</span><br><span class="line"></span><br><span class="line">456</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="2-4测试"><a href="#2-4测试" class="headerlink" title="2.4测试"></a>2.4测试</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">"firstiiii"</span></span><br><span class="line">            &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; <span class="string">"string,"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">" second string"</span>;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    sstream &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strResult is: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sstream &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strResult is: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sstream.str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strResult is: firstiiii</span><br><span class="line">strResult is: string,</span><br><span class="line">firstiiii string, second string</span><br></pre></td></tr></table></figure><br>由此可知，我们可以用它来分割字符串中的单词</p>
<h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h2><p><a href="https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">LEETCODE1455. 检查单词是否为句中其他单词的前缀</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isPrefixOfWord</span><span class="params">(<span class="built_in">string</span> sentence, <span class="built_in">string</span> searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ssin</span><span class="params">(sentence)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ssin &gt;&gt; <span class="keyword">word</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">word</span>.substr(<span class="number">0</span>, searchWord.<span class="built_in">size</span>()) == searchWord)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H0b4d4cb9ed5441f7b122f043b18076c9H.jpg" alt=""></p>
]]></content>
      <categories>
        <category>C/C++常用API</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 800 1360A.Minimal Square</title>
    <url>/2020/05/28/CODEFORCES1360A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360A-Minimal-Square"><a href="#1360A-Minimal-Square" class="headerlink" title="1360A.Minimal Square"></a>1360A.Minimal Square</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="http://codeforces.com/problemset/problem/1360/A" target="_blank" rel="noopener">1360A.Minimal Square</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>从第二行开始依次输入每个测试样例的<code>a</code>和<code>b</code></p>
<p><strong>描述</strong>：<code>a</code>代表长，<code>b</code>代表宽，要求输出一个正方形的最小面积，这个正方形把两个相同的长方形(样例输入构成的长方形)覆盖，且这两个长方形不重合，每个长方形的边与正方形平行</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>求出长和宽的最小值乘以<code>2</code>，之后将所得的值与长和宽比较得出的最大值作为目标正方形的边长，再输出面积</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">min</span>(a, b);</span><br><span class="line">        <span class="keyword">int</span> side = <span class="number">2</span> * temp;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="built_in">pow</span>(<span class="built_in">max</span>(side, <span class="built_in">max</span>(a, b)), <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES800</tag>
        <tag>acm/math</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES/ROUND/647/DIV2</title>
    <url>/2020/06/06/CODEFORCES-ROUND-647-DIV2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CODEFORCES-ROUND-647-DIV2"><a href="#CODEFORCES-ROUND-647-DIV2" class="headerlink" title="CODEFORCES/ROUND/647/DIV2"></a>CODEFORCES/ROUND/647/DIV2</h1><h2 id="A-Johnny-and-Ancient-Computer"><a href="#A-Johnny-and-Ancient-Computer" class="headerlink" title="A.Johnny and Ancient Computer"></a><a href="https://codeforces.com/problemset/problem/1362/A" target="_blank" rel="noopener">A.Johnny and Ancient Computer</a></h2><h3 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h3><p><code>1000</code>，标签：<code>implementation</code>   </p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给一个两个正整数，一个初始值，一个目标值，可以对初始值进行位运算，向左移动三位或两位或一位，或者向右移动三位或一位或两位，要求向右移动时必须除尽，舍弃小数部分的右移运算被禁止，求移动到目标值的最小次数，如果无法得到目标值则输出<code>-1</code>      </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果目标值大于初始值，则左移，反之在可以右移的情况下右移，先移动位数多的，后移动位数小的，移动一次答案加一   </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                  \</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);              \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &gt; b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;&gt; <span class="number">3</span> &gt;= b &amp;&amp; a % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    a = a &gt;&gt; <span class="number">3</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;&gt; <span class="number">2</span> &gt;= b &amp;&amp; a % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    a = a &gt;&gt; <span class="number">2</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;&gt; <span class="number">1</span> &gt;= b &amp;&amp; a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    a = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a == b)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; nums &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt; b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt;&lt; <span class="number">3</span> &lt;= b) &#123;</span><br><span class="line">                    a = a &lt;&lt; <span class="number">3</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a &lt;&lt; <span class="number">2</span> &lt;= b) &#123;</span><br><span class="line">                    a = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a &lt;&lt; <span class="number">1</span> &lt;= b) &#123;</span><br><span class="line">                    a = a &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a == b)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; nums &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Johnny-and-His-Hobbies"><a href="#B-Johnny-and-His-Hobbies" class="headerlink" title="B.Johnny and His Hobbies"></a><a href="https://codeforces.com/problemset/problem/1362/B" target="_blank" rel="noopener">B.Johnny and His Hobbies</a></h2><h3 id="难度-1"><a href="#难度-1" class="headerlink" title="难度"></a>难度</h3><p><code>1200</code>，标签：<code>brute force</code></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给一个集合，里面元素为数字，求一个最小的正整数<code>K</code>，使每个集合的每个元素与<code>K</code>进行<code>XOR</code>运算后集合元素等于原集合元素，意味着集合的元素顺序改变，但元素大小不改变  </p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>取第一个元素，求分别<code>XOR</code>其他元素的<code>K</code>，再对每个元素异或<code>K</code>，看看运算后的集合是否等于原集合，求出最小的<code>K</code>    </p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                  \</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);              \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1500</span>];</span><br><span class="line"><span class="keyword">int</span> aa[<span class="number">1500</span>];</span><br><span class="line"><span class="keyword">int</span> bb[<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(aa, <span class="number">0</span>, <span class="keyword">sizeof</span> aa);</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">            aa[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1025</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j ^ nums[<span class="number">0</span>]) == nums[i]) &#123;</span><br><span class="line">                    tt = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tt != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(bb, <span class="number">0</span>, <span class="keyword">sizeof</span> bb);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a; j++) &#123;</span><br><span class="line">                    bb[nums[j] ^ tt]++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1500</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (aa[k] != bb[k]) flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) ans = <span class="built_in">min</span>(ans, tt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Johnny-and-Another-Rating-Drop"><a href="#C-Johnny-and-Another-Rating-Drop" class="headerlink" title="C.Johnny and Another Rating Drop"></a><a href="https://codeforces.com/problemset/problem/1362/C" target="_blank" rel="noopener">C.Johnny and Another Rating Drop</a></h2><h3 id="难度-2"><a href="#难度-2" class="headerlink" title="难度"></a>难度</h3><p><code>1400</code>，标签：<code>math</code>、<code>dp</code></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数，问从<code>1</code>到此正整数（设为每个数Ki）的二进制形式与前一位（Ki-1）的二进制形式的每位二进制不一样的数量是多少，如果两个二进制位数不同，用<code>0</code>来填充   </p>
<p>假如正整数为<code>5</code></p>
<p>则<code>0</code>到<code>5</code>的二进制分别为：<code>000</code> <code>001</code> <code>010</code> <code>011</code> <code>100</code> <code>101</code><br><code>000</code>和<code>001</code>不同的位为最低位，数量为<code>1</code><br>所以从<code>1</code>到<code>5</code>分别为：<code>1</code> <code>2</code> <code>1</code> <code>3</code> <code>1</code>，总共为<code>8</code>  </p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>两种思路：第一种找规律，第二种数位<code>dp</code>   </p>
<p>思路<code>1</code>：可以发现最低位二进制一直是<code>01</code>变化，所以其贡献是<code>n</code>，倒数第二位，同理可推出贡献为<code>n/2</code>，所以推到二进制第<code>i</code>位，贡献是<code>n&lt;&lt;(i−1)</code>   ，累加就可以了   </p>
<p>思路<code>2</code>：打开<code>OEIS</code>，输入数列，求出<code>DP</code>公式，递归即可，香   </p>
<p>这里给出思路<code>1</code>的代码  </p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                  \</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);              \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = num;</span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            ans += temp / i;</span><br><span class="line">            i *= <span class="number">2</span>;</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Johnny-and-Contribution"><a href="#D-Johnny-and-Contribution" class="headerlink" title="D.Johnny and Contribution"></a><a href="https://codeforces.com/problemset/problem/1361/A" target="_blank" rel="noopener">D.Johnny and Contribution</a></h2><h3 id="难度-3"><a href="#难度-3" class="headerlink" title="难度"></a>难度</h3><p><code>1700</code>，标签：<code>greedy</code>，<code>constructive algorithms</code>    </p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有个傻逼想写博客，每个文章一个主题，一个主题可以被多个文章写，文章之间可以互相引用，但是互相引用的文章的主题不能相同   </p>
<p>这个傻逼写博客有个毛病，写文章时，选择的主题序号要最小，比如一个文章的引用文章的主题为<code>1</code>和<code>3</code>，那么此逼在写这个文章时用的主题序号为<code>2</code>  </p>
<p>假设给定文章数目<code>N</code>，从<code>1</code>到<code>N</code>的文章的主题规定为一个序列，现在这个逼从头写文章，问他写文章的次序，如果文章的主题不能达到此序列，输出<code>-1</code>   </p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>转化为一个图，每个文章为一个节点，文章间的引用当作节点之间的边，主题当作节点的权值  </p>
<p>先把所有边记录下来，然后把最后要得到的图的节点按照权值从小到大排序，之后按照节点权值选择先填的节点，在填充节点的过程中，如果此节点填充的值为<code>M</code>，则它的相连节点（且已被填充）的个数必须为<code>M-1</code>，且相连的节点（已填充）的权值必须是从<code>1</code>到<code>M-1</code>，如果不满足则输出<code>-1</code>，最后输出填充的顺序   </p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forn(i, n) for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for1(i, n) for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                      \</span></span><br><span class="line">    ios::sync_with_stdio(flase); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);                  \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">8e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], p[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x] &lt; a[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    forn(i, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        e[u].push_back(v);</span><br><span class="line">        e[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    for1(i, n) <span class="built_in">cin</span> &gt;&gt; a[i], p[i] = i;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line">    for1(i, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = p[i];</span><br><span class="line">        <span class="keyword">int</span> val = a[u];</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u])</span><br><span class="line">            <span class="keyword">if</span> (ans[v]) s.insert(ans[v]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != val - <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x != cnt) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[u] = a[u];</span><br><span class="line">    &#125;</span><br><span class="line">    for1(i, n) <span class="built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Johnny-and-Grandmaster"><a href="#E-Johnny-and-Grandmaster" class="headerlink" title="E.Johnny and Grandmaster"></a><a href="https://codeforces.com/problemset/problem/1361/B" target="_blank" rel="noopener">E.Johnny and Grandmaster</a></h2><h3 id="难度-4"><a href="#难度-4" class="headerlink" title="难度"></a>难度</h3><p><code>1900</code>，标签：<code>greedy</code></p>
<h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给两个数<code>N</code>和<code>P</code>，输入<code>N</code>个数，把<code>N</code>个数分为两个集合，以<code>P</code>为底，把每个集合的元素作为幂次，把集合的每个元素作为幂次算出来的值相加和为S，求出两个集合的S的差值最小为多少   </p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>思路<code>1</code>：从大到小枚举<code>p^k</code>，拿一个变量<code>cur</code>记录当前的枚举数字的幂次，<code>dif</code>记录当前集合中的数字的大小是当前枚举的数字的倍数，<code>ans</code>记录最终的值。枚举新一轮的时候，当<code>dif==0</code>的时候说明集合中的所有数字被抵消了或者循环刚开始，那么<code>cur</code>直接等于此次循环枚举数字的幂次即可，<code>ans</code>也直接等于当前的数字的值模<code>mod</code>即可。如果<code>dif!=0</code>说明当前集合不为<code>0</code>，我们就让集合中的数字减去当前枚举的数字，可以考虑把<code>cur</code>先化为跟当前枚举数字的幂次相同，这样<code>dif</code>就会不断乘底数<code>p</code>，如果<code>dif</code>变得大于<code>1e6</code>(也可以精确点写成<code>i</code>),说明当前集合中的数字已经是当前枚举数字的至少<code>1e6</code>倍大，那么就没必要接着枚举了，因为<code>N</code>的长度最大才是<code>1e6</code>，直接减去后面所有的数字即可，因为即使减去了后面所有的数字也一定还有剩余。如果小于<code>1e6</code>，就让<code>dif--</code>（减去当前枚举的这个数字后倍数自然会减一），计算幂时我们用到了快速幂的思想    </p>
<p>思路<code>2</code>：开双模数，有一定几率倍卡，但是概率太小忽略不计。首先知道一点，集合中的数字不可能减少为负数。那么每次减少一个数，看两个答案<code>ans1</code>，<code>ans2</code>是否同为<code>0</code>，同为<code>0</code>说明集合中的值被减少为<code>0</code>，然后就加上下一个枚举的数字，然后继续减后面的数字，重复这个过程，最后输出<code>ans1</code>就行了。<code>ans1</code>和<code>ans2</code>是按照不同的模数来算的，<code>ans1</code>的模数是题目要求的模数，<code>ans2</code>的模数是自己随便定的大模数</p>
<p>这里给出思路<code>1</code>的代码  </p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * c % P;</span><br><span class="line">        c = c * c % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (n &amp; <span class="number">1L</span>L) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        <span class="keyword">int</span> dif = <span class="number">0</span>, cur = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dif) &#123;</span><br><span class="line">                cur = a[i];</span><br><span class="line">                dif = <span class="number">1</span>;</span><br><span class="line">                ans += qpow(p, a[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (cur &gt; a[i]) &#123;</span><br><span class="line">                    cur --;</span><br><span class="line">                    dif *= p;</span><br><span class="line">                    <span class="keyword">if</span> (dif &gt; i) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur == a[i]) &#123;</span><br><span class="line">                    dif --;</span><br><span class="line">                    ans -= qpow(p, a[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                        ans -= qpow(p, a[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans % P + P) % P;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Johnny-and-Megan’s-Necklace"><a href="#F-Johnny-and-Megan’s-Necklace" class="headerlink" title="F.Johnny and Megan’s Necklace"></a><a href="https://codeforces.com/contest/1362/problem/F" target="_blank" rel="noopener">F.Johnny and Megan’s Necklace</a></h2><h3 id="难度-5"><a href="#难度-5" class="headerlink" title="难度"></a>难度</h3><p><code>2500</code>，标签：<code>dfs and similar</code></p>
<blockquote>
<p>未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/H0ba75266cb0440beb2cf8772fb0034c9O.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES/div2</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 800 1360B.Honest Coach</title>
    <url>/2020/05/30/CODEFORCES1360B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360B-Honest-Coach"><a href="#1360B-Honest-Coach" class="headerlink" title="1360B.Honest Coach"></a>1360B.Honest Coach</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/problemset/problem/1360/B?csrf_token=6ef612f8a17a9c506cca94a69af1a61e" target="_blank" rel="noopener">1360B.Honest Coach</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>第二行输入队员个数</p>
<p><strong>描述</strong>：把队员分成两队，每队最少为<code>1</code>人，求<code>abs</code>|第一个队的最大值减去第二个队的最小值|最小</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心的思想，先排序，再贪心</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : nums) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        &#125;</span><br><span class="line">		    </span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            result = <span class="built_in">min</span>(result, <span class="built_in">abs</span>(nums[i] - nums[i - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES800</tag>
        <tag>acm/greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 1100 1360C.Similar Pairs</title>
    <url>/2020/05/31/CODEFORCES1360C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360C-Similar-Pairs"><a href="#1360C-Similar-Pairs" class="headerlink" title="1360C.Similar Pairs"></a>1360C.Similar Pairs</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/problemset/problem/1360/C" target="_blank" rel="noopener">1360C.Similar Pairs</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>之后每两行为一组测试：  </p>
<p>第二行输入每组测试的元素个数  </p>
<p>第三行输入每组的元素  </p>
<p><strong>描述</strong>：当两个数奇偶相同或者绝对值相差<code>1</code>则称这两个数为<code>1</code>组，每次测试给你偶数个数，问所有元素是否有与它配对的数</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为一共有偶数个数，所以当奇数元素个数为偶数时，偶数元素个数也一定为偶数，则一定可以两两配对；如果奇数元素个数和偶数元素个数都为奇数时，检查是否存在一个奇数和一个偶数相减的绝对值为<code>1</code>的情况，如果存在这种情况，则一定可以两两配对，如果不存在，则不能两两配对</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[i] % <span class="number">2</span>)</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(nums, nums+n);</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(nums[i] - nums[i - <span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>acm/greedy</tag>
        <tag>CODEFORCES1100</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 1300 1360D.Buying Shovels</title>
    <url>/2020/05/31/CODEFORCES1360D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360D-Buying-Shovels"><a href="#1360D-Buying-Shovels" class="headerlink" title="1360D.Buying Shovels"></a>1360D.Buying Shovels</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/problemset/problem/1360/D" target="_blank" rel="noopener">1360D.Buying Shovels</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>之后每一行为一组测试：  </p>
<p>每组测试输入两个数：<code>n</code>和<code>k</code></p>
<p><strong>描述</strong>：有<code>k</code>种包裹，第<code>i</code>个包裹里有<code>i</code>个铲子，只能选择一种包裹，可选这个包裹无限次，要求选择的包裹数最少，并且铲子和等于<code>n</code></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据数据范围可以看出是求质数问题，求<code>n</code>中的质数，要求此质数在<code>k</code>的范围内，<code>n/此质数</code>最小，意思就是选最大的可以除尽的包裹，得到的就是选择包裹数最少</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= k)</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, n / i);</span><br><span class="line">                <span class="keyword">if</span> (n / i &lt;= k)</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>acm/math</tag>
        <tag>CODEFORCES1300</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点</title>
    <url>/2020/06/04/PYTHON%E4%B8%ADisdigit-%E3%80%81isalpha-%E3%80%81isalnum-%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点"><a href="#PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点" class="headerlink" title="PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点"></a>PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点</h1><h2 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit()"></a>isdigit()</h2><p><code>python</code>关于<code>isdigit()</code>内置函数的官方定义：  </p>
<blockquote>
<p>S.isdigit() -&gt; bool<br>        Return True if all characters in S are digits<br>        and there is at least one character in S, False otherwise.    </p>
</blockquote>
<p>翻译：</p>
<p><code>S.isdigit()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>字符串中至少有一个字符且如果<code>S</code>中的所有字符都是数字，那么返回结果就是<code>True</code>；否则，就返回<code>False</code>   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S1 = <span class="string">'12345'</span>       <span class="comment">#纯数字</span></span><br><span class="line">S2 = <span class="string">'①②'</span>          <span class="comment">#带圈的数字</span></span><br><span class="line">S3 = <span class="string">'汉字'</span>        <span class="comment">#汉字</span></span><br><span class="line">S4 = <span class="string">'%#￥'</span>        <span class="comment">#特殊符号</span></span><br><span class="line">S5 = <span class="string">'12345a'</span>      <span class="comment">#数字和字母</span></span><br><span class="line"></span><br><span class="line">print(S1.isdigit())</span><br><span class="line">print(S2.isdigit())</span><br><span class="line">print(S3.isdigit())</span><br><span class="line">print(S4.isdigit())</span><br><span class="line">print(S5.isdigit())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果：</span></span><br><span class="line"><span class="literal">True</span>     </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="isalpha"><a href="#isalpha" class="headerlink" title="isalpha()"></a>isalpha()</h2><p><code>python</code>关于<code>isalpha()</code>内置函数的官方定义：</p>
<blockquote>
<p>S.isalpha() -&gt; bool<br>        Return True if all characters in S are alphabetic<br>        and there is at least one character in S, False otherwise.</p>
</blockquote>
<p>翻译：<br><code>S.isalpha()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>字符串中至少有一个字符且如果S中的所有字符都是字母，那么返回结果就是<code>True</code>；否则，就返回<code>False</code>   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S1 = <span class="string">'abc汉字'</span>     <span class="comment">#汉字+字母</span></span><br><span class="line">S2 = <span class="string">'ab字134'</span>     <span class="comment">#包含数字</span></span><br><span class="line">S3 = <span class="string">'*&amp;&amp;'</span>         <span class="comment">#特殊符号</span></span><br><span class="line"></span><br><span class="line">print(S1.isalpha())</span><br><span class="line">print(S2.isalpha())</span><br><span class="line">print(S3.isalpha())</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum()"></a>isalnum()</h2><p><code>python</code>关于<code>isalnum()</code>内置函数的官方定义：  </p>
<blockquote>
<p>S.isalnum() -&gt; bool<br>        Return True if all characters in S are alphanumeric<br>        and there is at least one character in S, False otherwise.</p>
</blockquote>
<p>翻译：  </p>
<p><code>S.isalnum()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>中至少有一个字符且如果<code>S</code>中的所有字符都是字母数字，那么返回结果就是<code>True</code>；否则，就返回<code>False</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S1 = <span class="string">'abc汉字1'</span>    <span class="comment">#字母+汉字+数字</span></span><br><span class="line">S2 = <span class="string">'①②③'</span>      <span class="comment">#带圈的数字</span></span><br><span class="line">S3 = <span class="string">'%……&amp;'</span>       <span class="comment">#特殊符号</span></span><br><span class="line"></span><br><span class="line">print(S1.isalnum())</span><br><span class="line">print(S2.isalnum())</span><br><span class="line">print(S3.isalnum())</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p><code>python</code>官方定义中的字母：大家默认为英文字母+汉字即可</p>
</li>
<li><p><code>python</code>官方定义中的数字：大家默认为<code>Unicode</code>数字、<code>byte</code>数字（单字节）、全角数字（双字节）、罗马数字、带圈的数字即可</p>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE双周赛26</title>
    <url>/2020/06/04/LEETCODE%E5%8F%8C%E5%91%A8%E8%B5%9B26/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="LEETCODE双周赛26"><a href="#LEETCODE双周赛26" class="headerlink" title="LEETCODE双周赛26"></a>LEETCODE双周赛26</h1><h2 id="1446-连续字符"><a href="#1446-连续字符" class="headerlink" title="1446.连续字符"></a><a href="https://leetcode-cn.com/problems/consecutive-characters/submissions/" target="_blank" rel="noopener">1446.连续字符</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>双指针（滑动窗口）</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPower</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == s[j]) j++;</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, j - i);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;            </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1447-最简分数"><a href="#1447-最简分数" class="headerlink" title="1447.最简分数"></a><a href="https://leetcode-cn.com/problems/simplified-fractions/" target="_blank" rel="noopener">1447.最简分数</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>gcd+遍历</p>
</blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y ? gcd(y, x % y) : x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">simplifiedFractions</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gcd(j, i) == <span class="number">1</span>)</span><br><span class="line">                    result.push_back(to_string(i) + <span class="string">"/"</span> + to_string(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448.统计二叉树中好节点的数目"></a><a href="https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">1448.统计二叉树中好节点的数目</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>简简单单的dfs，记录遍历的节点的最大值</p>
</blockquote>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> maxn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = maxn &lt;= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) ans += dfs(root-&gt;left, <span class="built_in">max</span>(maxn, root-&gt;val));</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) ans += dfs(root-&gt;right, <span class="built_in">max</span>(maxn, root-&gt;val));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1449-数位成本和为目标值的最大数字"><a href="#1449-数位成本和为目标值的最大数字" class="headerlink" title="1449.数位成本和为目标值的最大数字"></a><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">1449.数位成本和为目标值的最大数字</a></h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>完全背包</p>
</blockquote>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) f[<span class="number">0</span>][i] = <span class="number">-1e8</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cost[i - <span class="number">1</span>]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - cost[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">9</span>][target] &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>, j = target; i; i--)</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= cost[i - <span class="number">1</span>] &amp;&amp; f[i][j] == f[i][j - cost[i - <span class="number">1</span>]] + <span class="number">1</span>) &#123;</span><br><span class="line">                res += to_string(i);</span><br><span class="line">                j -= cost[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hdd96bb61417945ca90a15b8b5b98b5a1g.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE周赛</category>
      </categories>
      <tags>
        <tag>LEETCODE周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO+BUTTERFLY搭建骚气且实用的个人网站</title>
    <url>/2020/05/27/HEXO-BUTTERFLY%E6%90%AD%E5%BB%BA%E9%AA%9A%E6%B0%94%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS.</p>
</blockquote>
<hr>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近狂刷<code>codeforces</code>，但是逐渐发现自身一个问题，那就是刷过的题虽然在当天感觉很明白，但是隔一天，隔两天，就发现自己再遇到此题时又是一翻鏖战，这就是说明自己做过的题吸收的效率不够高，于是我就打算做一道题总结一道题。那么问题来了，在哪里总结呢？</p>
<p>首先排除的是微信公众号，众所周知，微信公众号只能是自己分享东西的平台，而在这上面总结知识点就会引出很多问题，其一，每篇文章都要排版，其二，我的粉丝未必合此文章的胃口，其三，每天只能发布一篇文章，大大限制了自己的总结内容与时间分配。</p>
<p>那么诸如<code>csdn</code>、博客园、掘金、知乎这种东西呢？也有很多不方便的地方，比如文章左右侧的广告，实在影响人的心情，此外还有审核等等的制约，思前想后，我决定自己开辟一个个人网站。</p>
<p>当然不能从无到有手动开辟，自己能力有限，而且我的目的也是总结，总不能让自己以后把大把的时间浪费到维护网站上面去。于是我听从了大佬的建议，采用<code>hexo+github</code>的方式，<code>hexo</code>开辟网站，托管到<code>github</code>上面去。</p>
<p>花里胡哨的页面也是最吸引我的原因之一，我采用了<code>butterfly</code>的主题，绝对美炸天！</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程当然是心酸+心酸+心酸，心态险些被搞没。至于搭建网站的教程，实话实说，看了n多篇技术总结，都号称史上最全，到最后还是觉得看官方文档最省事。</p>
<p>当然自己也找到了一些好的文章，在此列出来希望对大家有帮助：</p>
<p><code>hexo</code>安装文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/a1a4ebf0e5fc" target="_blank" rel="noopener">Hexo+Butterfly+Github+Coding搭建个人博客</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="noopener">hexo官方文档</a></li>
</ul>
<p><code>butterfly</code>主题系列文章：</p>
<ol>
<li><a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(一)快速开始</a></li>
<li><a href="https://jerryc.me/posts/dc584b87/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(二)主题页面</a></li>
<li><a href="https://jerryc.me/posts/4aa8abbe/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(三)主题配置</a></li>
<li><a href="https://jerryc.me/posts/98d20436/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(四)主题问答、打赏名单</a></li>
<li><a href="https://jerryc.me/posts/198a4240/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(五)更新日誌</a></li>
</ol>
<h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><p>没日没夜的折腾了两天，总能从其中学到什么：其一，当然是收获了又骚又实用的好网站；其二，学会了<code>git</code>+<code>github</code>的基本使用，常见的<code>git</code>命令也记得很熟；其三，收获了一种精神——永不放弃，哪有什么一帆风顺，加油，骚年！</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>自己的网站弄的也不是很成熟，还有很多功能没有上线，比如日历、赞赏等，自己没有买域名，只是托管到<code>github</code>上。</p>
<h2 id="欢迎"><a href="#欢迎" class="headerlink" title="欢迎"></a>欢迎</h2><p><a href="https://haotianliu11.github.io/" target="_blank" rel="noopener">我的个人网站</a></p>
<hr>
<p><img src="https://imgkr.cn-bj.ufileos.com/148c824d-4eb8-48d3-9825-51625347b0f0.png" alt=""></p>
]]></content>
      <categories>
        <category>博客搭建历程</category>
      </categories>
      <tags>
        <tag>微信公众号文章——随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中join函数的用法</title>
    <url>/2020/06/04/PYTHON%E4%B8%ADjoin%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中join函数的用法"><a href="#PYTHON中join函数的用法" class="headerlink" title="PYTHON中join函数的用法"></a>PYTHON中join函数的用法</h1><p>Python中有<code>.join()</code>和<code>os.path.join()</code>两个函数，具体作用如下：  </p>
<p><code>.join()</code>：连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串<br><code>os.path.join()</code>：将多个路径组合后返回</p>
<h2 id="对序列进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对序列进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对序列进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对序列进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="string">' '</span>.join(a)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="string">''</span>.join(a)</span><br><span class="line"></span><br><span class="line"><span class="number">12345</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'-'</span>.jion(a)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'.'</span>.join(a)</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>
<h2 id="对字符串进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对字符串进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对字符串进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对字符串进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=<span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="string">' '</span>.join(b)</span><br><span class="line"></span><br><span class="line">h e l l o   w o r l d</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'-'</span> .join(b)</span><br><span class="line"></span><br><span class="line">h-e-l-l-o- -w-o-r-l-d</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">':'</span>.jion(b)</span><br><span class="line"></span><br><span class="line">h:e:l:l:o: :w:o:r:l:d</span><br></pre></td></tr></table></figure>
<h2 id="对元组进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对元组进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对元组进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对元组进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">' '</span>.join(c)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'-'</span>.join(c)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">':'</span>.join(c)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>:<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="对字典进行无序操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对字典进行无序操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对字典进行无序操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对字典进行无序操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;<span class="string">'name1'</span>:<span class="string">'a'</span>,<span class="string">'name2'</span>:<span class="string">'b'</span>,<span class="string">'name3'</span>:<span class="string">'c'</span>,<span class="string">'name4'</span>:<span class="string">'d'</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">' '</span>.jion(d)</span><br><span class="line"></span><br><span class="line">name1 name2 name3 name4</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'-'</span>.join(d)</span><br><span class="line"></span><br><span class="line">name1-name2-name3-name4</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">':'</span>.join(d)</span><br><span class="line"></span><br><span class="line">name1:name2:name3:name4</span><br></pre></td></tr></table></figure>
<h2 id="对目录进行操作"><a href="#对目录进行操作" class="headerlink" title="对目录进行操作"></a>对目录进行操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.path.join(<span class="string">'/hello/'</span>,<span class="string">'good/date'</span>,<span class="string">'datbody'</span>)</span><br><span class="line"></span><br><span class="line">hello/good/date/datbody</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中max函数的lambda表达式用法</title>
    <url>/2020/06/03/PYTHON%E4%B8%ADmax%E5%87%BD%E6%95%B0%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中max函数的lambda表达式用法"><a href="#PYTHON中max函数的lambda表达式用法" class="headerlink" title="PYTHON中max函数的lambda表达式用法"></a>PYTHON中max函数的lambda表达式用法</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>由一道<code>leetcode</code>题来引入<code>PYTHON</code>中<code>max</code>函数的<code>lambda</code>表达式用法<br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        p = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            p1 = self.get_palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            p2 = self.get_palindrome(s, i, i)</span><br><span class="line">            p = max([p, p1, p2], key=<span class="keyword">lambda</span> x: len(x))</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_palindrome</span><span class="params">(self, s: str, l: int, r: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br></pre></td></tr></table></figure>
<p><code>max([p, p1, p2], key=lambda x: len(x))</code>的含义就是本文章的内容</p>
<h2 id="lambda表达式介绍"><a href="#lambda表达式介绍" class="headerlink" title="lambda表达式介绍"></a>lambda表达式介绍</h2><p>在学习<code>python</code>的过程中，<code>lambda</code>的语法时常会使人感到困惑，<code>lambda</code>是什么，为什么要使用<code>lambda</code>，是不是必须使用<code>lambda</code>？</p>
<ol>
<li><code>lambda</code>是什么？<br>我们来看此表达式：<code>g = lambda x:x+1</code>，看一下执行的结果：<code>g(1)==2</code>、<code>g(2)==3</code>,当然，你也可以这样使用：<code>lambda x:x+1(1)</code>，结果为<code>2</code><br>可以这样认为,<code>lambda</code>作为一个表达式，定义了一个匿名函数，上例的代码<code>x</code>为入口参数，<code>x+1</code>为函数体，用函数来表示为:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><code>lambda</code>定义了一个匿名函数</li>
<li><code>lambda</code>并不会带来程序运行效率的提高，只会使代码更简洁</li>
<li>如果可以使用<code>for...in...if</code>来完成的，坚决不用<code>lambda</code></li>
<li>如果使用<code>lambda</code>，<code>lambda</code>内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。</li>
<li>总结：<code>lambda</code>是为了减少单行函数的定义而存在的</li>
</ol>
<h2 id="max函数中的lambda表达式"><a href="#max函数中的lambda表达式" class="headerlink" title="max函数中的lambda表达式"></a>max函数中的lambda表达式</h2><p>现在回到我们的max函数中，就十分容易理解了:<br>函数形式：<code>max( x ,key=lambda a : b )</code>，x可以是任何数值，可以有多个x值<br>这个函数的意思是：我们先把x值带入lambda函数转换成b值，然后再将b值进行比较<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">haha0=max(<span class="string">'az'</span>,<span class="string">'za'</span>, key=<span class="keyword">lambda</span> a: a[<span class="number">0</span>])</span><br><span class="line">haha1=max(<span class="string">'az'</span>,<span class="string">'za'</span>, key=<span class="keyword">lambda</span> a: a[<span class="number">1</span>])</span><br><span class="line">haha2=max(range(<span class="number">10</span>),key=<span class="keyword">lambda</span> a:a&gt;<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">print(haha0)        <span class="comment">#输出za</span></span><br><span class="line">print(haha1)        <span class="comment">#输出az</span></span><br><span class="line">print(haha2)        <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure></p>
<p>以<code>haha0</code>为例子：我们传入<code>az</code>，<code>za</code>，为了方便解释称之为虚拟比较，但是因为我们引入了<code>lambda</code>表达式，所以，我们实际上比较的是，<code>az</code>中的第一位<code>a</code>和<code>za</code>中第一位的<code>z</code>，由<code>ascii</code>码表可以知道<code>a</code>是小于<code>z</code>的，所以在这里最大的是<code>z</code>，那么我们返回的就是<code>z</code>的虚拟比较变量，也就是本来的<code>za</code>。</p>
<p><code>haha2</code>的用法十分少见，实际上比较的是:<br><code>F F F T T T T T T T ( False 和 True )</code></p>
<p><code>T</code>是肯定比<code>F</code>大的，但是一堆<code>True</code>哪里能互相比较大小呢，所以就输出第一个<code>True</code>值的虚拟比较变量，也就是<code>4</code></p>
<p><code>max</code>中带有<code>lambda</code>的这个写法的意义在于代码变得更简洁</p>
<p>假如我们有一个字典，里面记录着人名和相应年龄，现在我们想要在里面筛选出年龄最大的那个人的一条字典记录<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=&#123;<span class="string">"老王"</span> :<span class="number">18</span> , <span class="string">"小李"</span>:<span class="number">99</span>&#125;</span><br><span class="line">haha3=max(x.items(), key=<span class="keyword">lambda</span> a: a[<span class="number">1</span>])</span><br><span class="line">print(haha3)        <span class="comment">#输出('小李', 99)</span></span><br></pre></td></tr></table></figure></p>
<p>要注意使用字典的话一定要x.items()，不能直接输入x值，达不到我们想要的效果   </p>
<p>其实我们大可不必这么写，直接从字典中提取出年龄列表进行比较：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=&#123;<span class="string">"老王"</span> :<span class="number">18</span> , <span class="string">"小李"</span>:<span class="number">99</span>&#125;</span><br><span class="line">y=[]</span><br><span class="line"><span class="keyword">for</span> name,age <span class="keyword">in</span> x.items():</span><br><span class="line">    y.append(age)</span><br><span class="line">haha4=max(y)</span><br><span class="line">print(haha4)</span><br></pre></td></tr></table></figure></p>
<p>只是这样写是比较麻烦以及浪费内存的不是么？我想这就是<code>max</code>函数中设置<code>lambda</code>表达式的意义  </p>
<p>再举两个例子：    </p>
<ol>
<li>取第一维<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [(<span class="number">1</span>,<span class="number">2.5</span>), (<span class="number">1.5</span>, <span class="number">3.2</span>), (<span class="number">1.3</span>, <span class="number">4.0</span>), (<span class="number">2.2</span>, <span class="number">1.8</span>)]</span><br><span class="line">y,z = max(num, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">print(y, z)      <span class="comment">#结果为2.2 1.8</span></span><br></pre></td></tr></table></figure></li>
<li>取第二维<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [(<span class="number">1</span>,<span class="number">2.5</span>), (<span class="number">1.5</span>, <span class="number">3.2</span>), (<span class="number">1.3</span>, <span class="number">4.0</span>), (<span class="number">2.2</span>, <span class="number">1.8</span>)]</span><br><span class="line">y,z = max(num, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">print(y, z)      <span class="comment">#结果为1.3 4.0</span></span><br></pre></td></tr></table></figure>
<img src="https://ae01.alicdn.com/kf/H12f0feac72244f349b51fc9f740d048fh.jpg" alt=""></li>
</ol>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES/ROUND/648/DIV2</title>
    <url>/2020/06/10/CODEFORCES-ROUND-648-DIV2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CODEFORCES-ROUND-648-DIV2"><a href="#CODEFORCES-ROUND-648-DIV2" class="headerlink" title="CODEFORCES/ROUND/648/DIV2"></a>CODEFORCES/ROUND/648/DIV2</h1><h2 id="A-Matrix-Game"><a href="#A-Matrix-Game" class="headerlink" title="A.Matrix Game"></a><a href="https://codeforces.com/contest/1365/problem/A" target="_blank" rel="noopener">A.Matrix Game</a></h2><h3 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h3><p><code>1100</code>，标签：<code>implementation</code>   </p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>有一个<code>n</code>乘<code>m</code>的矩阵，由<code>0</code>和<code>1</code>组成，当一个<code>0</code>的同行同列没有<code>1</code>时，可以把这个<code>0</code>变为<code>1</code>，两个人轮流把<code>0</code>变成<code>1</code>，最后无法执行此操作的人输（也就是轮到某一人时，此时矩阵上剩余的<code>0</code>都无法变成<code>1</code>，此人输）</p>
<p>第一行输入测试次数，每次测试第一行输入<code>n</code>和<code>m</code>，然后<code>n</code>行输入矩阵元素（每行<code>m</code>个），输出最后获胜者</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思维题，读入的时候记录一下<code>1</code>所占的行和列数，用总的<code>n</code>和<code>m</code>减去行和列数求得剩余的行和列数，之后每翻一个<code>0</code>，此剩余的行数和列数减一，所以能翻的<code>0</code>的个数就是<code>min(剩余的行数,剩余的列数)</code>，用此最小值判断奇偶即可求出获胜者</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">                <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">                    a.insert(i);</span><br><span class="line">                    b.insert(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> aa = n - a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> bb = m - b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">min</span>(aa, bb);</span><br><span class="line">        <span class="keyword">if</span> (c % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Vivek"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Ashish"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Trouble-Sort"><a href="#B-Trouble-Sort" class="headerlink" title="B.Trouble Sort"></a><a href="https://codeforces.com/contest/1365/problem/B" target="_blank" rel="noopener">B.Trouble Sort</a></h2><h3 id="难度-1"><a href="#难度-1" class="headerlink" title="难度"></a>难度</h3><p><code>1300</code>，标签：<code>implementation</code></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>第一行输入测试数目，每次测试输入一个数<code>N</code>，代表数组的元素，接下来一行输入<code>N</code>的值代表数组中的元素，再下一行输入<code>N</code>个<code>0</code>或<code>1</code>代表此数组元素的类型，类型不同的元素可以交换，问能否通过交换让此数组变成升序排列 </p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>当这<code>N</code>个数由<code>0</code>和<code>1</code>组成时，一定可以换成升序排列，因为只要有一对类型不一样的值，它们就可以无限换，当这<code>N</code>个数全为<code>0</code>或<code>1</code>组成时，特判一下原本的数组是否为升序排序</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> a1[N], a2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(a1, <span class="number">0</span>, <span class="keyword">sizeof</span> a1);</span><br><span class="line">        <span class="built_in">memset</span>(a2, <span class="number">0</span>, <span class="keyword">sizeof</span> a2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a1[i], a2[i] = a1[i];</span><br><span class="line">        <span class="keyword">int</span> flag0 = <span class="number">0</span>, flag1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0</span>) flag0 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> flag1 = <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag0 == <span class="number">1</span> &amp;&amp; flag1 == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(a1, a1 + n);</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a1[i] != a2[i]) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>; x = <span class="number">1</span>; <span class="keyword">break</span>;&#125;; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Rotation-Matching"><a href="#C-Rotation-Matching" class="headerlink" title="C.Rotation Matching"></a><a href="https://codeforces.com/contest/1365/problem/C" target="_blank" rel="noopener">C.Rotation Matching</a></h2><h3 id="难度-2"><a href="#难度-2" class="headerlink" title="难度"></a>难度</h3><p><code>1400</code>，标签：<code>implementation</code></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>输入一个数<code>N</code>，接下来两行每行输入<code>N</code>个数，代表数组<code>A</code>和<code>B</code>，<code>A</code>和<code>B</code>的元素值相同，但顺序不同，如果<code>A</code>和<code>B</code>数组下标相同的元素值相同，则称这两个元素相等，求执行某些操作后<code>A</code>数组中的元素与<code>B</code>数组中的元素相等的个数的最大值。操作为：把<code>A</code>或<code>B</code>数组的元素全部向左或向右循环移动任意位，如<code>A</code>为<code>1 2 3</code>则向左移动<code>1</code>位为<code>2 3 1</code></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>与其让两个数组移动，不如让一个数组固定，另一个数组移动，因为数据范围的限制，我们只能用<code>O(N)</code>的时间复杂度，假设我们规定都向右移，移动的数组为<code>A</code>，那么我们用哈希表记录<code>A</code>中每个元素向右移动到<code>B</code>中对应值的位数，最后取相同位数出现最多的次数即可</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        a[temp] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        b[(a[temp] - i + n) % n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Solve-The-Maze"><a href="#D-Solve-The-Maze" class="headerlink" title="D.Solve The Maze"></a><a href="https://codeforces.com/contest/1365/problem/D" target="_blank" rel="noopener">D.Solve The Maze</a></h2><h3 id="难度-3"><a href="#难度-3" class="headerlink" title="难度"></a>难度</h3><p><code>1700</code>，标签：<code>bfs</code>  </p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个矩阵，<code>G</code>代表好人，<code>B</code>代表坏人，<code>#</code>代表墙，<code>.</code>代表空，你可以在<code>.</code>的地方加上墙，问能否让好人都到达矩阵的右下角，坏人都不能到达矩阵的右下角，输入的矩阵的右下角一定为<code>.</code>，其中<code>G、B、.</code>可以穿过，墙不能穿过，好人坏人只能上下左右移动</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>先把坏人四周加上墙，然后从右下角<code>BFS</code>检查能否到达所有好人，而不能到达所有坏人</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> arr[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">istrue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m; &#125;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] == <span class="string">'B'</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> ni = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> nj = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (istrue(ni, nj) &amp;&amp; arr[ni][nj] == <span class="string">'.'</span>) </span><br><span class="line">                            arr[ni][nj] = <span class="string">'#'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">bool</span> v[n+<span class="number">5</span>][m+<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">        <span class="keyword">if</span> (arr[n][m] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            v[n][m] = <span class="number">1</span>;</span><br><span class="line">            que.push(&#123;n, m&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ni = cur.first + dir[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nj = cur.second + dir[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (istrue(ni, nj) &amp;&amp; !v[ni][nj] &amp;&amp; arr[ni][nj] != <span class="string">'#'</span>) &#123;</span><br><span class="line">                    que.push(&#123;ni, nj&#125;);</span><br><span class="line">                    v[ni][nj] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> good = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">if</span> ((arr[i][j] == <span class="string">'G'</span> <span class="keyword">and</span> !v[i][j]) <span class="keyword">or</span> (arr[i][j] == <span class="string">'B'</span> <span class="keyword">and</span> v[i][j])) &#123;</span><br><span class="line">                    good = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (good ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Maximum-Subsequence-Value"><a href="#E-Maximum-Subsequence-Value" class="headerlink" title="E.Maximum Subsequence Value"></a><a href="https://codeforces.com/contest/1365/problem/E" target="_blank" rel="noopener">E.Maximum Subsequence Value</a></h2><h3 id="难度-4"><a href="#难度-4" class="headerlink" title="难度"></a>难度</h3><p><code>1900</code>，标签：<code>brute force</code></p>
<h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>这道题语言无法形容，直接上图</p>
<p><img src="https://ae01.alicdn.com/kf/Hf485d5e0b9e348d7b936aa2ab358dcabm.jpg" alt=""></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>鸽巢原理，当<code>n</code>小于三，<code>k</code>一定小于<code>3</code>，<code>max</code>为<code>1</code>，只要遍历<code>n</code>个数找或运算最大的就行了</p>
<p>当<code>n</code>大于<code>3</code>时，<code>K</code>可能大于<code>3</code>，因为<code>max</code>为<code>k-2</code>，所以三层枚举一定会枚举到一个算<code>i</code>的情况，如果再加一个数，原先是<code>0</code>的一定不能变成<code>1</code>，原先是<code>1</code>的反而可能变成<code>0</code>，范围反而变小，所以枚举<code>3</code>个就能找到最大值了</p>
<p>因为如果枚举<code>3</code>个或运算得到的结果某一位都为<code>0</code>，那么再加一个这一位为<code>1</code>的数，整体这一位也一定不为<code>1</code>，因为<code>max</code>为<code>k-2</code>，最多有两位<code>i</code>为<code>0</code>，三层枚举已经有三个为<code>0</code>了，由于数据范围很小，所以满足时间复杂度</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN =<span class="number">505</span>;</span><br><span class="line">ll arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,arr[i]|arr[j]|arr[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Swaps-Again"><a href="#F-Swaps-Again" class="headerlink" title="F.Swaps Again"></a><a href="https://codeforces.com/contest/1365/problem/F" target="_blank" rel="noopener">F.Swaps Again</a></h2><h3 id="难度-5"><a href="#难度-5" class="headerlink" title="难度"></a>难度</h3><p><code>2100</code>，标签：<code>constructive algorithms</code></p>
<h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给两个数组，可以把两个数组中相同位数的前缀和后缀互换位置，问多次操作后两个数组能否相等</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>做法：把<code>A</code>数组前后对应的放到一个<code>pair</code>里，然后检查<code>B</code>数组前半段的每个元素是否满足每个<code>pair</code>都占一个</p>
<p>证明：先推出来它可以随便交换左边第<code>x</code>和右边第<code>x</code>，然后推出来它可以<code>reverse</code>左边一个区间和右边对称区间。于是对于任意<code>pair</code>可以交换到任意位置，且任意<code>pair</code>内部可以交换</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; pairs;</span><br><span class="line">        vector&lt;int&gt; a(n), b(n);</span><br><span class="line">        <span class="keyword">bool</span> possible = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; a[n / <span class="number">2</span>] != b[n / <span class="number">2</span>])</span><br><span class="line">            possible = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = &#123;<span class="built_in">min</span>(a[i], a[n-i<span class="number">-1</span>]), <span class="built_in">max</span>(a[i],a[n-i<span class="number">-1</span>])&#125;;</span><br><span class="line">            pairs[p]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = &#123;<span class="built_in">min</span>(b[i], b[n - <span class="number">1</span> - i]), <span class="built_in">max</span>(b[i], b[n - <span class="number">1</span> - i])&#125;;</span><br><span class="line">            <span class="keyword">if</span> (pairs[p] &lt;= <span class="number">0</span>)</span><br><span class="line">                possible = <span class="number">0</span>;</span><br><span class="line">            pairs[p]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (possible)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Secure-Password"><a href="#G-Secure-Password" class="headerlink" title="G.Secure Password"></a><a href="https://codeforces.com/contest/1365/problem/G" target="_blank" rel="noopener">G.Secure Password</a></h2><blockquote>
<p>一道很难的交互题，超出能力范围，以后再写，未完待续</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES/div2</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中sort()和sorted()的用法</title>
    <url>/2020/06/07/PYTHON%E4%B8%ADsort-%E5%92%8Csorted-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中sort-和sorted-的用法"><a href="#PYTHON中sort-和sorted-的用法" class="headerlink" title="PYTHON中sort()和sorted()的用法"></a>PYTHON中sort()和sorted()的用法</h1><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><p>列表有自己的<code>sort</code>方法，其对列表进行原址排序，既然是原址排序，那显然元组不可能拥有这种方法，因为元组是不可修改的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">x.sort()</span><br><span class="line"><span class="keyword">print</span> x <span class="comment"># [1, 2, 4, 6, 7, 9]</span></span><br></pre></td></tr></table></figure>
<p>如果需要一个排序好的副本，同时保持原有列表不变，怎么实现呢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x =[<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">y = x[ : ]</span><br><span class="line">y.sort()</span><br><span class="line"><span class="keyword">print</span> y <span class="comment">#[1, 2, 4, 6, 7, 9]</span></span><br><span class="line"><span class="keyword">print</span> x <span class="comment">#[4, 6, 2, 1, 7, 9]</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>y = x[:]</code>通过分片操作将列表<code>x</code>的元素全部拷贝给<code>y</code>，如果简单的把<code>x</code>赋值给<code>y</code>：<code>y=x</code>，<code>y</code>和<code>x</code>还是指向同一个列表，并没有产生新的副本</p>
<p>另一种获取已排序的列表副本的方法是使用sorted函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x =[<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">y = sorted(x)</span><br><span class="line"><span class="keyword">print</span> y <span class="comment">#[1, 2, 4, 6, 7, 9]</span></span><br><span class="line"><span class="keyword">print</span> x <span class="comment">#[4, 6, 2, 1, 7, 9]</span></span><br></pre></td></tr></table></figure>
<p><code>sorted</code>返回一个有序的副本，并且类型总是列表，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> sorted(<span class="string">'Python'</span>) <span class="comment">#['P', 'h', 'n', 'o', 't', 'y']</span></span><br></pre></td></tr></table></figure>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p><code>sort</code>方法还有两个可选参数：<code>key</code>和<code>reverse</code></p>
<p><code>key</code>在使用时必须提供一个排序过程总调用的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;mmm&#39;, &#39;mm&#39;, &#39;mm&#39;, &#39;m&#39; ]</span><br><span class="line">x.sort(key &#x3D; len)</span><br><span class="line">print x # [&#39;m&#39;, &#39;mm&#39;, &#39;mm&#39;, &#39;mmm&#39;]</span><br></pre></td></tr></table></figure>
<p><code>reverse</code>实现降序排序，需要提供一个布尔值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span> ,<span class="number">0</span> , <span class="number">1</span>]</span><br><span class="line">y.sort(reverse = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> y <span class="comment">#[8, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [(<span class="number">123</span>,<span class="string">'b'</span>,<span class="number">8</span>),(<span class="number">122</span>,<span class="string">'c'</span>,<span class="number">3</span>),(<span class="number">128</span>,<span class="string">'a'</span>,<span class="number">5</span>)]</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组的第1个元素排序,没有任何参数时，默认是由小到大排序</span></span><br><span class="line">a.sort()</span><br><span class="line">print(<span class="string">'\n以元组的第1个元素排序'</span>)</span><br><span class="line">print(a)</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">f'由大到小：<span class="subst">&#123;a&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组的第2个元素排序</span></span><br><span class="line">print(<span class="string">'\n以元组的第2个元素排序'</span>)</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> i:i[<span class="number">1</span>])</span><br><span class="line">print(a)</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> i:i[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">f'由大到小：<span class="subst">&#123;a&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组的第3个元素排序</span></span><br><span class="line">print(<span class="string">'\n以元组的第3个元素排序'</span>)</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> i:i[<span class="number">2</span>])</span><br><span class="line">print(a)</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> i:i[<span class="number">2</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">f'由大到小：<span class="subst">&#123;a&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hd768bd7dd9b74f66abfafe1c877ce715C.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中strip()、lstrip()、rstrip()用法详解</title>
    <url>/2020/06/04/PYTHON%E4%B8%ADstrip-%E3%80%81lstrip-%E3%80%81rstrip-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中strip-、lstrip-、rstrip-用法详解"><a href="#PYTHON中strip-、lstrip-、rstrip-用法详解" class="headerlink" title="PYTHON中strip()、lstrip()、rstrip()用法详解"></a>PYTHON中strip()、lstrip()、rstrip()用法详解</h1><p>Python中有三个去除头尾字符、空白符的函数，它们依次为:</p>
<p><code>strip</code>： 用来去除头尾字符、空白符(换行、回车、制表符、空格)<br><code>lstrip</code>：用来去除开头字符、空白符(换行、回车、制表符、空格)<br><code>rstrip</code>：用来去除结尾字符、空白符(换行、回车、制表符、空格)    </p>
<p><strong>注意</strong>：这些函数都只会删除头和尾的字符，中间的不会删除</p>
<p>用法分别为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.strip([chars])</span><br><span class="line">string.lstrip([chars])</span><br><span class="line">string.rstrip([chars])</span><br></pre></td></tr></table></figure></p>
<p>参数<code>chars</code>是可选的，当<code>chars</code>为空，默认删除<code>string</code>头尾的空白符   </p>
<p>当<code>chars</code>不为空时，函数会被<code>chars</code>解成一个个的字符，然后将这些字符去掉    </p>
<p>它返回的是去除头尾字符(或空白符)的<code>string</code>副本，<code>string</code>本身不会发生改变</p>
<p>举例说明如下：</p>
<ol>
<li><p>当chars为空时，默认删除空白符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">' ab cd '</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.strip() <span class="comment">#删除头尾空格</span></span><br><span class="line"><span class="string">'ab cd'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.lstrip() <span class="comment">#删除开头空格</span></span><br><span class="line"><span class="string">'ab cd '</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.rstrip() <span class="comment">#删除结尾空格</span></span><br><span class="line"><span class="string">' ab cd'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当chars不为空时，函数会被chars解成一个个的字符，然后将这些字符去掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">'1a2b12c21'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2.strip(<span class="string">'12'</span>) <span class="comment">#删除头尾的1和2</span></span><br><span class="line"><span class="string">'a2b12c'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2.lstrip(<span class="string">'12'</span>) <span class="comment">#删除开头的1和2</span></span><br><span class="line"><span class="string">'a2b12c21'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2.rstrip(<span class="string">'12'</span>) <span class="comment">#删除结尾的1和2</span></span><br><span class="line"><span class="string">'1a2b12c'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中反转字符串的三种方法</title>
    <url>/2020/06/04/PYTHON%E4%B8%AD%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中反转字符串的三种方法"><a href="#PYTHON中反转字符串的三种方法" class="headerlink" title="PYTHON中反转字符串的三种方法"></a>PYTHON中反转字符串的三种方法</h1><h2 id="1-切片法（最简洁的一种）"><a href="#1-切片法（最简洁的一种）" class="headerlink" title="1.切片法（最简洁的一种）"></a>1.切片法（最简洁的一种）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse1</span><span class="params">()</span>:</span></span><br><span class="line">    s = input(<span class="string">"请输入需要反转的内容："</span>)</span><br><span class="line">    <span class="keyword">return</span> s[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(reverse1())</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line"></span><br><span class="line">请输入需要反转的内容：莺啼岸柳弄春晴 柳弄春晴夜月明</span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This is extended slice syntax. It works by doing [begin:end:step] - by leaving begin and end off and specifying a step of -1, it reverses a string.<br>这是扩展片语法。它的工作方式是[begin:end:step]-离开begin和end并指定步骤-1，它反转字符串。</p>
</blockquote>
<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse2</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> reverse2(s[<span class="number">1</span>:])+s[<span class="number">0</span>]</span><br><span class="line">print(reverse2(<span class="string">"莺啼岸柳弄春晴 柳弄春晴夜月明"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line"></span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<h2 id="3-借用列表的reverse-方法"><a href="#3-借用列表的reverse-方法" class="headerlink" title="3.借用列表的reverse()方法"></a>3.借用列表的reverse()方法</h2><blockquote>
<p>reverse()函数将列表的内容进行了反转，借助这个特性，可以先将字符串转换成列表，利用reverse()函数进行反转后，再处理成字符串。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse3</span><span class="params">(s)</span>:</span></span><br><span class="line">    l=list(s)</span><br><span class="line">    l.reverse()</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">""</span>.join(l))</span><br><span class="line">print(reverse3(<span class="string">"莺啼岸柳弄春晴 柳弄春晴夜月明"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line"></span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣python题解(1-100题)</title>
    <url>/2020/06/03/%E5%8A%9B%E6%89%A3python%E9%A2%98%E8%A7%A3-1-100%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1.两数之和</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[nums[i]], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[target - nums[i]] = i</span><br></pre></td></tr></table></figure>
<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2.两数相加</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = cur =ListNode(<span class="number">0</span>)</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                carry += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                carry += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur.next = ListNode(carry%<span class="number">10</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            carry //=<span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3.无重复字符的最长子串</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        p1 = p2 = m = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p2 &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[p2] <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[s[p2]] = <span class="literal">True</span></span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">                m = max(len(d), m)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">del</span> d[s[p1]]</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
<h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4.寻找两个正序数组的中位数</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        totalList = nums1 + nums2</span><br><span class="line">        totalList.sort()</span><br><span class="line">        <span class="keyword">if</span> len(totalList) % <span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">            i = totalList[len(totalList)//<span class="number">2</span>]</span><br><span class="line">            j = totalList[len(totalList)//<span class="number">2</span> - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> (i+j)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> totalList[len(totalList)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        p = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            p1 = self.get_palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            p2 = self.get_palindrome(s, i, i)</span><br><span class="line">            p = max([p, p1, p2], key=<span class="keyword">lambda</span> x: len(x))</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_palindrome</span><span class="params">(self, s: str, l: int, r: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br></pre></td></tr></table></figure>
<h1 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6.Z字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6.Z字形变换</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, S: str, R: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> R == <span class="number">1</span> <span class="keyword">or</span> R &gt; len(S):  <span class="comment"># corner case</span></span><br><span class="line">            <span class="keyword">return</span> S</span><br><span class="line">        res, i, step = [<span class="string">''</span> <span class="keyword">for</span> r <span class="keyword">in</span> range(R)], <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># a string for each line</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> S:</span><br><span class="line">            res[i] += s</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:  <span class="comment"># first row</span></span><br><span class="line">                step = <span class="number">1</span>  <span class="comment"># down</span></span><br><span class="line">            <span class="keyword">if</span> i == R - <span class="number">1</span>:  <span class="comment"># last row</span></span><br><span class="line">                step = <span class="number">-1</span>  <span class="comment"># up</span></span><br><span class="line">            i += step</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure>
<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7.整数反转</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        result = int(str(x)[::<span class="number">-1</span>]) <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -int(str(x)[<span class="number">1</span>:][::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">-2</span>**<span class="number">31</span> &lt;= result &lt;= (<span class="number">2</span>**<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8.字符串转换整数"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8.字符串转换整数</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            ret = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> i.isdigit(): <span class="keyword">return</span> ret</span><br><span class="line">                ret = ret *<span class="number">10</span> + int(i)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        s = str.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'+'</span>: <span class="keyword">return</span> min(<span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>,helper(s[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'-'</span>: <span class="keyword">return</span> max(<span class="number">-2</span>**<span class="number">31</span>,-helper(s[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>].isdigit(): <span class="keyword">return</span> min(<span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>,helper(s))</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9.回文数</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        orig = x</span><br><span class="line">        back_x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            back_x = back_x * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> orig == back_x</span><br></pre></td></tr></table></figure>
<h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.正则表达式匹配</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        s, p = <span class="string">' '</span>+ s, <span class="string">' '</span>+ p</span><br><span class="line">        lenS, lenP = len(s), len(p)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(lenP) <span class="keyword">for</span> i <span class="keyword">in</span> range(lenS)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, lenP):</span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, lenS):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, lenP):</span><br><span class="line">                <span class="keyword">if</span> p[j] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">"*"</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] <span class="keyword">or</span> int(dp[i<span class="number">-1</span>][j] <span class="keyword">and</span> p[j<span class="number">-1</span>] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bool(dp[<span class="number">-1</span>][<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11.盛最多水的容器</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        second = len(height) - <span class="number">1</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> first &lt; second:</span><br><span class="line">            area = max((second - first) * min(height[first], height[second]), area)</span><br><span class="line">            <span class="keyword">if</span> height[first] &lt; height[second]:</span><br><span class="line">                first+=<span class="number">1</span>        </span><br><span class="line">            <span class="keyword">else</span>:     </span><br><span class="line">                second-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure>
<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12.整数转罗马数字</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">"I"</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">"IV"</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="string">"V"</span>,</span><br><span class="line">            <span class="number">9</span>: <span class="string">"IX"</span>,</span><br><span class="line">            <span class="number">10</span>: <span class="string">"X"</span>,</span><br><span class="line">            <span class="number">40</span>: <span class="string">"XL"</span>,</span><br><span class="line">            <span class="number">50</span>: <span class="string">"L"</span>,</span><br><span class="line">            <span class="number">90</span>: <span class="string">"XC"</span>,</span><br><span class="line">            <span class="number">100</span>: <span class="string">"C"</span>,</span><br><span class="line">            <span class="number">400</span>: <span class="string">"CD"</span>,</span><br><span class="line">            <span class="number">500</span>: <span class="string">"D"</span>,</span><br><span class="line">            <span class="number">900</span>: <span class="string">"CM"</span>,</span><br><span class="line">            <span class="number">1000</span>: <span class="string">"M"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        arr = [<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">while</span> num &gt;= a:</span><br><span class="line">                num = num - a</span><br><span class="line">                result = result + mapping[a]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13.罗马数字转整数</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span>    </span><br><span class="line">        res, prev = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dict = &#123;<span class="string">'I'</span>:<span class="number">1</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'L'</span>:<span class="number">50</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[::<span class="number">-1</span>]:          </span><br><span class="line">            <span class="keyword">if</span> dict[i] &gt;= prev:</span><br><span class="line">                res += dict[i]     </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res -= dict[i]    </span><br><span class="line">            prev = dict[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14.最长公共前缀</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        l = list(zip(*strs))</span><br><span class="line">        prefix = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> len(set(i))==<span class="number">1</span>:</span><br><span class="line">                prefix += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure>
<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15.三数之和</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        result = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            l = i + <span class="number">1</span></span><br><span class="line">            r = len(nums) - <span class="number">1</span></span><br><span class="line">            target = <span class="number">0</span> - nums[i]</span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="keyword">if</span> nums[l] + nums[r]== target:</span><br><span class="line">                    result.add((nums[i], nums[l], nums[r]))</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> list(result)</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H26cf739c186b48a7a158b9096c5b651dZ.jpg" alt=""></p>
]]></content>
      <categories>
        <category>力扣/python</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
        <tag>LEETCODE</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中zip()与zip(*)的用法</title>
    <url>/2020/06/06/PYTHON%E4%B8%ADzip-%E4%B8%8Ezip-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中zip-与zip-的用法"><a href="#PYTHON中zip-与zip-的用法" class="headerlink" title="PYTHON中zip()与zip(*)的用法"></a>PYTHON中zip()与zip(*)的用法</h1><p>可以看成是<code>zip()</code>为压缩，<code>zip(*)</code>是解压</p>
<h2 id="zip-与zip"><a href="#zip-与zip" class="headerlink" title="zip()与zip(*)"></a>zip()与zip(*)</h2><p>举一个示例代码来说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">a_b_zip = zip(a, b)  <span class="comment"># 打包为元组的列表,而且元素个数与最短的列表一致</span></span><br><span class="line">print(<span class="string">"type of a_b_zip is %s"</span> % type(a_b_zip))  <span class="comment"># 输出zip函数的返回对象类型</span></span><br><span class="line">a_b_zip = list(a_b_zip)  <span class="comment"># 因为zip函数返回一个zip类型对象，所以需要转换为list类型</span></span><br><span class="line">print(a_b_zip)</span><br><span class="line">print(<span class="string">"------------------------------------------"</span>)</span><br><span class="line">a_c_zip = zip(a, c)</span><br><span class="line">a_c_zip = list(a_c_zip)</span><br><span class="line">print(a_c_zip)</span><br><span class="line"></span><br><span class="line">nums = [[<span class="string">'a1'</span>, <span class="string">'a2'</span>, <span class="string">'a3'</span>], [<span class="string">'b1'</span>, <span class="string">'b2'</span>, <span class="string">'b3'</span>], [<span class="string">'c1'</span>, <span class="string">'c2'</span>, <span class="string">'c3'</span>]]</span><br><span class="line">iterator = zip(*nums)  <span class="comment"># 参数为list数组时，是压缩数据，相当于zip()函数</span></span><br><span class="line">print(<span class="string">"type of iterator is %s"</span> % type(iterator))  <span class="comment"># 输出zip(*zipped)函数返回对象的类型</span></span><br><span class="line">iterator = list(iterator)  <span class="comment"># 因为zip(*zipped)函数返回一个zip类型对象，所以需要转换为list类型</span></span><br><span class="line">print(iterator)</span><br><span class="line">print(<span class="string">"------------------------------------------"</span>)</span><br><span class="line">print(<span class="string">"a_b_zip ："</span>, a_b_zip)</span><br><span class="line">print(<span class="string">"zip(*a_b_zip) ："</span>, list(zip(*a_b_zip)))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">type of a_b_zip <span class="keyword">is</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">zip</span>'&gt;</span></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">------------------------------------------</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">type of iterator <span class="keyword">is</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">zip</span>'&gt;</span></span><br><span class="line">[('a1', 'b1', 'c1'), ('a2', 'b2', 'c2'), ('a3', 'b3', 'c3')]</span><br><span class="line">------------------------------------------</span><br><span class="line">a_b_zip ： [(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">zip(*a_b_zip) ： [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>
<p>ps：<code>zip()</code>函数的返回对象转换成<code>list</code>不是必须的，只是为了方便输出，<code>list</code>输出很直观</p>
<h2 id="用zip-反转字典"><a href="#用zip-反转字典" class="headerlink" title="用zip()反转字典"></a>用zip()反转字典</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br><span class="line">m.items()</span><br><span class="line">print(list(zip(m.values(), m.keys())))</span><br><span class="line">mi &#x3D; dict(zip(m.values(), m.keys()))</span><br><span class="line">print(mi)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;d&#39;)]</span><br><span class="line">&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础总结(2)</title>
    <url>/2020/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络基础总结-2"><a href="#计算机网络基础总结-2" class="headerlink" title="计算机网络基础总结(2)"></a>计算机网络基础总结(2)</h1><p>1. </p>
]]></content>
  </entry>
  <entry>
    <title>translate first day</title>
    <url>/2020/05/31/translate-first-day/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="A-week-of-distractions-from-Trump-shows-a-leader-in-crisis"><a href="#A-week-of-distractions-from-Trump-shows-a-leader-in-crisis" class="headerlink" title="A week of distractions from Trump shows a leader in crisis"></a>A week of distractions from Trump shows a leader in crisis</h1><p>(CNN)On Monday, as the nation marked Memorial Day, President Donald Trump mocked his campaign rival for wearing a face mask. On Wednesday, as the national death toll from coronavirus reached a wretched milestone, Trump and his family flew to Florida in an attempted focus on space travel.</p>
<p>By Friday, as smoke was lifting in Minneapolis after a night of racial unrest, he announced the United States would withdraw from the World Health Organization. A day later, after another night of protests, he declared himself safe inside his heavily fortified mansion and insinuated his own supporters would rally outside that evening.</p>
<p>In between, there was a dark suggestion of murder, false conspiracies about voting through the mail, a fight over where to hold his nominating convention and a dramatic escalation of ill will with the very social media platform that facilitated almost all the other diversions in the first place.</p>
<p>Trump’s efforts to change the subject at moments of peril have been a hallmark of his entire career in politics and, when successful, a constant source of frustration for his rivals. But rarely have they appeared more blatant or off-key than now, as a battered nation emerges from a pandemic that has left more than 100,000 dead and as racial unrest brews again.<br>That it is all happening five months before Trump faces an election in which polls show him trailing only heightens the sense of a leader in crisis, even as he insists he has a handle on both matters and attempts to proceed as planned with his presidency. Trump, cognizant of his precarious political position, has retrenched.</p>
<p>Unwilling or unable to strike a unifying tone, Trump lashed out Saturday morning when he criticized the Democratic mayors of Washington and Minneapolis while appearing to summon his own supporters to rally outside the White House.</p>
<p>After announcing his was safe, warning he was protected by “vicious dogs” and “ominous weapons,” Trump provided a play-by-play of Friday evening’s protests, of which he said he’d “watched every move.” Trump wrote: “Tonight, I understand, is MAGA NIGHT AT THE WHITE HOUSE???”</p>
<p>Advisers insist Trump is focused on reviving the country after three months of pandemic that have led, along with the six-figure death toll, to record levels of unemployment and entire industries shuttered. Trump has aggressively pushed for states to reopen even when they don’t necessarily meet the parameters set out by his task force, which has seen its meetings sharply curtailed and its health experts’ public roles reduced.</p>
<p>At the same time, Trump has sought over the past week to shine the presidential spotlight into dustier corners filled with festering racial grievances and antique conspiracies, all of which have been debunked. He has waged feuds old and new and unveiled strategically timed policy announcements at a moment when his leadership is being questioned.</p>
<p>The events that unfolded after the President issued a tweet early Friday laden with racist overtones underscored the degree to which he has used inflammatory statements to ignite controversy and enthuse his supporters, even as he denied later that those were his intentions.</p>
<p>Aides spent Friday debating whether Trump should address the situation in Minnesota during a planned appearance in the Rose Garden, which had been called to announce new actions against China and the US withdrawal from the World Health Organization.</p>
<p>Some of his advisers encouraged him to speak about Minnesota because his election-year rival had already delivered an address on the topic. Others were more skeptical, convinced Trump would only face more questions about his tweet that used a phrase first uttered by a Miami police chief in 1967 to describe a crackdown in black neighborhoods.</p>
<p>More than 12 hours after tweeting “when the looting starts, the shooting starts” as images of Minneapolis fire and riots played on cable news, Trump insisted on Twitter that his message was not, in fact, a reference to brutal civil rights-era police tactics. But he ignored the topic in the Rose Garden, choosing instead to focus on China and retreating to the Oval Office as reporters shouted questions.</p>
<p>It was only around 5 p.m. ET — after a full day of public silence — that Trump announced he’d spoken with the family of George Floyd, the black man who had died after being pinned to the ground by his neck by a white police officer.</p>
<p>“It certainly looked like there was no excuse for it,” he said of the violent arrest during a roundtable event meant to focus on coronavirus.</p>
<p>The episode followed Trump’s longtime model of igniting controversy before retreating hours later. If anything, leaving his message lingering without explanation was a diversion in itself and another example of Trump’s inability — or unwillingness — to put aside the divisive itch he’s long cultivated.</p>
<p>The role of national consoler has never come easily to Trump, nor have attempts at unifying a country riven by politics and ideology. In many instances he’s simply shown no interest in assuming the tone or accepting the responsibilities that US presidents have shouldered throughout history.</p>
<p>He doesn’t believe it’s up to him to demonstrate responsible mask-wearing, and he retweeted a message earlier this week that appeared to mock former Vice President Joe Biden’s mask-and-aviators ensemble.</p>
<p>Most of the country may say Trump should wear a mask in public — a Quinnipiac University poll this week put the figure at 67% — but among white men the number stands only at 49%, enough for his stance to pass political muster with his most reliable bloc of supporters.</p>
<p>As coronavirus began ravaging parts of the country, he did declare himself a wartime President waging battle against the “invisible enemy.” But with war comes death — in this case, more US deaths than the Vietnam and Korean wars combined — and Trump was slow to acknowledge the 100,000 milestone reached midweek.</p>
<p>He was aboard Air Force One when the death toll officially ticked into six digits, returning to Washington after his plans to witness the first manned US space launch in nearly a decade had been thwarted by the weather.</p>
<p>He had hoped that the trip, with his entire family in tow, would help shift a national storyline from the miserable pandemic toward a more optimistic one of scientific potential. But the launch was scrubbed when thunderstorms rolled in and Trump was forced to return to Washington.</p>
<p>The President didn’t address the grim figure as he returned to the White House with the first lady on Wednesday.</p>
<p>He finally tweeted about it on Thursday morning, deeming it “a very sad milestone.” But he did not make time to address it in person.</p>
<p>Instead, he has wielded sinister conspiracies and false allegations.</p>
<p>He’s railed against vote-by-mail, which many governors are seeking to expand amid a highly contagious viral pandemic and which has not proved to be rife with fraud. Despite his issues with the practice, Trump himself voted by mail in February, even though he was in Florida — the state where he votes — on the day that early voting locations opened and drove past one that’s across from his golf course at least six times.</p>
<p>He has actively worked to relitigate the circumstances that led to Robert Mueller’s Russia investigation, including this week, when he fan-danced around the still-unnamed allegation against his predecessor Barack Obama.</p>
<p>On Friday evening, his newly installed director of national intelligence appeared to further the cause by releasing the transcripts of phone calls between Trump’s onetime national security adviser and the then-Russian ambassador to the United States.</p>
<p>The darkest of Trump’s fixations remains the unfounded insinuation that a morning cable news host played a role in killing a young aide almost two decades ago, a blatant falsehood that led this week to pleas from the young woman’s widower for Twitter to disallow the messages.</p>
<p>The social media giant did not block those messages but did attempt to fact-check his claims about vote-by-mail, a move that set Trump off and led to a hurried effort inside the White House to finalize an executive order few believe will withstand legal scrutiny and that could, potentially, cause even more regulation of the President’s tweets. Hours after he signed it, Twitter slapped a warning on his Minnesota tweet, saying it glorified violence.</p>
<p>At one time, Trump used his once-a-week campaign rallies to unleash the vitriol and paranoia that his supporters love and that he believes are the very characteristics that led to his unlikely victory in 2016.</p>
<p>Rallies are out of the question for now — though aides say they’re looking to revive them sooner rather than later.</p>
<p>This story has been updated with additional developments.</p>
<p><img src="https://ae01.alicdn.com/kf/Haf7cd3754a7a4a1390938116e7db9917N.jpg" alt=""></p>
]]></content>
      <categories>
        <category>TRANSLATE</category>
      </categories>
      <tags>
        <tag>TRANSLATE</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础总结(1)</title>
    <url>/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络基础总结-1"><a href="#计算机网络基础总结-1" class="headerlink" title="计算机网络基础总结(1)"></a>计算机网络基础总结(1)</h1><ol>
<li>局域网：覆盖范围小、自己花钱买设备、带宽固定、自己维护、100米、10M 100M 1000M<br>广域网：距离远、花钱租带宽<br>Internet：由ISP组成、有自己的机房、对网民提供访问Internet连接</li>
<li>ISP：Internet服务提供商（Internet service provide）</li>
<li>DNS：把网站域名解析成IP地址</li>
<li>子网掩码：告诉计算机哪里是网络部分，哪里是主机部分</li>
<li>路由器的作用是在不同网段转发数据</li>
<li>计算机的网卡有mac地址（物理地址），全球唯一，mac地址在计算机出场时已经被固定在网卡中：48位二进制（12位十六进制）</li>
<li><p>计算机访问过程：  </p>
<p>先把要访问的域名发送给DNS服务器，DNS服务器把域名解析成IP地址返回  </p>
<p>数据包由数据、原IP地址、目标IP地址组成  </p>
<p>数据帧由数据、原IP地址、目标IP地址、此时的mac地址、下一个目的地的mac地址组成  </p>
<p>计算机发送数据帧后，数据帧在运输的过程中两个mac地址不断变化，因此不断重新封装，但是数据包没变   </p>
<p>数据帧在运输过程中不断经过路由器，路由器看数据包中的IP地址，决定下一步走哪个mac地址</p>
<p>目标服务器收到请求后，往计算机回传数据，会把数据切割成小块，并给每一块编号，然后取一部分放到目标服务器的缓存当中，再然后在缓存中取出一块，加上此服务器IP地址、目标计算机IP地址、此时的mac地址、下一个目的地的mac开始发送，发送后，此数据块不会被缓存区删除，因为发送的过程中可能会丢失，当目标计算机收到此数据块放到计算机中的缓存区后，发送请求接受下一个数据块的消息到此服务器时，此数据块才会在缓存区被删除  </p>
<p>当计算机的缓存满了时，会读取，然后再存缓存 </p>
<p>第一张图说明：<br> <img src="https://ae01.alicdn.com/kf/Hdb3d351ef0844379b41ec593f99d16506.jpg" alt="">  </p>
<p> 第二张图说明：<br> <img src="https://ae01.alicdn.com/kf/Hdb637a9eee4a485f886ec3430de942ddU.jpg" alt=""></p>
</li>
<li><p>OSI参考模型（国际标准把计算机通信进行的定义）</p>
<ol>
<li>应用层：所有能产生网络流量的程序</li>
<li>表示层：在传输之前是否进行加密或压缩处理、传的是二进制还是ASCII码</li>
<li>会话层：电脑和某服务器建立起的联系，比如电影前进后退进、查木马都是会话层的体现 netstat -n 命令可在终端查看此电脑建立的会话  </li>
<li>传输层：可靠传输（比如某服务器传输数据到计算机、把数据分块传输，如果发送了某一块之后没收到请求下一块的信息，就会接着发送这个数据块，防止数据块丢失）、流量控制（比如服务器发送数据太快了，则计算机发消息告诉服务器调整发送速度）、不可靠传输（比如DNS解析域名，一个数据包就能说明问题与得到答案，不需要建立会话）</li>
<li>网络层：负责选择最佳路径、规划IP地址</li>
<li>数据链路层：帧的开始和结束、透明传输（将数据中与开头或结尾表示相同的部分进行转义）、差错校验（检错错误，数据中多加一部分数据进行校验，但不纠错，只检查，错误的就扔掉，纠错是在传输层进行）  </li>
<li>物理层：接口标准、电器标准、如何在物理链路上传输更快的速度</li>
</ol>
</li>
<li><p>每一层都是一个较为独立的模块，每一个模块变化都不会影响其他的模块；但每一层都有关系：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层-&gt;人（-&gt;代表xx为xx提供服务） </p>
</li>
<li><p>网络出现故障，应该从最底层物理层往上一层一层进行检查  </p>
<ol>
<li>物理层故障：查看连接状态、查看发送和接收的数据包</li>
<li>数据链路层故障：mac地址冲突、ADSL欠费、网速没办法协商一致、计算机连接到错误的VLAN(虚拟局域网)</li>
<li>网络层故障：配置了错误的IP地址、子网掩码、配置错误的网关、路由器没有配置到达目标网络的路由、数据有没有通过各个网关到达指定位置  </li>
<li>应用层故障：应用程序配置错误</li>
</ol>
</li>
<li><p>打开终端输入命令ping一个网址，若数据有来有回，则证明网通了</p>
</li>
<li>OSI参考模型和网络安全<ol>
<li>物理层安全</li>
<li>数据链路层安全：ADSL账号密码、VLAN、交换机端口绑定mac地址</li>
<li>网络层安全：在路由器上时使用ACL控制数据包流量、防火墙</li>
<li>应用层安全：开发的应用程序没漏洞</li>
</ol>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H66237f88bb294f1db97200f8cd552ddbd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>计算机网络基础——韩立刚视频总结</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中print格式化输出用法</title>
    <url>/2020/06/06/PYTHON%E4%B8%ADprint%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Python中print用法里面-、-s-、-d-代表的意思"><a href="#Python中print用法里面-、-s-、-d-代表的意思" class="headerlink" title="Python中print用法里面% 、%s 、 % d 代表的意思"></a>Python中print用法里面% 、%s 、 % d 代表的意思</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>%s</code>表示格化式一个对象为字符<br><code>%d</code>表示格化式一个对象为整数<br><code>%</code>字符：标记转换说明符的开始<br>在<code>%</code>的左侧放置一个字符串（格式化字符串），右侧放置希望格式化的值    </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Hello, %s"%"zhang3" =&gt; "Hello, zhang3"</span><br><span class="line">"%d"%33 =&gt; "33"</span><br><span class="line">"%s:%d"%("ab",3) =&gt; "ab:3"</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'%s plus %s equals %s'</span> % (<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">'1 plus 2 equals 2'</span></span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOTTERY_PRE = <span class="string">"LXG_LOT_"</span></span><br><span class="line">LOTTERY_ITEM = LOTTERY_PRE + <span class="string">'%s_ITEM'</span></span><br><span class="line">new_version = <span class="string">"20181007220245756"</span></span><br><span class="line">new_lobbery_item = LOTTERY_ITEM % new_version</span><br><span class="line">print(new_lobbery_item)</span><br><span class="line"></span><br><span class="line">输出 LXG_LOT_20181007220245756_ITEM</span><br></pre></td></tr></table></figure></li>
<li>%s 字符串<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string=<span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"string=%s"</span> % string) <span class="comment"># output: string=hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是hello</span></span><br><span class="line">print(<span class="string">"string=%2s"</span> % string) <span class="comment"># output: string=hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格</span></span><br><span class="line"><span class="comment"># 所以%7s的打印结果是  hello</span></span><br><span class="line">print(<span class="string">"string=%7s"</span> % string)<span class="comment"># output: string=  hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格</span></span><br><span class="line"><span class="comment"># 所以%-7s的打印结果是hello  !</span></span><br><span class="line">print(<span class="string">"string=%-7s!"</span> % string)<span class="comment"># output: string=hello  !</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是he</span></span><br><span class="line">print(<span class="string">"string=%.2s"</span> % string) <span class="comment"># output: string=he</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身</span></span><br><span class="line"><span class="comment"># 所以%.7s的打印结果是hello</span></span><br><span class="line">print(<span class="string">"string=%.7s"</span> % string)<span class="comment"># output: string=hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串</span></span><br><span class="line"><span class="comment"># 当截取的字符串长度小于a时，还需要在其左侧补空格</span></span><br><span class="line">print(<span class="string">"string=%7.2s"</span> % string )<span class="comment"># output: string=     he</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"string=%2.7s"</span> % string )<span class="comment"># output: string=hello</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"string=%10.7s"</span> % string) <span class="comment"># output: string=    hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用%.s来表示精度，两个*的值分别在后面小括号的前两位数值指定</span></span><br><span class="line">print(<span class="string">"string=%*.*s"</span> % (<span class="number">7</span>,<span class="number">2</span>,string)) <span class="comment"># output: string=     he</span></span><br></pre></td></tr></table></figure></li>
<li>%d 整型<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num=<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %d打印时结果是14</span></span><br><span class="line">print(<span class="string">"num=%d"</span> % num) <span class="comment"># output: num=14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %1d意思是打印结果为1位整数，当整数的位数超过1位时，按整数原值打印，所以%1d的打印结果还是14</span></span><br><span class="line">print(<span class="string">"num=%1d"</span> % num) <span class="comment"># output: num=14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数左侧补空格，所以%3d的打印结果是 14</span></span><br><span class="line">print(<span class="string">"num=%3d"</span> % num) <span class="comment"># output: num= 14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %-3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数右侧补空格，所以%3d的打印结果是14_</span></span><br><span class="line">print(<span class="string">"num=%-3d!"</span> % num) <span class="comment"># output: num=14 !</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %05d意思是打印结果为5位整数，当整数的位数不够5位时，在整数左侧补0，所以%05d的打印结果是00014</span></span><br><span class="line">print(<span class="string">"num=%05d"</span> % num) <span class="comment"># output: num=00014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %.3d小数点后面的3意思是打印结果为3位整数，</span></span><br><span class="line"><span class="comment"># 当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果是014</span></span><br><span class="line">print(<span class="string">"num=%.3d"</span> % num) <span class="comment"># output: num=014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %.0003d小数点后面的0003和3一样，都表示3，意思是打印结果为3位整数，</span></span><br><span class="line"><span class="comment"># 当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果还是014</span></span><br><span class="line">print(<span class="string">"num=%.0003d"</span> % num) <span class="comment"># output: num=014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %5.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，再在左侧补空格，</span></span><br><span class="line"><span class="comment"># 规则就是补0优先，最终的长度选数值较大的那个，所以%5.3d的打印结果还是  014</span></span><br><span class="line">print(<span class="string">"num=%5.3d"</span> % num)<span class="comment"># output: num=  014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %05.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，</span></span><br><span class="line"><span class="comment"># 由于是05，再在左侧补0，最终的长度选数值较大的那个，所以%05.3d的打印结果还是00014</span></span><br><span class="line">print(<span class="string">"num=%05.3d"</span> % num) <span class="comment"># output: num=00014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用%.d来表示精度，两个*的值分别在后面小括号的前两位数值指定</span></span><br><span class="line">print(<span class="string">"num=%*.*d"</span> % (<span class="number">4</span>,<span class="number">3</span>,num)) <span class="comment"># output: num= 014</span></span><br></pre></td></tr></table></figure></li>
<li>%f 浮点型<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># %a.bf，a表示浮点数的打印长度，b表示浮点数小数点后面的精度</span></span><br><span class="line"><span class="comment"># 只是%f时表示原值，默认是小数点后5位数</span></span><br><span class="line">print(<span class="string">"PI=%f"</span> % math.pi) <span class="comment"># output: PI=3.141593</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只是%9f时，表示打印长度9位数，小数点也占一位，不够左侧补空格</span></span><br><span class="line">print(<span class="string">"PI=%9f"</span> % math.pi) <span class="comment"># output: PI= 3.141593</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有.而没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补0</span></span><br><span class="line">print(<span class="string">"PI=%03.f"</span> % math.pi) <span class="comment"># output: PI=003</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够左侧补空格</span></span><br><span class="line">print(<span class="string">"PI=%6.3f"</span> % math.pi) <span class="comment"># output: PI= 3.142</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %-6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够右侧补空格</span></span><br><span class="line">print(<span class="string">"PI=%-6.3f!"</span> % math.pi) <span class="comment"># output: PI=3.142 !</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用%.f来表示精度，两个*的值分别在后面小括号的前两位数值指定</span></span><br><span class="line">print(<span class="string">"PI=%*.*f"</span> % (<span class="number">6</span>,<span class="number">3</span>,math.pi)) <span class="comment"># output: PI= 3.142</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础总结——mosh版本</title>
    <url>/2020/06/01/python%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94mosh%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON视频讲解-MOSH-总结"><a href="#PYTHON视频讲解-MOSH-总结" class="headerlink" title="PYTHON视频讲解(MOSH)总结"></a>PYTHON视频讲解(MOSH)总结</h1><h2 id="和C-C-的区别"><a href="#和C-C-的区别" class="headerlink" title="和C/C++的区别"></a>和C/C++的区别</h2><ol>
<li><p><code>python</code>的<code>print</code>是一个函数，其中代表换行的参数默认换行，所以每次执行一次<code>print</code>都会自动换行</p>
</li>
<li><p><code>python</code>的<code>bool</code>值是<code>False</code>和<code>True</code>，首字母大写，而<code>C/C++</code>的<code>bool</code>类型值是<code>false</code>和<code>true</code>，首字母小写  </p>
</li>
<li><p><code>python</code>的输出函数是<code>print</code>，而<code>C</code>的输出语句是<code>printf</code></p>
</li>
<li><p><code>python</code>的输入语句是<code>input()</code>，这个函数把括号内的东西输出，并接受输入的值，所以可以有如下写法<code>name = input(&quot;what&#39;s your name&quot;)</code></p>
</li>
<li><p><code>input</code>把接收的值转化为字符串</p>
</li>
<li><p><code>10/3 = 3.333</code>，这与<code>C/C++</code>不同<br><code>10//3 = 3</code>，这与<code>C/C++</code>相同<br><code>3**2 = 9</code>，<code>C/C++</code>中没有此用法</p>
</li>
<li><p><code>C++</code>中的类与<code>python</code>中的类有一点区别<br>假设都定义了<code>School</code>这个类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++:</span><br><span class="line">School one;</span><br><span class="line"></span><br><span class="line">python:</span><br><span class="line">one &#x3D; School()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ol>
<li><p><code>type</code>(变量) 打印变量的类型  </p>
</li>
<li><p>三个引号<code>&#39;&#39;&#39; &#39;&#39;&#39;</code>，三引号中间的变量可以换行，此外还有双引号和单引号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">email = <span class="string">'''</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">This is Fu JANG 's blog.</span></span><br><span class="line"><span class="string">Welcome to u.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(email)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Hello!</span><br><span class="line">This <span class="keyword">is</span> Fu JANG <span class="string">'s blog.</span></span><br><span class="line"><span class="string">Welcome to u.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">进程已结束,退出代码0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于第二点的代码（三引号）<code>email[0]</code>就是<code>H</code>，<code>email[-1]</code>就是<code>换行符</code>，<code>email[-2]</code>就是<code>.</code>，而对于以下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">email = <span class="string">'Hello'</span></span><br><span class="line">print(email[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">o</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[0:3]</code>左闭右开<br><code>[0:]</code> 0到末尾<br><code>[:3]</code>与第一个等效<br><code>[:]</code> 全部</p>
</li>
<li><p><code>f&#39;{变量名}’</code>  占位符，程序会用对应变量的值去填充大括号  </p>
</li>
<li><p><code>len()</code>  返回字符串的长度</p>
</li>
<li><p><code>.upper()</code>把字符串中字母全部转 为大写，但不改变原字符串<br><code>.lower()</code>把字符串中字母全部转为小写，但不改变原字符串<br><code>.title()</code>把字符串中单词首字母字母全部转为大写，但不改变原字符串<br> <code>.find(&#39;&#39;)</code>找到这个字符在字符串中的第一个索引<br> 若<code>&#39;&#39;</code>中为一串字符，则返回第一个字符的索引<br> 若<code>&#39;&#39;</code>中的字符在字符串中不存在，则返回<code>-1</code><br> <code>.replace(&#39;原&#39;, &#39;新&#39;)</code> 若字符串中没有原字符，则不替换</p>
</li>
<li><p><code>&#39; &#39; in 变量</code> 返回一个布尔值，代表该字符是否在此变量中  </p>
</li>
<li><p><code>round()</code>四舍五入<br><code>abs()</code>取绝对值</p>
</li>
<li><p>引用模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">print(math.ceil(<span class="number">2.9</span>)) 封</span><br><span class="line">print(math.floor(<span class="number">2.9</span>)) 底</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if</code>语句：<br><code>if:</code><br><code>elif:</code><br><code>else:</code>  </p>
</li>
<li><p>逻辑运算符：<br><code>and or not</code>   </p>
</li>
<li><p><code>while</code>循环，当条件不符合时，执行<code>else</code>，<code>break</code>的程序不执行<code>else</code><br><code>while:</code><br><code>else:</code>  </p>
</li>
<li><p><code>range(10)</code> <code>0</code>到<code>9</code><br><code>range(5,10)</code> <code>5</code>到<code>9</code><br><code>range(5,10,2)</code> <code>5,7,9</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码：</span><br><span class="line">for item in range(10):</span><br><span class="line">	print(item)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表：方括号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	[1,2,3],</span><br><span class="line">	[4,5,6],</span><br><span class="line">	[7,8,9]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表定义的方法<br><code>.append()</code> 在最后面插入<br> <code>.insert(0,10)</code> 在索引为0的位置加10<br> <code>.remove(5)</code> 删除第一个5<br> <code>.clear()</code> 清空列表<br> <code>.pop()</code> 删最后<br> <code>.index(5)</code> 传第一个5的索引<br> <code>.count(5)</code> 传5的个数<br> <code>.sort()</code> 不返回值，从小到大排序<br> <code>.reverse()</code> 从大到小排序<br> <code>.copy()</code> 复制</p>
</li>
<li><p><code>(,,)</code> 元组 不可变<br><code>.count()</code> 计数<br><code>.index()</code> 传索引  </p>
</li>
<li><p>压缩属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; (1,2,3)</span><br><span class="line">x, y, z &#x3D; m</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">customer = &#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"FuJANG"</span>,</span><br><span class="line">    <span class="string">"sex"</span> : <span class="string">"man"</span>,</span><br><span class="line">    <span class="string">"address"</span> : <span class="string">"China"</span>,</span><br><span class="line">    <span class="string">"age"</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">"is_handsome"</span> : <span class="literal">True</span></span><br><span class="line">&#125;</span><br><span class="line">print(customer[<span class="string">"name"</span>])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">FuJANG</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字典定义的方法<br><code>.get(&quot; &quot;)</code> 若键不存在则返回<code>None</code><br><code>.get(&quot;key&quot;, &quot;value&quot;)</code> 提供一个默认的值，并不修改字典，当在字典中对应的<code>key</code>存在时，默认值无效<br>可用此形式更改、添加字典<code>[&quot; &quot;] = &quot; &quot;</code></p>
</li>
<li><p>表示形式<br>列表<code>[ , , ]</code><br>元组<code>( , , )</code><br>字典<code>{  , , }</code>  </p>
</li>
<li><p><code>abc = &quot;字符串”</code><br><code>for ch in abc:</code>遍历字符串中的所有字符<br><code>abc.split(&quot;空格&quot;)</code> 根据空格分割字符串中的单词并储存在一个列表中</p>
</li>
</ol>
<h2 id="函数与模块"><a href="#函数与模块" class="headerlink" title="函数与模块"></a>函数与模块</h2><ol>
<li><p>定义一个函数<br> 每个函数后最好加上两个空行（标准格式），先定义函数后才可引用，<code>()</code>中可以加参数，如<code>(name)</code>,调用时需要传一个值如<code>(&quot;Mosh&quot;)</code>，关键字参数一般放在最后<br> 没有<code>return</code>的函数默认返回<code>None</code><br> 当<code>return x, y</code>时，<code>python</code>把<code>x, y</code>解释为一个元组<code>(x, y)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">()</span>:</span></span><br><span class="line">	内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>try...expect</code>来处理异常错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	×××</span><br><span class="line">expect 错误类型:</span><br><span class="line">	×××</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>class</code>定义一个类，首字母大写，不用下划线<br>  <code>def</code>定义一个函数，首字母小写，用下划线链接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> ×××<span class="params">(self, ×××)</span>:</span></span><br><span class="line">		×××</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> ×××</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">用类声明对象</span></span><br><span class="line">point1 = Point()</span><br><span class="line">调用定义的方法</span><br><span class="line">point1.×××()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以在程序的任何位置设置属性，属性没有必要一定在类里定义</span><br><span class="line">point1.属性名 = <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>python</code>中的构造函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">		self.x = x</span><br><span class="line">		self.y = y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">point1 = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承：当一个类中没有任何东西时，为了规范格式，通常加一个<code>pass</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normal</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></span><br><span class="line">		×××</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Normal)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Normal)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"×××"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hello</span><br><span class="line">hello.×××()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> ×××</span><br><span class="line">×××()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">as</span> he</span><br><span class="line">he.×××()</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立一个包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">① New → Directory → __init__.py</span><br><span class="line">② New → Python Package</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> 包.文件</span><br><span class="line">包.文件.函数()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 包.文件 <span class="keyword">import</span> 函数</span><br><span class="line">函数()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 包 <span class="keyword">import</span> 文件</span><br><span class="line">文件.函数()</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置模块的调用举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># randint 为闭区间</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.random() 随机跳出一个<span class="number">0</span>和<span class="number">1</span>间的数字</span><br><span class="line">random.randint(<span class="number">10</span>, <span class="number">20</span>) <span class="number">10</span>到<span class="number">20</span>间的一个整数值</span><br><span class="line">random.choice(numbers) 假如numbers是一个列表，则随机跳出列表中的一个元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置模块与下载模块<br><code>python</code>中有内置模块，当找不到想使用的模块时，可以去<code>pypi.org</code>寻找相应的模块下载命令，然后在终端上用命令下载相应的模块</p>
</li>
</ol>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0x01位运算</title>
    <url>/2020/05/28/0x01%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x01-位-运-算"><a href="#0x01-位-运-算" class="headerlink" title="0x01 位 运 算"></a>0x01 位 运 算</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>用<code>xor</code>表示异或运算，在<code>m</code>位二进制数中，通常称最低位为<code>0</code>位，从右到左依此类推，最高位为<code>m-1</code>位。</p>
</li>
<li><p><code>|-1|</code>的原码为<code>00000001</code><br><code>|-1|</code>的反码为<code>11111110</code><br><code>-1</code>的补码为<code>11111111</code>，十六进制表示为<code>0xff</code><br><code>8</code>位二进制对应的最大值<code>127</code>的十六进制表示为<code>0x7f</code><br>在计算机中数字以其补码的形式保存，正数的补码等于其原码，负数的补码等于其对应正数的原码取反码再<code>+1</code></p>
</li>
<li><p>对于<code>32</code>位二进制数<code>C</code>(设十进制的值为<code>S</code>)，其按位取反得到的编码<code>~C</code>对应的十进制的值为<code>-1-S</code>(正负都满足此规律)</p>
</li>
<li><p>补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在<code>32</code>位补码下做最高位不进位的二进制加减法运算。发生算术溢出时，<code>32</code>位无符号整数相当于自动对<code>2^32</code>取模，这也解释了有符号整数溢出时为何会出现负数的现象。</p>
</li>
<li><p>在算法竞赛中常用十六进制来表示一个常数，这样书写需要八个字符。<br>| 10进制 | 16进制 |<br>| :-: | :-: |<br>| 21 4748 3647 | 0x7f ff ff ff |<br>| 10 6110 9567 | 0x3f 3f 3f 3f |<br>| -1 | 0xff ff ff ff | </p>
</li>
<li><p><code>4</code>个字节的<code>int</code>表示的最大值为<code>21 4748 3647</code><br><code>4</code>个字节的<code>unsigned int</code>表示的最大值为<code>42 9496 7295</code> </p>
</li>
<li><p><code>0x3f 3f 3f 3f</code>是一个很有用的值，它满足两个条件：<br>其一，整数的两倍不超过int能表示的最大正整数<br>其二，二进制下每八位都相同<br>因此，我们可以用<code>memset(a, 0x3f, sizeof a)</code>来给<code>a</code>数组的每一个元素都赋值为正无穷，虽然<code>0x7f</code>能给每一个元素赋值成最大，但是为了避免溢出情况，推荐用<code>0x3f</code>。</p>
<ol>
<li><code>1 &lt;&lt; n = 2^n, n &lt;&lt; 1 = 2n</code><br><code>n &gt;&gt; 1 = n / 2.0 向下取整</code><br>需要注意的是，整数做<code>/</code>运算执行的是向<code>0</code>取整<br><code>(-3) &gt;&gt; 1 = -2, (-3) / 2 = -1</code></li>
</ol>
</li>
<li><p>除非特殊提示，我们默认右移采用的是算术右移的实现方式</p>
<blockquote>
<p>逻辑右移不考虑符号位，右移一位，左边补零即可。<br> 算术右移考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。<br> 所以算术右移也可以进行有符号位的除法,右移n位就等于除2的n次方。<br> 例如，8位二进制数11001101分别右移一位。<br> 逻辑右移就是[0]1100110<br> 算术右移就是[1]1100110  </p>
</blockquote>
</li>
</ol>
<h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><p>二进制状态压缩是指将一个长度为<code>m</code>的<code>bool</code>数组用一个<code>m</code>位二进制整数表示并存储的方法，利用如下操作实现对原<code>bool</code>数组对应下标元素的存取。  </p>
<ol>
<li>取出整数<code>n</code>的第<code>k</code>位：<code>(n&gt;&gt;k)&amp;1</code></li>
<li>取出整数<code>n</code>的后<code>k</code>位<code>(0到k-1位)</code>：<code>((1&lt;&lt;K)-1)&amp;n</code></li>
<li>把整数<code>n</code>的第<code>k</code>位反转：<code>(1&lt;&lt;k) nor n</code></li>
<li>把整数<code>n</code>的第<code>k</code>位赋值为<code>1</code>：<code>(1&lt;&lt;k)|n</code>  </li>
<li>把整数<code>n</code>的第<code>k</code>位赋值为<code>0</code>：<code>(~(1&lt;&lt;k))&amp;n</code>  </li>
</ol>
<p>当<code>m</code>不大时，我们可以使用一个整数存储，当m很大时，我们可以用若干个整数存储<code>(int数组)</code>，也可以用<code>C++STL</code>为我们提供的<code>bitset</code>实现。</p>
<h2 id="成对变换"><a href="#成对变换" class="headerlink" title="成对变换"></a>成对变换</h2><p>通过计算可发现，对于非负整数<code>n</code>:  </p>
<ol>
<li>当<code>n</code>为偶数时，<code>n xor 1 = n + 1</code></li>
<li>当<code>n</code>为奇数时，<code>n xor 1 = n - 1</code></li>
</ol>
<p>因此<code>0与1</code>, <code>2与3</code>, <code>4与5</code> … 关于<code>xor 1</code>运算构成成对变换。  </p>
<p>这一性质经常用于图论邻接表中边集的存储。在具有无向边(双向边)的图中把一对正反方向的边分别存储在邻接表数组的第<code>n</code>与<code>n+1</code>位置(其中<code>n</code>为偶数)，就可以通过<code>xor 1</code>的运算获得与当前边<code>(x,y)</code>反向的边<code>(y,x)</code>的存储位置。</p>
<h2 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h2><p><code>lowbit(n)</code>定义为非负整数<code>n</code>在二进制表示下“最低位的1及其后边所有的0”构成的数值。  </p>
<p>例子：<code>lowbit(10)=2</code>  </p>
<p>其原理为：<code>lowbit(n)=n&amp;(~n-1)=n&amp;(-n)</code></p>
<p><code>lowbit</code>运算配合<code>Hash</code>可以找出整数二进制下所有是<code>1</code>的位，所花费的时间与<code>1</code>的个数同级。为了达到这个目的，我们只需要不断把<code>n</code>赋值为<code>n-lowbit(n)</code>直至<code>n=0</code>。我们可以把每次减去的数(其一定为2的幂)求<code>log</code>得到对应的<code>1</code>所在的位数，因为<code>C++math.h</code>库中的<code>log</code>函数复杂度常数较大，所以我们可以预处理一个数组，通过<code>Hash</code>的方法代替<code>log</code>运算。  </p>
<p>此外<code>lowbit</code>运算也是树状数组中的一个基本运算。</p>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x06倍增</title>
    <url>/2020/06/03/0x06%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x06倍增"><a href="#0x06倍增" class="headerlink" title="0x06倍增"></a>0x06倍增</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>倍增，字面意思就是“成倍的增长”。这是指我们在进行递推时，如果状态空间很大，通常的线性递推无法满足时间与空间复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间中在<code>2</code>的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过“任意整数可以表示成若干个<code>2</code>的次幂项的和”这一性质 ，使用之前求出的代表值拼成所需的值。所以使用倍增算法也要求我们递推的问题的状态空间关于<code>2</code>的次幂具有可划分性  </p>
<p>“倍增”与“二进制划分”两个思想相互结合，降低了求解很多问题的时间与空间复杂度。我们之前学习的快速幂其实就是“倍增”与“二进制划分”思想的一种体现。在此文章中，我们研究序列上的倍增问题，包括求解<code>RMQ</code>（区间最值）问题的<code>ST</code>算法，关于求解最近公共祖先<code>LCA</code>等在树上的倍增应用，我将在后续文章进行探讨   </p>
<p>试想这样一个问题：给定一个长度为<code>N</code>的数列<code>A</code>，然后进行若干次询问，每次给定一个整数<code>T</code>，求出最大的<code>k</code>，满足数列<code>A</code>中前<code>k</code>个数的和小于等于<code>T</code>。你的算法必须是在线的（必须即时回答每一个询问，不能等待收到所有询问后再统一处理），假设<code>T</code>小于等于数组<code>A</code>中所有数的和  </p>
<p>朴素做法当然是从前向后枚举<code>K</code>，每次询问花费的时间与答案的大小有关，最坏情况为<code>O(N)</code>  </p>
<p>如果我们能够先花费<code>O(N)</code>的时间预处理<code>A</code>数组的前缀和数组<code>S</code>，就可以二分<code>K</code>的位置，比较<code>S[K]</code>与<code>T</code>的大小来确定二分上下界的变化，每次询问花费的时间都是<code>O(logN)</code>。这个算法在平均情况下表现很好，但是它的缺点是如果每次询问给定的整数<code>T</code>都非常小，造成答案<code>K</code>也非常小，那么该算法可能还不如从前往后枚举更优（因为假如每次只怼前<code>3</code>个，此时<code>O(log)</code>的算法可能不如<code>O(3)</code>的好）   </p>
<p>我们可以设计这样一种倍增算法：  </p>
<ol>
<li>令<code>p=1</code>，<code>k=0</code>，<code>sum=0</code>  </li>
<li>比较<code>A</code>数组中<code>k</code>之后的<code>p</code>个数的和与<code>T</code>的关系，也就是说，如果<code>sum+S[k+p]-S[k]&lt;=T</code>，则令<code>sum+=S[k+p]-S[k]</code>，<code>k+=p</code>，<code>p*=2</code>，即累加上<code>p</code>个数的和，然后把<code>p</code>的跨度增长一倍，如果<code>sum+S[k+p]-S[k]&gt;T</code>，则另<code>p/=2</code>  </li>
<li>重复上一步，直至<code>p</code>的值变为<code>0</code>，此时<code>k</code>就是答案  </li>
</ol>
<p>这个算法始终在答案大小的范围内实施“倍增”与“二进制划分”的思想，通过若干长度为<code>2</code>的次幂的区间拼成最后的<code>k</code>，时间复杂度级别为答案的对数，能够应对<code>T</code>的各种大小情况  </p>
<h2 id="ACWING109-天才ACM"><a href="#ACWING109-天才ACM" class="headerlink" title="ACWING109.天才ACM"></a><a href="https://www.acwing.com/problem/content/111/" target="_blank" rel="noopener">ACWING109.天才ACM</a></h2><p>首先，对于一个集合<code>S</code>，显然应该取<code>S</code>中最大的<code>M</code>个数和最小的<code>M</code>个数，最大的和最小的构成一对、次大和次小构成一对…这样求出的校验值最大。而为了让数组<code>A</code>分成的段数最少，每一段都应该在校验值不超过<code>T</code>的情况下，尽量包含更多的数，所以我们从头开始对<code>A</code>进行分段，让每一段尽量长，到达结尾时分成的段数就是答案   </p>
<p>于是，需要解决的问题是：当确定一个左端点<code>L</code>之后，右端点<code>R</code>在满足<code>A[L]到A[R]</code>的校验值不超过<code>T</code>的前提下，最大能取到多少   </p>
<p>求长度为<code>N</code>的一段校验值需要排序配对，时间复杂度为<code>O(NlogN)</code>。当校验值上限<code>T</code>比较小时，如果在整个<code>L到N</code>的区间二分右端点<code>R</code>，二分第一步就要检验<code>(N-L)/2</code>这么长的一段，最终右端点<code>R</code>却可能只扩展了一点儿，浪费了很多时间。与上一道题目一样，我们需要一个与右端点<code>R</code>扩展的长度相适应的算法———倍增   </p>
<p>可以采用与上一题类似的倍增过程：  </p>
<ol>
<li>初始化<code>p=1</code>，<code>R=L</code></li>
<li>求出<code>[L,R+p]</code>这一段区间的校验值，若检验值小于等于<code>T</code>，则<code>R+=P</code>，<code>p*=2</code>，否则<code>P/=2</code>   </li>
<li>重复上一步，直到<code>p</code>的值变为<code>0</code>，此时<code>R</code>即为所求  </li>
</ol>
<p><strong>代码</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">#define fir(i, a, b) for (int i &#x3D; a; i &lt;&#x3D; b; i++)</span><br><span class="line">#define sqr(a) (a) * (a)</span><br><span class="line">#define IOS                  \</span><br><span class="line">    ios::sync_with_stdio(0); \</span><br><span class="line">    cin.tie(0);              \</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 5e5 + 10;</span><br><span class="line">int n, m, p[N], ans, l, r;</span><br><span class="line">ll b[N], a[N], k;</span><br><span class="line"></span><br><span class="line">void merge(int l, int mid, int r) &#123;</span><br><span class="line">    int i &#x3D; l, j &#x3D; mid, k &#x3D; l;</span><br><span class="line">    while (i &lt; mid &amp;&amp; j &lt;&#x3D; r)</span><br><span class="line">        if (a[i] &lt;&#x3D; a[j])</span><br><span class="line">            b[k++] &#x3D; a[i++];</span><br><span class="line">        else</span><br><span class="line">            b[k++] &#x3D; a[j++];</span><br><span class="line">    while (i &lt; mid)</span><br><span class="line">        b[k++] &#x3D; a[i++];</span><br><span class="line">    while (j &lt;&#x3D; r)</span><br><span class="line">        b[k++] &#x3D; a[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check(int l, int mid, int r) &#123;</span><br><span class="line">    fir(i, mid, r)</span><br><span class="line">        a[i] &#x3D; p[i];</span><br><span class="line">    sort(a + mid, a + r + 1);</span><br><span class="line">    merge(l, mid, r);</span><br><span class="line">    ll sum &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; r - l + 1 &gt;&gt; 1 &amp;&amp; i &lt;&#x3D; m; i++)</span><br><span class="line">        sum +&#x3D; sqr(b[r - i + 1] - b[l + i - 1]);</span><br><span class="line">    if (sum &lt;&#x3D; k) &#123;</span><br><span class="line">        for (int i &#x3D; l; i &lt;&#x3D; r; i++)</span><br><span class="line">            a[i] &#x3D; b[i];</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    l &#x3D; r &#x3D; 0;</span><br><span class="line">    ans &#x3D; 0;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    fir(i, 1, n)</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void work() &#123;</span><br><span class="line">    int len &#x3D; 1;</span><br><span class="line">    l &#x3D; r &#x3D; 1;</span><br><span class="line">    a[l] &#x3D; p[l];</span><br><span class="line">    while (r &lt;&#x3D; n)</span><br><span class="line">        if (!len) &#123;</span><br><span class="line">            len &#x3D; 1;</span><br><span class="line">            ans++;</span><br><span class="line">            l &#x3D; (++r);</span><br><span class="line">            a[l] &#x3D; p[l];</span><br><span class="line">        &#125; else if (r + len &lt;&#x3D; n &amp;&amp; check(l, r + 1, r + len)) &#123;</span><br><span class="line">            r +&#x3D; len;</span><br><span class="line">            len &lt;&lt;&#x3D; 1;</span><br><span class="line">            if (r &#x3D;&#x3D; n)</span><br><span class="line">                break;</span><br><span class="line">        &#125; else</span><br><span class="line">            len &gt;&gt;&#x3D; 1;</span><br><span class="line">    if (r &#x3D;&#x3D; n)</span><br><span class="line">        ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    IOS;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        work();</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这题的代码差点儿把我杀死，不写了，未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hef994b8d2de64cc38bd77fc14c753637d.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x02递推与递归</title>
    <url>/2020/05/30/0x02%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x02递推与递归"><a href="#0x02递推与递归" class="headerlink" title="0x02递推与递归"></a>0x02递推与递归</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>一个实际问题的各种可能情况构成的集合通常称为“状态空间”，而程序的运行则是对状态空间的遍历</p>
<p>对于一个待求解的问题，当它局限在某处边界、某个小范围或者某种特殊情况下时，其答案往往是已知的。如果能够将该解答的应用场景扩大到原问题的状态空间，并且扩展过程的每个步骤具有相似性，就可以考虑使用递推或者递归求解</p>
<p>以已知的“问题边界”为起点向“原问题”正向推导的扩展方式就是递推。然而在很多时候，推导的路线难以确定，这时以“原问题”为起点尝试寻找把状态空间缩小到已知的“问题边界”路线，再通过该路线反向回溯的遍历方式就是递归  </p>
<p>使用递推或递归要求“原问题”与“问题边界”之间的每个变换步骤具有相似性，这样我们才能设计一段程序来实现该步骤，将其重复作用于问题之中。换句话说，程序在每个步骤上应该面对相同种类的问题，这些问题都是原问题的一个子问题，可能仅在规模或者某些限制条件上有所区别，并且能够使用“求解原问题的程序”进行求解</p>
<p>对于递归算法，有了上面这个前提，我们就可以让程序在每个变换步骤中执行三个操作：</p>
<ol>
<li>缩小问题状态空间的规模。这意味着程序尝试寻找在“原问题”与“问题边界”之间的变换路线，并向正在探索的路线迈出一步</li>
<li>尝试求解规模缩小以后的问题，结果可能是成功，也可能是失败</li>
<li>如果成功，即找到了规模缩小后的问题的答案，那么将答案扩展到当前问题；如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直至最终确定当前问题无法继续求解</li>
</ol>
<p>以上三个操作有两点特别关键：一是“如何尝试求解规模缩小以后的问题”。因为规模缩小以后的问题是原问题的一个子问题，所以我们可以把它视为一个新的原问题，由相同的程序进行求解，这就是所谓的“<strong>自身调用自身</strong>”；二是如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“<strong>回溯时还原现场</strong>”，关于递归与回溯，举一道简单的例题</p>
<h3 id="LEETCODES1457-二叉树中的伪回文路径"><a href="#LEETCODES1457-二叉树中的伪回文路径" class="headerlink" title="LEETCODES1457. 二叉树中的伪回文路径"></a><a href="https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">LEETCODES1457. 二叉树中的伪回文路径</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">    unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">    int pseudoPalindromicPaths(TreeNode* root) &#123;</span><br><span class="line">        cnt[root-&gt;val]++;</span><br><span class="line">        if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            int t &#x3D; 0;</span><br><span class="line">            for (auto item : cnt)</span><br><span class="line">                if (item.second % 2)</span><br><span class="line">                    t++;</span><br><span class="line">            cnt[root-&gt;val]--;</span><br><span class="line">            return t &lt;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        if (root-&gt;left) res +&#x3D; pseudoPalindromicPaths(root-&gt;left);</span><br><span class="line">        if (root-&gt;right) res +&#x3D; pseudoPalindromicPaths(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        cnt[root-&gt;val]--;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>y总原话：从这道题中我们可以看出<code>回溯时还原现场</code>的要求，每一次<code>return</code>之前都要记得恢复，有两次<code>return</code>，所以两次都要记得恢复。我们要记住一点：如果进来的时候修改了，那么在退出之前就应该恢复  </p>
</blockquote>
<p>重申：如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“<strong>回溯时还原现场</strong>”</p>
<h2 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a>递归总结</h2><p>可以看到，递归程序的基本单元是由“缩小”、“求解”、“扩展”组成的一种变换步骤，只是在“求解”时因为问题的相似性，不断重复使用了这样一种变换步骤，直至在一致的问题边界上直接确定答案。对于其中任意一条从“原问题”到“边界问题”的变换路线，横向来看，它跳的每一层是一次递归程序的执行；纵向来看，它的左右两边分别是寻找路线和沿其推导的流程。为了保证每层的“缩小”与“拓展”能够衔接在同一形式的问题上，“求解”操作自然要保证在执行前后程序面对的问题的状态是相同的，这也就是“还原现场”的必要性所在</p>
<h2 id="递推与递归的简单应用"><a href="#递推与递归的简单应用" class="headerlink" title="递推与递归的简单应用"></a>递推与递归的简单应用</h2><p>在使用枚举算法蛮力探索问题的整个”状态空间“时，经常需要递归。按照规模大小，有如下的几种常见的枚举形式和遍历方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">枚举形式</th>
<th style="text-align:center">状态空间规模</th>
<th style="text-align:center">一般遍历方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">多项式</td>
<td style="text-align:center">n^k k为常数</td>
<td style="text-align:center">循环(for)、递推</td>
</tr>
<tr>
<td style="text-align:center">指数</td>
<td style="text-align:center">k^n k为常数</td>
<td style="text-align:center">递归、位运算</td>
</tr>
<tr>
<td style="text-align:center">排列</td>
<td style="text-align:center">n!</td>
<td style="text-align:center">递归、C++next_permutation</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">C_n^m</td>
<td style="text-align:center">递归+减枝</td>
</tr>
</tbody>
</table>
</div>
<h2 id="递归的机器实现"><a href="#递归的机器实现" class="headerlink" title="递归的机器实现"></a>递归的机器实现</h2><p>一台典型的<code>32</code>位计算机采用“堆栈结构”来实现函数调用，它在汇编语言中，把函数所需的第<code>k</code>个、第<code>k-1</code>个，……，第<code>1</code>个参数依次入栈，然后执行<code>call(address)</code>指令。该指令把返回地址（当前语句的下一条语句地址）入栈，然后跳转到<code>address</code>位置的语句。在函数返回时，它执行<code>ret</code>指令。该指令把返回地址出栈，并跳转到该地址继续执行</p>
<p>对于函数中定义的<code>C++</code>局部变量，在每次执行<code>call</code>与<code>ret</code>指令时，也会在栈中相应的保存与复原，而作用范围超过该函数的变量，以及通过<code>new</code>和<code>malloc</code>函数动态分配的空间则保存在另一块成为<code>堆</code>的结构中。栈指针、返回值、局部的运算会借助<code>CPU</code>的“寄存器”完成</p>
<p>由此我们得知：</p>
<ol>
<li>局部变量在每层递归中都占有一份空间，声明过多或递归过深就会超出”栈“所能存储的范围，造成栈溢出</li>
<li>非局部变量对于各层递归都共享一份空间，需要及时维护、还原现场，以防止在各层递归之间存储和读取的数据相互影响</li>
</ol>
<p>了解了递归的及其实现之后，我们就可以使用模拟的方法，把递归程序改写为非递归程序。具体来说，我们可以用一个数组来模拟栈，使用变量来模拟栈指针和返回值，使用<code>switch/case</code>或者<code>goto/label</code>来模拟语句跳转</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治法把一个问题划分成若干个规模更小的同类子问题，对这些子问题递归求解，然后在回溯时通过它们推导出原问题的解</p>
<p><img src="https://ae01.alicdn.com/kf/H66237f88bb294f1db97200f8cd552ddbd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x04二分</title>
    <url>/2020/05/31/0x04%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x04二分"><a href="#0x04二分" class="headerlink" title="0x04二分"></a>0x04二分</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>二分的基础的用法是在单调序列或单调函数中进行查找，因此当问题的答案具有单调性时，就可以通过二分把求解问题转换为判定（根据复杂度理论，判定的难度小于求解），进一步地，我们还可以扩展到通过三分法去解决单峰函数的极值以及相关问题</p>
<p>对于整数域上的二分，需要注意中止边界、左右区间取舍时的开闭情况，避免漏掉答案或者造成死循环；对于实数域上的二分，需要注意精度问题</p>
<h2 id="整数集合上的二分"><a href="#整数集合上的二分" class="headerlink" title="整数集合上的二分"></a>整数集合上的二分</h2><p>本文章的写法保证最终答案处于闭区间<code>[l,r]</code>以内，循环以<code>l=r</code>结束，每次二分的中间值<code>mid</code>会归属于左半段与右半段二者之一</p>
<p><strong>模板如下</strong>：</p>
<p>在单调递增序列<code>a</code>中查找<code>&gt;=x</code>的数中最小的一个（<code>x</code>或<code>x</code>的后继）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (l &lt; r) &#123;</span><br><span class="line">    int mid &#x3D; (l + r) &gt;&gt; 1;</span><br><span class="line">    if (a[mid] &gt;&#x3D; x) r &#x3D; mid; else l &#x3D; mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">return a[l];</span><br></pre></td></tr></table></figure><br>在单调递增序列<code>a</code>中查找<code>&lt;=x</code>的数中最大的一个（<code>x</code>或<code>x</code>的前驱）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (l &lt; r) &#123;</span><br><span class="line">    int mid &#x3D; (l + r + 1) &gt;&gt; 1;</span><br><span class="line">    if (a[mid] &lt;&#x3D; x) l &#x3D; mid; else r &#x3D; mid - 1;</span><br><span class="line">&#125;</span><br><span class="line">return a[l];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如上面两段代码所示，这种二分写法可能会有两种形式：<br>1.缩小范围时，<code>r=mid</code>， <code>l=mid+1</code>，取中间值时，<code>mid=(l+r)&gt;&gt;1</code><br>2.缩小范围时，<code>l=mid</code>， <code>r=mid-1</code>，取中间值时，<code>mid=(l+r+1)&gt;&gt;1</code><br>如果不对<code>mid</code>的取法加以区分，假如第二段代码也采用<code>mid=(l+r)&gt;&gt;1</code>，那么当<code>r-l</code>等于<code>1</code>时，就有<code>mid=(l+r)&gt;&gt;1=l</code>，接下来若进入<code>l=mid</code>分支，可行区间未缩小，造成死循环；若进入<code>r=mid-1</code>分支，造成<code>l&gt;r</code>，循环不能以<code>l=r</code>结束；相反若<code>mid=(l+r+1)&gt;&gt;1</code> ，则第二段代码则正确得到结果。因此对两个形式采用配套的<code>mid</code>取法是必要的。此外还要注意：我们在二分实现中采用了右移运算符<code>&gt;&gt;1</code>，而不是整数除法<code>/2</code>。这是因为右移运算是向下取整，而整数除法是向<code>0</code>取整，在二分值域包含负数时后者不能正常工作。</p>
</blockquote>
<p><strong>我用一个例题来体现这两个模板的差别</strong>：<br><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">ACWING789.数的范围</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN &#x3D; 1e5 + 10;</span><br><span class="line">int nums[MAXN];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, q;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    while (q--) &#123;</span><br><span class="line">        int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">        int x;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            int mid &#x3D; (l + r) &gt;&gt; 1;</span><br><span class="line">            if (nums[mid] &gt;&#x3D; x) r &#x3D; mid; else l &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[l] !&#x3D; x) printf(&quot;-1 -1\n&quot;);</span><br><span class="line">        else &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; &quot; &quot;;</span><br><span class="line">            int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">            while (l &lt; r) &#123;</span><br><span class="line">                int mid &#x3D; (l + r + 1) &gt;&gt; 1;</span><br><span class="line">                if (nums[mid] &lt;&#x3D; x) l &#x3D; mid; else r &#x3D; mid - 1;</span><br><span class="line">            &#125;  </span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出这两个模板的另一个区别：当目标值不止一个时，第一个模板是取到左边，也就是在单调递增序列<code>a</code>中查找<code>&gt;=x</code>的数中最小的一个；第二个模板是取到右边，也就是在单调递增序列<code>a</code>中查找<code>&lt;=x</code>的数中最大的一个；当目标值只有只有一个时，两个模板的结果没有差别  </p>
<p>仔细分析这两种<code>mid</code>的取法，我们还发现：<code>mid=(l+r)&gt;&gt;1</code>不会取到<code>r</code>这个值，<code>mid=(l+r+1)&gt;&gt;1</code>不会取到<code>l</code>这个值，我们可以利用这一性质来处理无解的情况，把最初的二分区间分别扩大为<code>[1,n+1]</code>和<code>[0,n]</code>，把<code>a</code>数组的一个越界下标包含进来。如果最后二分终止于扩大后的这个越界下标上，则说明目标值不在<code>a</code>中；当然我们也可以直接看最终求得的<code>l</code>下标在<code>a</code>数组中对应的值是否为目标值  </p>
<p>二分的终止条件就是<code>l==r</code>，该值就是答案所在位置</p>
<p><code>C++STL</code>的<code>lower_bound</code>和<code>upper_bound</code>函数实现了在一个序列中二分查找某个整数<code>x</code>的后继</p>
<blockquote>
<p>未完待续</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>API之lowerer_bound/upper_bound用法</title>
    <url>/2020/06/02/API%E4%B9%8Blowerer-bound-upper-bound%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之lowerer-bound-upper-bound用法"><a href="#API之lowerer-bound-upper-bound用法" class="headerlink" title="API之lowerer_bound/upper_bound用法"></a>API之lowerer_bound/upper_bound用法</h1><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound()"></a>lower_bound()</h2><p><code>lower_bound(beg, end, val, comp)</code>  </p>
<p><strong>参数</strong>：</p>
<ol>
<li><p>一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是数组的首地址，只是用于比较的“首”地址）</p>
</li>
<li><p>一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）</p>
</li>
<li><p>就是一个要二分查找的那个数</p>
</li>
<li><p><code>greater&lt;int&gt;()</code>代表降序，<code>less&lt;int&gt;()</code>代表升序，默认是升序，也就是数组元素从小到大排列</p>
</li>
</ol>
<p><strong>返回值</strong>:</p>
<p>返回值就是返回第一次出现大于等于那个要查找的数的地址</p>
<p><strong>注意</strong>：</p>
<ol>
<li><p>返回值是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组的数组名，即这个数组的首地址,只有这样才代表那个要查找的数字的下标</p>
</li>
<li><p>那就是要大于等于那个数，等于好理解，大于怎么理解呢，比如说我并没有找到那个数，加入一个的数组里边就有5个数，分别是1,1,1,3,5,而我需要找的那个数就是2，怎么返回呢？就是返回那个第一个大于2的数的地址，就是返回3的地址，那么再有一组数据就是5个数1,1,1,3,3，还是需要找寻2，那么该返回什么呢？那就是第一个3的地址</p>
</li>
</ol>
<p><strong>示例</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int k, n &#x3D; 10;</span><br><span class="line">int a[10] &#x3D; &#123;1, 1, 1, 3, 3, 5, 5, 5, 5, 6&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;k)) &#123;</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; &quot;的第一个大于等于它的位置在&quot; &lt;&lt; ((lower_bound(a, a + n, k)) - a) + 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>结果</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 3 3 5 5 5 5 6 </span><br><span class="line">3</span><br><span class="line">3的第一个大于等于它的位置在4</span><br><span class="line">5</span><br><span class="line">5的第一个大于等于它的位置在6</span><br></pre></td></tr></table></figure></p>
<h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound()"></a>upper_bound()</h2><p><code>upper_bound</code>函数的用法<code>lower_bound</code>函数的用法相似，不过这个唯一的不同就是返回的是第一个比我要找的那个数大的数的地址，注意，这里并没有等于，也就是说如果在5个数1,1,2,2,4，里边寻找3，那么就会返回4的地址</p>
<p><strong>示例</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int k, n &#x3D; 10;</span><br><span class="line">int a[10] &#x3D; &#123;1, 1, 1, 3, 3, 5, 5, 5, 5, 6&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;k)) &#123;</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; &quot;的第一个大于它的位置在&quot; &lt;&lt; ((upper_bound(a, a + n, k)) - a) + 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>结果</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 3 3 5 5 5 5 6 </span><br><span class="line">5</span><br><span class="line">5的第一个大于它的位置在10</span><br><span class="line">1</span><br><span class="line">1的第一个大于它的位置在4</span><br></pre></td></tr></table></figure></p>
<h2 id="set和map中的upper-bound-lower-bound"><a href="#set和map中的upper-bound-lower-bound" class="headerlink" title="set和map中的upper_bound/lower_bound"></a>set和map中的upper_bound/lower_bound</h2><p>和上述一样的功能，不过其本身<code>class</code>内的放法比调用用外部的<code>upper_bound/lower_bound</code>效率高</p>
<h2 id="灵活使用"><a href="#灵活使用" class="headerlink" title="灵活使用"></a>灵活使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map&lt;int, int&gt; spfs;</span><br><span class="line">auto spf &#x3D; spfs.upper_bound(cows[i].second);</span><br><span class="line">spf--;</span><br></pre></td></tr></table></figure>
<p>这就实现了找小于等于<code>cows[i].second</code>的数中最大值的功能</p>
]]></content>
      <categories>
        <category>C/C++常用API</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>0x07贪心</title>
    <url>/2020/06/02/0x07%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x07贪心"><a href="#0x07贪心" class="headerlink" title="0x07贪心"></a>0x07贪心</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>贪心是一种在每次决策时采取当前意义下最优策略的算法，因此，使用贪心法要求问题的整体最优性可以由局部最优性导出。贪心算法的正确性需要证明，常见的证明手段有：  </p>
<ol>
<li>微扰（邻项交换）<br>证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果的变差，经常用于以“排序”为贪心策略的证明</li>
<li>范围缩放<br>证明任何对局部最优策略作用范围的扩展都不会造成整体结果的变差  </li>
<li>决策包容性<br>证明在任意局面下，做出局部最优策略以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略的可能性包含其他所有策略提供的可能性  </li>
<li>反证法</li>
<li>数学归纳法</li>
</ol>
<blockquote>
<p>我们通过几道例题来介绍贪心算法的应用</p>
</blockquote>
<h2 id="ACWING110-防晒"><a href="#ACWING110-防晒" class="headerlink" title="ACWING110.防晒"></a><a href="https://www.acwing.com/problem/content/112/" target="_blank" rel="noopener">ACWING110.防晒</a></h2><p>按照<code>minSPF</code>递减的顺序把奶牛排序，依次考虑每头奶牛  </p>
<p>对于每头奶牛，扫描一遍所有的防晒霜，在这头奶牛能用（能用指的是该防晒霜的强度符合这头奶牛的范围，并且瓶数还有剩余）的防晒霜里找<code>SPF</code>值最大的使用  </p>
<p>以上算法的贪心策略是在满足条件的前提下每次选择<code>SPF</code>最大的防晒霜，这个策略正确的原因是：我们考虑这一步策略的作用范围扩展到后续其他奶牛之后产生的影响。每瓶防晒霜是否可用，会被<code>minSPF</code>和<code>maxSPF</code>两个条件限制，因为奶牛已经按照<code>minSPF</code>递减排序，所以每一个不低于当前奶牛<code>minSPF</code>值的防晒霜，都不会低于后面其他奶牛的<code>minSPF</code>。也就是说，对于当前奶牛可用的任意两瓶防晒霜<code>x</code>和<code>y</code>，如果<code>SFP[X]&lt;SFP[y]</code>，那么后面的奶牛只可能出现三种情况之一  </p>
<ol>
<li><p><code>x</code>和<code>y</code>都能用<br><img src="https://ae01.alicdn.com/kf/H2cc96d8dff754e51a734da64de4234dd0.jpg" alt=""></p>
</li>
<li><p><code>x</code>和<code>y</code>都不能用<br><img src="https://ae01.alicdn.com/kf/H9ee214eba1ab4d3db7de671fcec790cfN.jpg" alt=""></p>
</li>
<li><p><code>x</code>能用，<code>y</code>不能用<br><img src="https://ae01.alicdn.com/kf/H956b6a5e4b7743629416b5c1c262da0bn.jpg" alt=""></p>
</li>
</ol>
<p>因此当前奶牛选择较大的<code>y</code>去用，对于整体的影响肯定比选择较小的<code>x</code>去用要好，另外，每头奶牛对答案的贡献至多是<code>1</code>，即使让当前奶牛放弃日光浴，留下防晒霜给后面的某一头奶牛去用，对答案的贡献也不会更大，综上所述，尽量满足当前的奶牛，并选择<code>SPF</code>值尽量大的防晒霜是一个正确的贪心策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 2510;</span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line">int n, m;</span><br><span class="line">PII cows[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    map&lt;int, int&gt; spfs;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        int spf, cover;</span><br><span class="line">        cin &gt;&gt; spf &gt;&gt; cover;</span><br><span class="line">        spfs[spf] +&#x3D; cover;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows, cows + n);</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    spfs[0] &#x3D; spfs[1001] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        auto spf &#x3D; spfs.upper_bound(cows[i].second);</span><br><span class="line">        spf--;</span><br><span class="line">        if (spf-&gt;first &gt;&#x3D; cows[i].first) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            if (--spf-&gt;second &#x3D;&#x3D; 0)</span><br><span class="line">                spfs.erase(spf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING111-畜栏预定"><a href="#ACWING111-畜栏预定" class="headerlink" title="ACWING111.畜栏预定"></a><a href="https://www.acwing.com/problem/content/113/" target="_blank" rel="noopener">ACWING111.畜栏预定</a></h2><p>按照开始吃草的时间把牛排序，用小根堆维护所有畜栏中最后一头牛结束吃草的时间的最小值，每循环到一头牛，如果这头牛的吃草开始时间比这个小根堆的堆顶大，则把这个牛插入到这个小根堆堆顶对应的畜栏中，再重新维护小根堆；如果小根堆的堆顶比这头牛的开始吃草时间大，则新建一个畜栏，插入到小根堆中</p>
<p>这种策略成功的原因在于：把每个畜栏的时间都充分利用，如果存在多个畜栏可以存放此牛，则选择最后一头牛结束吃草时间最小的畜栏，这样可以充分利用每个畜栏的时间；把每个牛的开始吃草时间从小到大排序的原因是，这样就可以让后面的牛插入在畜栏的后面，如果不排序，则每个畜栏前面可能有时间空隙放牛，这是不符合要求的，很难做出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line">const int N &#x3D; 50010;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int id[N];</span><br><span class="line">pair&lt;PII, int&gt; cows[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second;</span><br><span class="line">        cows[i].second &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows, cows + n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (heap.empty() || heap.top().first &gt;&#x3D; cows[i].first.first) &#123;</span><br><span class="line">            id[cows[i].second] &#x3D; heap.size() + 1;</span><br><span class="line">            heap.push(&#123;cows[i].first.second, heap.size() + 1&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            auto stall &#x3D; heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            stall.first &#x3D; cows[i].first.second;</span><br><span class="line">            id[cows[i].second] &#x3D; stall.second;</span><br><span class="line">            heap.push(stall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; heap.size() &lt;&lt; endl;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; id[i] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hef70c4f4a75e40738e47ea16124d9091W.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>0x01位运算例题</title>
    <url>/2020/05/29/0x01%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x01位运算例题"><a href="#0x01位运算例题" class="headerlink" title="0x01位运算例题"></a>0x01位运算例题</h1><blockquote>
<p>点击每道题题目即可获取原题链接</p>
</blockquote>
<h2 id="a-b"><a href="#a-b" class="headerlink" title="a^b"></a><a href="https://www.acwing.com/problem/content/91/" target="_blank" rel="noopener">a^b</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>long long</code>可以表示的最大值为<code>922 3372 0368 5477 5807</code><br><code>unsigned long long</code>可以表示的最大值为<code>1844 6744 0737 0955 1615</code>  </p>
<p>由此观之<code>a^b</code>大于<code>ULL</code>类型可以表示的最大值，所以要用快速幂的思想来求解这道题。</p>
<p><img src="https://ae01.alicdn.com/kf/H4fabba6e8a6644e88cb9ee4fe512f4ecH.jpg" alt=""><br>且取模的性质如下</p>
<ul>
<li>(a + b) % p = (a % p + b % p) % p</li>
<li>(a - b) % p = (a % p - b % p) % p </li>
<li>(a <em> b) % p = (a % p </em> b % p) % p </li>
<li>a ^ b % p = ((a % p)^b) % p </li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int power(int a, int b, int c) &#123;</span><br><span class="line">    int ans &#x3D; 1 % c;</span><br><span class="line">    for (; b; b &gt;&gt;&#x3D; 1) &#123;</span><br><span class="line">        if (b &amp; 1) ans &#x3D; (long long)ans * a % c;</span><br><span class="line">        a &#x3D; (long long)a * a % c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int a, b, p;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    int ans &#x3D; power(a, b, p);</span><br><span class="line">    printf(&quot;%d&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>我们可以用<code>b&amp;1</code>运算表示<code>b</code>的二进制下的最低位，并用<code>b&gt;&gt;1</code>来舍去最低位。在递归的过程中把<code>&gt;&gt;</code>和<code>&amp;</code>结合，其时间复杂度为<code>O(logb)</code></p>
<h2 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title="64位整数乘法"></a><a href="https://www.acwing.com/problem/content/92/" target="_blank" rel="noopener">64位整数乘法</a></h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL power(LL a, LL b, LL c) &#123;</span><br><span class="line">    LL ans &#x3D; 0;</span><br><span class="line">    for (; b; b &gt;&gt;&#x3D; 1) &#123;</span><br><span class="line">        if (b &amp; 1) ans &#x3D; (ans + a) % c;</span><br><span class="line">        a &#x3D; a * 2 % c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    LL a, b, p;</span><br><span class="line">    scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    LL ans &#x3D; power(a, b, p);</span><br><span class="line">    printf(&quot;%lld&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>我们可以用<code>b&amp;1</code>运算表示<code>b</code>的二进制下的最低位，并用<code>b&gt;&gt;1</code>来舍去最低位。在递归的过程中把<code>&gt;&gt;</code>和<code>&amp;</code>结合，其时间复杂度为<code>O(logb)</code>，与上一题不同的是位数问题，但是每次<code>%p</code>之后都能保证不超过<code>2*10^18</code>，在<code>long long</code>的范围内</p>
<h2 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a><a href="https://www.acwing.com/problem/content/93/" target="_blank" rel="noopener">最短Hamilton路径</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们可以采用朴素算法,其时间复杂度为<code>O(n*n!)</code>，<code>n!</code>为枚举<code>n</code>个点的全排列，<code>n</code>代表枚举路径的长度求得结果，这个算法的时间复杂度太高，不符合。而我们可以用二进制状态压缩<code>DP</code>来把时间复杂度优化到<code>O((n^2)*(2^n))</code>,我们用<code>F[i,j]</code>表示点被经过的状态对应二进制数<code>i</code>，且目前处于点<code>j</code>的最短路径   </p>
<p>在起点时<code>F[1,0]=0</code>，即目前处于点<code>0</code>且只经过了点<code>0</code>的最短路径为<code>0</code>。为方便起见，我们将数组中其他元素设为无穷大，最终目的是求<code>F[(1&lt;&lt;n),n-1]</code>的值，即经过所有点且最终处于<code>n-1</code>的最短路径</p>
<p>在任意时刻，有公式<code>F[i,j]=min(F[i,j],F[i^(1&lt;&lt;j),k]+weight[k,j])</code>，根据分析可得<code>k</code>一定是倒数第二个经过的点。我们枚举<code>k</code>，当<code>k</code>对应在<code>i</code>的二进制为<code>1</code>时，我们讨论这种情况并比较</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N &#x3D; 20, M &#x3D; 1 &lt;&lt; 20;</span><br><span class="line">int weight[N][N], F[M][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;weight[i][j]);</span><br><span class="line"></span><br><span class="line">    memset(F, 0x3f, sizeof F);</span><br><span class="line">    F[1][0] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; 1 &lt;&lt; n; i++)</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">            if (i &gt;&gt; j &amp; 1)</span><br><span class="line">                for (int k &#x3D; 0; k &lt; n; k++)</span><br><span class="line">                    if ((i ^ 1 &lt;&lt; j) &gt;&gt; k &amp; 1)</span><br><span class="line">                        F[i][j] &#x3D; min(F[i][j], F[i ^ 1 &lt;&lt; j][k] + weight[k][j]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;, F[(1 &lt;&lt; n) - 1][n - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还差一题，未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hdd96bb61417945ca90a15b8b5b98b5a1g.jpg" alt=""></p>
]]></content>
      <categories>
        <category>算法竞赛进阶指南</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>API之stringstream用法</title>
    <url>/2020/05/30/API%E4%B9%8Bstringstream%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之stringstream用法"><a href="#API之stringstream用法" class="headerlink" title="API之stringstream用法"></a>API之stringstream用法</h1><p>本文主要介绍 C++ 中 stringstream 类的常见用法。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><code>&lt;sstream&gt;</code>定义了三个类：<code>istringstream</code>、<code>ostringstream</code>和<code>stringstream</code>，分别用来进行流的输入、输出和输入输出操作。本文以<code>stringstream</code>为主，介绍流的输入和输出操作</p>
<p><code>&lt;sstream&gt;</code>主要用来进行数据类型转换，由于<code>&lt;sstream&gt;</code>使用<code>string</code>对象来代替字符数组（<code>snprintf</code>方式），就避免缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符的问题。简单说，相比c库的数据类型转换而言，<code>&lt;sstream&gt;</code>更加安全、自动和直接</p>
<h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h2><h3 id="2-1数据类型转换"><a href="#2-1数据类型转换" class="headerlink" title="2.1数据类型转换"></a>2.1数据类型转换</h3><p>这里展示一个代码示例，该示例介绍了将<code>int</code>类型转换为<code>string</code>类型的过程。示例代码（<code>stringstream_test1.cpp</code>）如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    string strResult;</span><br><span class="line">    int nValue &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将int类型的值放入输入流中</span><br><span class="line">    sstream &lt;&lt; nValue;</span><br><span class="line">    &#x2F;&#x2F; 从sstream中抽取前面插入的int类型的值，赋给string类型</span><br><span class="line">    sstream &gt;&gt; strResult;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;[cout]strResult is: &quot; &lt;&lt; strResult &lt;&lt; endl;</span><br><span class="line">    printf(&quot;[printf]strResult is: %s\n&quot;, strResult.c_str());</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[cout]strResult is: 1000   </span><br><span class="line">[printf]strResult is: 1000</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2多个字符串拼接"><a href="#2-2多个字符串拼接" class="headerlink" title="2.2多个字符串拼接"></a>2.2多个字符串拼接</h3><p>本示例介绍在<code>stringstream</code>中存放多个字符串，实现多个字符串拼接的目的（其实完全可以使用 <code>string</code>类实现），同时，介绍<code>stringstream</code>的清空方法。示例代码（<code>stringstream_test2.cpp</code>）如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将多个字符串放入 sstream 中</span><br><span class="line">    sstream &lt;&lt; &quot;first&quot;</span><br><span class="line">            &lt;&lt; &quot; &quot;</span><br><span class="line">            &lt;&lt; &quot;string,&quot;;</span><br><span class="line">    sstream &lt;&lt; &quot; second string&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 清空 sstream</span><br><span class="line">    sstream.str(&quot;&quot;);</span><br><span class="line">    sstream &lt;&lt; &quot;third string&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;After clear, strResult is: &quot; &lt;&lt; sstream.str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strResult is: first string, second string</span><br><span class="line">After clear, strResult is: third string</span><br></pre></td></tr></table></figure></p>
<p>从上述代码执行结果能够知道：</p>
<ul>
<li>可以使用<code>str()</code>方法，将<code>stringstream</code>类型转换为<code>string</code>类型</li>
<li>可以将多个字符串放入<code>stringstream</code>中，实现字符串的拼接目的</li>
<li>如果想清空<code>stringstream</code>，必须使用<code>sstream.str(&quot;&quot;)</code>; 方式:<code>clear()</code>方法适用于进行多次数据类型转换的场景。详见示例<code>2.3</code></li>
</ul>
<h3 id="2-3stringstream的清空"><a href="#2-3stringstream的清空" class="headerlink" title="2.3stringstream的清空"></a>2.3stringstream的清空</h3><p>清空<code>stringstream</code>有两种方法：<code>clear()</code>方法以及<code>str(&quot;&quot;)</code>方法，这两种方法有不同的使用场景。<code>str(&quot;&quot;)</code>方法的使用场景，在上面的示例中已经介绍了，这里介绍<code>clear()</code>方法的使用场景。示例代码（<code>stringstream_test3.cpp</code>）如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    int first, second;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插入字符串</span><br><span class="line">    sstream &lt;&lt; &quot;456&quot;;</span><br><span class="line">    &#x2F;&#x2F; 转换为int类型</span><br><span class="line">    sstream &gt;&gt; first;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在进行多次类型转换前，必须先运行clear()</span><br><span class="line">    sstream.clear();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 插入bool值</span><br><span class="line">    sstream &lt;&lt; true;</span><br><span class="line">    &#x2F;&#x2F; 转换为int类型</span><br><span class="line">    sstream &gt;&gt; second;</span><br><span class="line">    cout &lt;&lt; second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">456</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>注意：在本示例涉及的场景下（多次数据类型转换），必须使用<code>clear()</code>方法清空<code>stringstream</code>，不使用<code>clear()</code>方法或使用<code>str(&quot;&quot;)</code>方法，都不能得到数据类型转换的正确结果。下图分别是未使用<code>clear()</code>方法、使用<code>str(&quot;&quot;)</code>方法时的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">456</span><br><span class="line">4197008</span><br><span class="line"></span><br><span class="line">456</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="2-4测试"><a href="#2-4测试" class="headerlink" title="2.4测试"></a>2.4测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将多个字符串放入 sstream 中</span><br><span class="line">    sstream &lt;&lt; &quot;firstiiii&quot;</span><br><span class="line">            &lt;&lt; &quot; &quot;</span><br><span class="line">            &lt;&lt; &quot;string,&quot;;</span><br><span class="line">    sstream &lt;&lt; &quot; second string&quot;;</span><br><span class="line">    string a, b;</span><br><span class="line">    sstream &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    sstream &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; &quot;strResult is: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sstream.str();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strResult is: firstiiii</span><br><span class="line">strResult is: string,</span><br><span class="line">firstiiii string, second string</span><br></pre></td></tr></table></figure><br>由此可知，我们可以用它来分割字符串中的单词</p>
<h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h2><p><a href="https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">LEETCODE1455. 检查单词是否为句中其他单词的前缀</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">    int isPrefixOfWord(string sentence, string searchWord) &#123;</span><br><span class="line">        stringstream ssin(sentence);</span><br><span class="line"></span><br><span class="line">        string word;</span><br><span class="line">        for (int i &#x3D; 1; ssin &gt;&gt; word; i++)</span><br><span class="line">            if (word.substr(0, searchWord.size()) &#x3D;&#x3D; searchWord)</span><br><span class="line">                return i;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H0b4d4cb9ed5441f7b122f043b18076c9H.jpg" alt=""></p>
]]></content>
      <categories>
        <category>C/C++常用API</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 1100 1360C.Similar Pairs</title>
    <url>/2020/05/31/CODEFORCES1360C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360C-Similar-Pairs"><a href="#1360C-Similar-Pairs" class="headerlink" title="1360C.Similar Pairs"></a>1360C.Similar Pairs</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/problemset/problem/1360/C" target="_blank" rel="noopener">1360C.Similar Pairs</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>之后每两行为一组测试：  </p>
<p>第二行输入每组测试的元素个数  </p>
<p>第三行输入每组的元素  </p>
<p><strong>描述</strong>：当两个数奇偶相同或者绝对值相差<code>1</code>则称这两个数为<code>1</code>组，每次测试给你偶数个数，问所有元素是否有与它配对的数</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为一共有偶数个数，所以当奇数元素个数为偶数时，偶数元素个数也一定为偶数，则一定可以两两配对；如果奇数元素个数和偶数元素个数都为奇数时，检查是否存在一个奇数和一个偶数相减的绝对值为<code>1</code>的情况，如果存在这种情况，则一定可以两两配对，如果不存在，则不能两两配对</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int nums[55];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        memset(nums, 0, sizeof nums);</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;nums[i]);</span><br><span class="line">            if (nums[i] % 2)</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum % 2 &#x3D;&#x3D; 0) printf(&quot;YES\n&quot;);</span><br><span class="line">        else &#123;</span><br><span class="line">            sort(nums, nums+n);</span><br><span class="line">            int flag &#x3D; 0;</span><br><span class="line">            for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">                if (abs(nums[i] - nums[i - 1] &#x3D;&#x3D; 1)) &#123;</span><br><span class="line">                    printf(&quot;YES\n&quot;);</span><br><span class="line">                    flag &#x3D; 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag &#x3D;&#x3D; 0)</span><br><span class="line">                printf(&quot;NO\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES1100</tag>
        <tag>acm/greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 800 1360B.Honest Coach</title>
    <url>/2020/05/30/CODEFORCES1360B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360B-Honest-Coach"><a href="#1360B-Honest-Coach" class="headerlink" title="1360B.Honest Coach"></a>1360B.Honest Coach</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/problemset/problem/1360/B?csrf_token=6ef612f8a17a9c506cca94a69af1a61e" target="_blank" rel="noopener">1360B.Honest Coach</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>第二行输入队员个数</p>
<p><strong>描述</strong>：把队员分成两队，每队最少为<code>1</code>人，求<code>abs</code>|第一个队的最大值减去第二个队的最小值|最小</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心的思想，先排序，再贪心</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        vector&lt;int&gt; nums(n);</span><br><span class="line"></span><br><span class="line">        for (auto &amp;x : nums) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">        &#125;</span><br><span class="line">		    </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int result &#x3D; 0x3f3f3f3f;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            result &#x3D; min(result, abs(nums[i] - nums[i - 1]));</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>acm/greedy</tag>
        <tag>CODEFORCES800</tag>
      </tags>
  </entry>
  <entry>
    <title>API之to_string用法</title>
    <url>/2020/06/04/API%E4%B9%8Bto-string%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之to-string用法"><a href="#API之to-string用法" class="headerlink" title="API之to_string用法"></a>API之to_string用法</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string to_string (int val);</span><br><span class="line">string to_string (long val);</span><br><span class="line">string to_string (long long val);</span><br><span class="line">string to_string (unsigned val);</span><br><span class="line">string to_string (unsigned long val);</span><br><span class="line">string to_string (unsigned long long val);</span><br><span class="line">string to_string (float val);</span><br><span class="line">string to_string (double val);</span><br><span class="line">string to_string (long double val);</span><br></pre></td></tr></table></figure>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>将数值转化为字符串。返回对应的字符串。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string pi &#x3D; &quot;pi is &quot; + std::to_string(3.1415926);</span><br><span class="line">    string perfect &#x3D; to_string(1 + 2 + 4 + 7 + 14) + &quot; is a perfect number&quot;;</span><br><span class="line">    cout &lt;&lt; pi &lt;&lt; &#39;\n&#39;;</span><br><span class="line">    cout &lt;&lt; perfect &lt;&lt; &#39;\n&#39;;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi is 3.141593</span><br><span class="line">28 is a perfect number</span><br></pre></td></tr></table></figure><br><img src="https://ae01.alicdn.com/kf/H0b4d4cb9ed5441f7b122f043b18076c9H.jpg" alt=""></p>
]]></content>
      <categories>
        <category>C/C++常用API</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 1300 1360D.Buying Shovels</title>
    <url>/2020/05/31/CODEFORCES1360D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360D-Buying-Shovels"><a href="#1360D-Buying-Shovels" class="headerlink" title="1360D.Buying Shovels"></a>1360D.Buying Shovels</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://codeforces.com/problemset/problem/1360/D" target="_blank" rel="noopener">1360D.Buying Shovels</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>之后每一行为一组测试：  </p>
<p>每组测试输入两个数：<code>n</code>和<code>k</code></p>
<p><strong>描述</strong>：有<code>k</code>种包裹，第<code>i</code>个包裹里有<code>i</code>个铲子，只能选择一种包裹，可选这个包裹无限次，要求选择的包裹数最少，并且铲子和等于<code>n</code></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据数据范围可以看出是求质数问题，求<code>n</code>中的质数，要求此质数在<code>k</code>的范围内，<code>n/此质数</code>最小，意思就是选最大的可以除尽的包裹，得到的就是选择包裹数最少</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int n, k;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">        int ans &#x3D; n;</span><br><span class="line">        for (int i &#x3D; 1; i * i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            if (n % i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (i &lt;&#x3D; k)</span><br><span class="line">                    ans &#x3D; min(ans, n &#x2F; i);</span><br><span class="line">                if (n &#x2F; i &lt;&#x3D; k)</span><br><span class="line">                    ans &#x3D; min(ans, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES1300</tag>
        <tag>acm/math</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES 800 1360A.Minimal Square</title>
    <url>/2020/05/28/CODEFORCES1360A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1360A-Minimal-Square"><a href="#1360A-Minimal-Square" class="headerlink" title="1360A.Minimal Square"></a>1360A.Minimal Square</h1><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="http://codeforces.com/problemset/problem/1360/A" target="_blank" rel="noopener">1360A.Minimal Square</a></p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>第一行输入测试数目</p>
<p>从第二行开始依次输入每个测试样例的<code>a</code>和<code>b</code></p>
<p><strong>描述</strong>：<code>a</code>代表长，<code>b</code>代表宽，要求输出一个正方形的最小面积，这个正方形把两个相同的长方形(样例输入构成的长方形)覆盖，且这两个长方形不重合，每个长方形的边与正方形平行</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>求出长和宽的最小值乘以<code>2</code>，之后将所得的值与长和宽比较得出的最大值作为目标正方形的边长，再输出面积</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        int temp &#x3D; min(a, b);</span><br><span class="line">        int side &#x3D; 2 * temp;</span><br><span class="line">        int s &#x3D; pow(max(side, max(a, b)), 2);</span><br><span class="line">        printf(&quot;%d\n&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES800</tag>
        <tag>acm/math</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE10/PYTHON解法/正则表达式匹配</title>
    <url>/2020/06/05/LEETCODE10-PYTHON%E8%A7%A3%E6%B3%95-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.正则表达式匹配</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isMatch(self, s: str, p: str) -&gt; bool:</span><br><span class="line">        s, p &#x3D; &#39; &#39;+ s, &#39; &#39;+ p</span><br><span class="line">        lenS, lenP &#x3D; len(s), len(p)</span><br><span class="line">        dp &#x3D; [[0]*(lenP) for i in range(lenS)]</span><br><span class="line">        dp[0][0] &#x3D; 1</span><br><span class="line"></span><br><span class="line">        for j in range(1, lenP):</span><br><span class="line">            if p[j] &#x3D;&#x3D; &#39;*&#39;:</span><br><span class="line">                dp[0][j] &#x3D; dp[0][j-2]</span><br><span class="line"></span><br><span class="line">        for i in range(1, lenS):</span><br><span class="line">            for j in range(1, lenP):</span><br><span class="line">                if p[j] in &#123;s[i], &#39;.&#39;&#125;:</span><br><span class="line">                    dp[i][j] &#x3D; dp[i-1][j-1]</span><br><span class="line">                elif p[j] &#x3D;&#x3D; &quot;*&quot;:</span><br><span class="line">                    dp[i][j] &#x3D; dp[i][j-2] or int(dp[i-1][j] and p[j-1] in &#123;s[i], &#39;.&#39;&#125;)</span><br><span class="line"></span><br><span class="line">        return bool(dp[-1][-1])</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H0ba75266cb0440beb2cf8772fb0034c9O.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE1/PYTHON解法/两数之和</title>
    <url>/2020/06/03/LEETCODE1-PYTHON%E8%A7%A3%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1.两数之和</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        dic &#x3D; &#123;&#125;</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i] in dic:</span><br><span class="line">                return [dic[nums[i]], i]</span><br><span class="line">            else:</span><br><span class="line">                dic[target - nums[i]] &#x3D; i</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE3/PYTHON解法/无重复字符的最长子串</title>
    <url>/2020/06/03/LEETCODE3-PYTHON%E8%A7%A3%E6%B3%95-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3.无重复字符的最长子串</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        d &#x3D; &#123;&#125;</span><br><span class="line">        p1 &#x3D; p2 &#x3D; m &#x3D; 0</span><br><span class="line">        </span><br><span class="line">        while p2 &lt; len(s):</span><br><span class="line">            if s[p2] not in d:</span><br><span class="line">                d[s[p2]] &#x3D; True</span><br><span class="line">                p2 +&#x3D; 1</span><br><span class="line">                m &#x3D; max(len(d), m)</span><br><span class="line">            else:</span><br><span class="line">                del d[s[p1]]</span><br><span class="line">                p1 +&#x3D; 1</span><br><span class="line">            </span><br><span class="line">        return m</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>window</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO+BUTTERFLY搭建骚气且实用的个人网站</title>
    <url>/2020/05/27/HEXO-BUTTERFLY%E6%90%AD%E5%BB%BA%E9%AA%9A%E6%B0%94%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS.</p>
</blockquote>
<hr>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近狂刷<code>codeforces</code>，但是逐渐发现自身一个问题，那就是刷过的题虽然在当天感觉很明白，但是隔一天，隔两天，就发现自己再遇到此题时又是一翻鏖战，这就是说明自己做过的题吸收的效率不够高，于是我就打算做一道题总结一道题。那么问题来了，在哪里总结呢？</p>
<p>首先排除的是微信公众号，众所周知，微信公众号只能是自己分享东西的平台，而在这上面总结知识点就会引出很多问题，其一，每篇文章都要排版，其二，我的粉丝未必合此文章的胃口，其三，每天只能发布一篇文章，大大限制了自己的总结内容与时间分配。</p>
<p>那么诸如<code>csdn</code>、博客园、掘金、知乎这种东西呢？也有很多不方便的地方，比如文章左右侧的广告，实在影响人的心情，此外还有审核等等的制约，思前想后，我决定自己开辟一个个人网站。</p>
<p>当然不能从无到有手动开辟，自己能力有限，而且我的目的也是总结，总不能让自己以后把大把的时间浪费到维护网站上面去。于是我听从了大佬的建议，采用<code>hexo+github</code>的方式，<code>hexo</code>开辟网站，托管到<code>github</code>上面去。</p>
<p>花里胡哨的页面也是最吸引我的原因之一，我采用了<code>butterfly</code>的主题，绝对美炸天！</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程当然是心酸+心酸+心酸，心态险些被搞没。至于搭建网站的教程，实话实说，看了n多篇技术总结，都号称史上最全，到最后还是觉得看官方文档最省事。</p>
<p>当然自己也找到了一些好的文章，在此列出来希望对大家有帮助：</p>
<p><code>hexo</code>安装文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/a1a4ebf0e5fc" target="_blank" rel="noopener">Hexo+Butterfly+Github+Coding搭建个人博客</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="noopener">hexo官方文档</a></li>
</ul>
<p><code>butterfly</code>主题系列文章：</p>
<ol>
<li><a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(一)快速开始</a></li>
<li><a href="https://jerryc.me/posts/dc584b87/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(二)主题页面</a></li>
<li><a href="https://jerryc.me/posts/4aa8abbe/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(三)主题配置</a></li>
<li><a href="https://jerryc.me/posts/98d20436/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(四)主题问答、打赏名单</a></li>
<li><a href="https://jerryc.me/posts/198a4240/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(五)更新日誌</a></li>
</ol>
<h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><p>没日没夜的折腾了两天，总能从其中学到什么：其一，当然是收获了又骚又实用的好网站；其二，学会了<code>git</code>+<code>github</code>的基本使用，常见的<code>git</code>命令也记得很熟；其三，收获了一种精神——永不放弃，哪有什么一帆风顺，加油，骚年！</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>自己的网站弄的也不是很成熟，还有很多功能没有上线，比如日历、赞赏等，自己没有买域名，只是托管到<code>github</code>上。</p>
<h2 id="欢迎"><a href="#欢迎" class="headerlink" title="欢迎"></a>欢迎</h2><p><a href="https://haotianliu11.github.io/" target="_blank" rel="noopener">我的个人网站</a></p>
<hr>
<p><img src="https://imgkr.cn-bj.ufileos.com/148c824d-4eb8-48d3-9825-51625347b0f0.png" alt=""></p>
]]></content>
      <categories>
        <category>博客搭建历程</category>
      </categories>
      <tags>
        <tag>微信公众号文章——随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE5/PYTHON解法/最长回文串</title>
    <url>/2020/06/03/LEETCODE5-PYTHON%E8%A7%A3%E6%B3%95-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        p &#x3D; &#39;&#39;</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            p1 &#x3D; self.get_palindrome(s, i, i+1)</span><br><span class="line">            p2 &#x3D; self.get_palindrome(s, i, i)</span><br><span class="line">            p &#x3D; max([p, p1, p2], key&#x3D;lambda x: len(x))</span><br><span class="line">        return p</span><br><span class="line">    </span><br><span class="line">    def get_palindrome(self, s: str, l: int, r: int) -&gt; str:</span><br><span class="line">        while l &gt;&#x3D; 0 and r &lt; len(s) and s[l] &#x3D;&#x3D; s[r]:</span><br><span class="line">            l -&#x3D; 1</span><br><span class="line">            r +&#x3D; 1</span><br><span class="line">        return s[l+1:r]</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE2/PYTHON解法/两数相加</title>
    <url>/2020/06/03/LEETCODE2-PYTHON%E8%A7%A3%E6%B3%95-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2.两数相加</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy &#x3D; cur &#x3D;ListNode(0)</span><br><span class="line">        carry &#x3D; 0</span><br><span class="line">        while l1 or l2 or carry:</span><br><span class="line">            if l1:</span><br><span class="line">                carry +&#x3D; l1.val</span><br><span class="line">                l1 &#x3D; l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                carry +&#x3D; l2.val</span><br><span class="line">                l2 &#x3D; l2.next</span><br><span class="line">            cur.next &#x3D; ListNode(carry%10)</span><br><span class="line">            cur &#x3D; cur.next</span><br><span class="line">            carry &#x2F;&#x2F;&#x3D;10</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>ListNode</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE6/PYTHON解法/Z字形变换</title>
    <url>/2020/06/04/LEETCODE6-PYTHON%E8%A7%A3%E6%B3%95-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6.Z字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6.Z字形变换</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convert(self, S: str, R: int) -&gt; str:</span><br><span class="line">        if R &#x3D;&#x3D; 1 or R &gt; len(S):  # corner case</span><br><span class="line">            return S</span><br><span class="line">        res, i, step &#x3D; [&#39;&#39; for r in range(R)], 0, 0  # a string for each line</span><br><span class="line">        for s in S:</span><br><span class="line">            res[i] +&#x3D; s</span><br><span class="line">            if i &#x3D;&#x3D; 0:  # first row</span><br><span class="line">                step &#x3D; 1  # down</span><br><span class="line">            if i &#x3D;&#x3D; R - 1:  # last row</span><br><span class="line">                step &#x3D; -1  # up</span><br><span class="line">            i +&#x3D; step</span><br><span class="line">        return &quot;&quot;.join(res)</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE4/PYTHON解法/寻找两个正序数组的中位数</title>
    <url>/2020/06/03/LEETCODE4-PYTHON%E8%A7%A3%E6%B3%95-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4.寻找两个正序数组的中位数</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:</span><br><span class="line">        totalList &#x3D; nums1 + nums2</span><br><span class="line">        totalList.sort()</span><br><span class="line">        if len(totalList) % 2 &#x3D;&#x3D;0:</span><br><span class="line">            i &#x3D; totalList[len(totalList)&#x2F;&#x2F;2]</span><br><span class="line">            j &#x3D; totalList[len(totalList)&#x2F;&#x2F;2 - 1]</span><br><span class="line">            return (i+j)&#x2F;2</span><br><span class="line">        else:</span><br><span class="line">            return totalList[len(totalList)&#x2F;&#x2F;2]</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/He2534bd81da14f7cac54ae321362c2e1p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE7/PYTHON解法/整数反转</title>
    <url>/2020/06/04/LEETCODE7-PYTHON%E8%A7%A3%E6%B3%95-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7.整数反转</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x: int) -&gt; int:</span><br><span class="line">        result &#x3D; int(str(x)[::-1]) if x &gt;&#x3D; 0 else -int(str(x)[1:][::-1])</span><br><span class="line"></span><br><span class="line">        if -2**31 &lt;&#x3D; result &lt;&#x3D; (2**31)-1:</span><br><span class="line">            return result</span><br><span class="line">        else:</span><br><span class="line">            return 0</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE双周赛26</title>
    <url>/2020/06/04/LEETCODE%E5%8F%8C%E5%91%A8%E8%B5%9B26/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="LEETCODE双周赛26"><a href="#LEETCODE双周赛26" class="headerlink" title="LEETCODE双周赛26"></a>LEETCODE双周赛26</h1><h2 id="1446-连续字符"><a href="#1446-连续字符" class="headerlink" title="1446.连续字符"></a><a href="https://leetcode-cn.com/problems/consecutive-characters/submissions/" target="_blank" rel="noopener">1446.连续字符</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>双指针（滑动窗口）</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxPower(string s) &#123;</span><br><span class="line">        int maxn &#x3D; -0x3f3f3f3f;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size();) &#123;</span><br><span class="line">            int j &#x3D; i + 1;</span><br><span class="line">            while (j &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; s[j]) j++;</span><br><span class="line">            maxn &#x3D; max(maxn, j - i);</span><br><span class="line">            i &#x3D; j;</span><br><span class="line">        &#125;            </span><br><span class="line">        </span><br><span class="line">        return maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1447-最简分数"><a href="#1447-最简分数" class="headerlink" title="1447.最简分数"></a><a href="https://leetcode-cn.com/problems/simplified-fractions/" target="_blank" rel="noopener">1447.最简分数</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>gcd+遍历</p>
</blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int gcd(int x, int y) &#123;</span><br><span class="line">        return y ? gcd(y, x % y) : x;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; simplifiedFractions(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">                if (gcd(j, i) &#x3D;&#x3D; 1)</span><br><span class="line">                    result.push_back(to_string(i) + &quot;&#x2F;&quot; + to_string(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448.统计二叉树中好节点的数目"></a><a href="https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">1448.统计二叉树中好节点的数目</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>简简单单的dfs，记录遍历的节点的最大值</p>
</blockquote>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int goodNodes(TreeNode* root) &#123;</span><br><span class="line">        return dfs(root, INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int dfs(TreeNode* root, int maxn) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        int ans &#x3D; maxn &lt;&#x3D; root-&gt;val;</span><br><span class="line">        if (root-&gt;left) ans +&#x3D; dfs(root-&gt;left, max(maxn, root-&gt;val));</span><br><span class="line">        if (root-&gt;right) ans +&#x3D; dfs(root-&gt;right, max(maxn, root-&gt;val));</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1449-数位成本和为目标值的最大数字"><a href="#1449-数位成本和为目标值的最大数字" class="headerlink" title="1449.数位成本和为目标值的最大数字"></a><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">1449.数位成本和为目标值的最大数字</a></h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>完全背包</p>
</blockquote>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; cost, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; f(10, vector&lt;int&gt;(target + 1));</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; target; i++) f[0][i] &#x3D; -1e8;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++)</span><br><span class="line">            for (int j &#x3D; 0; j &lt;&#x3D; target; j++) &#123;</span><br><span class="line">                f[i][j] &#x3D; f[i - 1][j];</span><br><span class="line">                if (j &gt;&#x3D; cost[i - 1]) f[i][j] &#x3D; max(f[i][j], f[i][j - cost[i - 1]] + 1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        if (f[9][target] &lt; 1) return &quot;0&quot;;</span><br><span class="line">        string res;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 9, j &#x3D; target; i; i--)</span><br><span class="line">            while (j &gt;&#x3D; cost[i - 1] &amp;&amp; f[i][j] &#x3D;&#x3D; f[i][j - cost[i - 1]] + 1) &#123;</span><br><span class="line">                res +&#x3D; to_string(i);</span><br><span class="line">                j -&#x3D; cost[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hdd96bb61417945ca90a15b8b5b98b5a1g.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE周赛</category>
      </categories>
      <tags>
        <tag>LEETCODE周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中join函数的用法</title>
    <url>/2020/06/04/PYTHON%E4%B8%ADjoin%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中join函数的用法"><a href="#PYTHON中join函数的用法" class="headerlink" title="PYTHON中join函数的用法"></a>PYTHON中join函数的用法</h1><p>Python中有<code>.join()</code>和<code>os.path.join()</code>两个函数，具体作用如下：  </p>
<p><code>.join()</code>：连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串<br><code>os.path.join()</code>：将多个路径组合后返回</p>
<h2 id="对序列进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对序列进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对序列进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对序列进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;]</span><br><span class="line"></span><br><span class="line">&gt;&gt; &#39; &#39;.join(a)</span><br><span class="line"></span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line">&gt;&gt; &#39;&#39;.join(a)</span><br><span class="line"></span><br><span class="line">12345</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39;-&#39;.jion(a)</span><br><span class="line"></span><br><span class="line">1-2-3-4-5</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39;.&#39;.join(a)</span><br><span class="line"></span><br><span class="line">1.2.3.4.5</span><br></pre></td></tr></table></figure>
<h2 id="对字符串进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对字符串进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对字符串进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对字符串进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#x3D;&#39;hello world&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt; &#39; &#39;.join(b)</span><br><span class="line"></span><br><span class="line">h e l l o   w o r l d</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39;-&#39; .join(b)</span><br><span class="line"></span><br><span class="line">h-e-l-l-o- -w-o-r-l-d</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39;:&#39;.jion(b)</span><br><span class="line"></span><br><span class="line">h:e:l:l:o: :w:o:r:l:d</span><br></pre></td></tr></table></figure>
<h2 id="对元组进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对元组进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对元组进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对元组进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c&#x3D;(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39; &#39;.join(c)</span><br><span class="line"></span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39;-&#39;.join(c)</span><br><span class="line"></span><br><span class="line">1-2-3-4-5</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39;:&#39;.join(c)</span><br><span class="line"></span><br><span class="line">1:2:3:4:5</span><br></pre></td></tr></table></figure>
<h2 id="对字典进行无序操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对字典进行无序操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对字典进行无序操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对字典进行无序操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d&#x3D;&#123;&#39;name1&#39;:&#39;a&#39;,&#39;name2&#39;:&#39;b&#39;,&#39;name3&#39;:&#39;c&#39;,&#39;name4&#39;:&#39;d&#39;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39; &#39;.jion(d)</span><br><span class="line"></span><br><span class="line">name1 name2 name3 name4</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39;-&#39;.join(d)</span><br><span class="line"></span><br><span class="line">name1-name2-name3-name4</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#39;:&#39;.join(d)</span><br><span class="line"></span><br><span class="line">name1:name2:name3:name4</span><br></pre></td></tr></table></figure>
<h2 id="对目录进行操作"><a href="#对目录进行操作" class="headerlink" title="对目录进行操作"></a>对目录进行操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.path.join(&#39;&#x2F;hello&#x2F;&#39;,&#39;good&#x2F;date&#39;,&#39;datbody&#39;)</span><br><span class="line"></span><br><span class="line">hello&#x2F;good&#x2F;date&#x2F;datbody</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中max函数的lambda表达式用法</title>
    <url>/2020/06/03/PYTHON%E4%B8%ADmax%E5%87%BD%E6%95%B0%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中max函数的lambda表达式用法"><a href="#PYTHON中max函数的lambda表达式用法" class="headerlink" title="PYTHON中max函数的lambda表达式用法"></a>PYTHON中max函数的lambda表达式用法</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>由一道<code>leetcode</code>题来引入<code>PYTHON</code>中<code>max</code>函数的<code>lambda</code>表达式用法<br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        p &#x3D; &#39;&#39;</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            p1 &#x3D; self.get_palindrome(s, i, i+1)</span><br><span class="line">            p2 &#x3D; self.get_palindrome(s, i, i)</span><br><span class="line">            p &#x3D; max([p, p1, p2], key&#x3D;lambda x: len(x))</span><br><span class="line">        return p</span><br><span class="line">    </span><br><span class="line">    def get_palindrome(self, s: str, l: int, r: int) -&gt; str:</span><br><span class="line">        while l &gt;&#x3D; 0 and r &lt; len(s) and s[l] &#x3D;&#x3D; s[r]:</span><br><span class="line">            l -&#x3D; 1</span><br><span class="line">            r +&#x3D; 1</span><br><span class="line">        return s[l+1:r]</span><br></pre></td></tr></table></figure>
<p><code>max([p, p1, p2], key=lambda x: len(x))</code>的含义就是本文章的内容</p>
<h2 id="lambda表达式介绍"><a href="#lambda表达式介绍" class="headerlink" title="lambda表达式介绍"></a>lambda表达式介绍</h2><p>在学习<code>python</code>的过程中，<code>lambda</code>的语法时常会使人感到困惑，<code>lambda</code>是什么，为什么要使用<code>lambda</code>，是不是必须使用<code>lambda</code>？</p>
<ol>
<li><code>lambda</code>是什么？<br>我们来看此表达式：<code>g = lambda x:x+1</code>，看一下执行的结果：<code>g(1)==2</code>、<code>g(2)==3</code>,当然，你也可以这样使用：<code>lambda x:x+1(1)</code>，结果为<code>2</code><br>可以这样认为,<code>lambda</code>作为一个表达式，定义了一个匿名函数，上例的代码<code>x</code>为入口参数，<code>x+1</code>为函数体，用函数来表示为:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def g(x):</span><br><span class="line">    return x+1</span><br></pre></td></tr></table></figure></li>
<li><code>lambda</code>定义了一个匿名函数</li>
<li><code>lambda</code>并不会带来程序运行效率的提高，只会使代码更简洁</li>
<li>如果可以使用<code>for...in...if</code>来完成的，坚决不用<code>lambda</code></li>
<li>如果使用<code>lambda</code>，<code>lambda</code>内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。</li>
<li>总结：<code>lambda</code>是为了减少单行函数的定义而存在的</li>
</ol>
<h2 id="max函数中的lambda表达式"><a href="#max函数中的lambda表达式" class="headerlink" title="max函数中的lambda表达式"></a>max函数中的lambda表达式</h2><p>现在回到我们的max函数中，就十分容易理解了:<br>函数形式：<code>max( x ,key=lambda a : b )</code>，x可以是任何数值，可以有多个x值<br>这个函数的意思是：我们先把x值带入lambda函数转换成b值，然后再将b值进行比较<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">haha0&#x3D;max(&#39;az&#39;,&#39;za&#39;, key&#x3D;lambda a: a[0])</span><br><span class="line">haha1&#x3D;max(&#39;az&#39;,&#39;za&#39;, key&#x3D;lambda a: a[1])</span><br><span class="line">haha2&#x3D;max(range(10),key&#x3D;lambda a:a&gt;3)</span><br><span class="line"> </span><br><span class="line">print(haha0)        #输出za</span><br><span class="line">print(haha1)        #输出az</span><br><span class="line">print(haha2)        #输出4</span><br></pre></td></tr></table></figure></p>
<p>以<code>haha0</code>为例子：我们传入<code>az</code>，<code>za</code>，为了方便解释称之为虚拟比较，但是因为我们引入了<code>lambda</code>表达式，所以，我们实际上比较的是，<code>az</code>中的第一位<code>a</code>和<code>za</code>中第一位的<code>z</code>，由<code>ascii</code>码表可以知道<code>a</code>是小于<code>z</code>的，所以在这里最大的是<code>z</code>，那么我们返回的就是<code>z</code>的虚拟比较变量，也就是本来的<code>za</code>。</p>
<p><code>haha2</code>的用法十分少见，实际上比较的是:<br><code>F F F T T T T T T T ( False 和 True )</code></p>
<p><code>T</code>是肯定比<code>F</code>大的，但是一堆<code>True</code>哪里能互相比较大小呢，所以就输出第一个<code>True</code>值的虚拟比较变量，也就是<code>4</code></p>
<p><code>max</code>中带有<code>lambda</code>的这个写法的意义在于代码变得更简洁</p>
<p>假如我们有一个字典，里面记录着人名和相应年龄，现在我们想要在里面筛选出年龄最大的那个人的一条字典记录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;&#123;&quot;老王&quot; :18 , &quot;小李&quot;:99&#125;</span><br><span class="line">haha3&#x3D;max(x.items(), key&#x3D;lambda a: a[1])</span><br><span class="line">print(haha3)        #输出(&#39;小李&#39;, 99)</span><br></pre></td></tr></table></figure></p>
<p>要注意使用字典的话一定要x.items()，不能直接输入x值，达不到我们想要的效果   </p>
<p>其实我们大可不必这么写，直接从字典中提取出年龄列表进行比较：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;&#123;&quot;老王&quot; :18 , &quot;小李&quot;:99&#125;</span><br><span class="line">y&#x3D;[]</span><br><span class="line">for name,age in x.items():</span><br><span class="line">    y.append(age)</span><br><span class="line">haha4&#x3D;max(y)</span><br><span class="line">print(haha4)</span><br></pre></td></tr></table></figure></p>
<p>只是这样写是比较麻烦以及浪费内存的不是么？我想这就是<code>max</code>函数中设置<code>lambda</code>表达式的意义  </p>
<p>再举两个例子：    </p>
<ol>
<li>取第一维<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; [(1,2.5), (1.5, 3.2), (1.3, 4.0), (2.2, 1.8)]</span><br><span class="line">y,z &#x3D; max(num, key&#x3D;lambda x:x[0])</span><br><span class="line">print(y, z)      #结果为2.2 1.8</span><br></pre></td></tr></table></figure></li>
<li>取第二维<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; [(1,2.5), (1.5, 3.2), (1.3, 4.0), (2.2, 1.8)]</span><br><span class="line">y,z &#x3D; max(num, key&#x3D;lambda x:x[1])</span><br><span class="line">print(y, z)      #结果为1.3 4.0</span><br></pre></td></tr></table></figure>
<img src="https://ae01.alicdn.com/kf/H12f0feac72244f349b51fc9f740d048fh.jpg" alt=""></li>
</ol>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE9/PYTHON解法/回文数</title>
    <url>/2020/06/05/LEETCODE9-PYTHON%E8%A7%A3%E6%B3%95-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9.回文数</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:</span><br><span class="line">        orig &#x3D; x</span><br><span class="line">        back_x &#x3D; 0</span><br><span class="line">        while x &gt; 0:</span><br><span class="line">            back_x &#x3D; back_x * 10 + x % 10</span><br><span class="line">            x &#x2F;&#x2F;&#x3D; 10</span><br><span class="line">        return orig &#x3D;&#x3D; back_x</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H0ba75266cb0440beb2cf8772fb0034c9O.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE8/PYTHON解法/字符串转换整数</title>
    <url>/2020/06/04/LEETCODE8-PYTHON%E8%A7%A3%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8.字符串转换整数"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8.字符串转换整数</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, str: str) -&gt; int:</span><br><span class="line">        def helper(x):</span><br><span class="line">            if not x: return 0</span><br><span class="line">            ret &#x3D; 0</span><br><span class="line">            for i in x:</span><br><span class="line">                if not i.isdigit(): return ret</span><br><span class="line">                ret &#x3D; ret *10 + int(i)</span><br><span class="line">            return ret</span><br><span class="line"></span><br><span class="line">        s &#x3D; str.strip()</span><br><span class="line">        if not s: return 0</span><br><span class="line">        elif s[0] &#x3D;&#x3D; &#39;+&#39;: return min(2**31-1,helper(s[1:]))</span><br><span class="line">        elif s[0] &#x3D;&#x3D; &#39;-&#39;: return max(-2**31,-helper(s[1:]))</span><br><span class="line">        elif s[0].isdigit(): return min(2**31-1,helper(s))</span><br><span class="line">        else: return 0</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE/PYTHON</category>
      </categories>
      <tags>
        <tag>LEETCODE</tag>
        <tag>PYTHON</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础总结(2)</title>
    <url>/2020/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络基础总结-2"><a href="#计算机网络基础总结-2" class="headerlink" title="计算机网络基础总结(2)"></a>计算机网络基础总结(2)</h1><p>1. </p>
]]></content>
  </entry>
  <entry>
    <title>PYTHON中反转字符串的三种方法</title>
    <url>/2020/06/04/PYTHON%E4%B8%AD%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中反转字符串的三种方法"><a href="#PYTHON中反转字符串的三种方法" class="headerlink" title="PYTHON中反转字符串的三种方法"></a>PYTHON中反转字符串的三种方法</h1><h2 id="1-切片法（最简洁的一种）"><a href="#1-切片法（最简洁的一种）" class="headerlink" title="1.切片法（最简洁的一种）"></a>1.切片法（最简洁的一种）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def reverse1():</span><br><span class="line">    s &#x3D; input(&quot;请输入需要反转的内容：&quot;)</span><br><span class="line">    return s[::-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(reverse1())</span><br><span class="line"></span><br><span class="line">#运行结果</span><br><span class="line"></span><br><span class="line">请输入需要反转的内容：莺啼岸柳弄春晴 柳弄春晴夜月明</span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This is extended slice syntax. It works by doing [begin:end:step] - by leaving begin and end off and specifying a step of -1, it reverses a string.<br>这是扩展片语法。它的工作方式是[begin:end:step]-离开begin和end并指定步骤-1，它反转字符串。</p>
</blockquote>
<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def reverse2(s):</span><br><span class="line">    if s&#x3D;&#x3D;&quot;&quot;:</span><br><span class="line">        return s</span><br><span class="line">    else:</span><br><span class="line">        return reverse2(s[1:])+s[0]</span><br><span class="line">print(reverse2(&quot;莺啼岸柳弄春晴 柳弄春晴夜月明&quot;))</span><br><span class="line"></span><br><span class="line">#运行结果</span><br><span class="line"></span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<h2 id="3-借用列表的reverse-方法"><a href="#3-借用列表的reverse-方法" class="headerlink" title="3.借用列表的reverse()方法"></a>3.借用列表的reverse()方法</h2><blockquote>
<p>reverse()函数将列表的内容进行了反转，借助这个特性，可以先将字符串转换成列表，利用reverse()函数进行反转后，再处理成字符串。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def reverse3(s):</span><br><span class="line">    l&#x3D;list(s)</span><br><span class="line">    l.reverse()</span><br><span class="line">    return (&quot;&quot;.join(l))</span><br><span class="line">print(reverse3(&quot;莺啼岸柳弄春晴 柳弄春晴夜月明&quot;))</span><br><span class="line"></span><br><span class="line">#运行结果</span><br><span class="line"></span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点</title>
    <url>/2020/06/04/PYTHON%E4%B8%ADisdigit-%E3%80%81isalpha-%E3%80%81isalnum-%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点"><a href="#PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点" class="headerlink" title="PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点"></a>PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点</h1><h2 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit()"></a>isdigit()</h2><p><code>python</code>关于<code>isdigit()</code>内置函数的官方定义：  </p>
<blockquote>
<p>S.isdigit() -&gt; bool<br>        Return True if all characters in S are digits<br>        and there is at least one character in S, False otherwise.    </p>
</blockquote>
<p>翻译：</p>
<p><code>S.isdigit()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>字符串中至少有一个字符且如果<code>S</code>中的所有字符都是数字，那么返回结果就是<code>True</code>；否则，就返回<code>False</code>   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S1 &#x3D; &#39;12345&#39;       #纯数字</span><br><span class="line">S2 &#x3D; &#39;①②&#39;          #带圈的数字</span><br><span class="line">S3 &#x3D; &#39;汉字&#39;        #汉字</span><br><span class="line">S4 &#x3D; &#39;%#￥&#39;        #特殊符号</span><br><span class="line">S5 &#x3D; &#39;12345a&#39;      #数字和字母</span><br><span class="line"></span><br><span class="line">print(S1.isdigit())</span><br><span class="line">print(S2.isdigit())</span><br><span class="line">print(S3.isdigit())</span><br><span class="line">print(S4.isdigit())</span><br><span class="line">print(S5.isdigit())</span><br><span class="line"></span><br><span class="line"># 执行结果：</span><br><span class="line">True     </span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h2 id="isalpha"><a href="#isalpha" class="headerlink" title="isalpha()"></a>isalpha()</h2><p><code>python</code>关于<code>isalpha()</code>内置函数的官方定义：</p>
<blockquote>
<p>S.isalpha() -&gt; bool<br>        Return True if all characters in S are alphabetic<br>        and there is at least one character in S, False otherwise.</p>
</blockquote>
<p>翻译：<br><code>S.isalpha()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>字符串中至少有一个字符且如果S中的所有字符都是字母，那么返回结果就是<code>True</code>；否则，就返回<code>False</code>   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S1 &#x3D; &#39;abc汉字&#39;     #汉字+字母</span><br><span class="line">S2 &#x3D; &#39;ab字134&#39;     #包含数字</span><br><span class="line">S3 &#x3D; &#39;*&amp;&amp;&#39;         #特殊符号</span><br><span class="line"></span><br><span class="line">print(S1.isalpha())</span><br><span class="line">print(S2.isalpha())</span><br><span class="line">print(S3.isalpha())</span><br><span class="line"></span><br><span class="line">#执行结果</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h2 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum()"></a>isalnum()</h2><p><code>python</code>关于<code>isalnum()</code>内置函数的官方定义：  </p>
<blockquote>
<p>S.isalnum() -&gt; bool<br>        Return True if all characters in S are alphanumeric<br>        and there is at least one character in S, False otherwise.</p>
</blockquote>
<p>翻译：  </p>
<p><code>S.isalnum()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>中至少有一个字符且如果<code>S</code>中的所有字符都是字母数字，那么返回结果就是<code>True</code>；否则，就返回<code>False</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S1 &#x3D; &#39;abc汉字1&#39;    #字母+汉字+数字</span><br><span class="line">S2 &#x3D; &#39;①②③&#39;      #带圈的数字</span><br><span class="line">S3 &#x3D; &#39;%……&amp;&#39;       #特殊符号</span><br><span class="line"></span><br><span class="line">print(S1.isalnum())</span><br><span class="line">print(S2.isalnum())</span><br><span class="line">print(S3.isalnum())</span><br><span class="line"></span><br><span class="line">#执行结果</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p><code>python</code>官方定义中的字母：大家默认为英文字母+汉字即可</p>
</li>
<li><p><code>python</code>官方定义中的数字：大家默认为<code>Unicode</code>数字、<code>byte</code>数字（单字节）、全角数字（双字节）、罗马数字、带圈的数字即可</p>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中strip()、lstrip()、rstrip()用法详解</title>
    <url>/2020/06/04/PYTHON%E4%B8%ADstrip-%E3%80%81lstrip-%E3%80%81rstrip-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中strip-、lstrip-、rstrip-用法详解"><a href="#PYTHON中strip-、lstrip-、rstrip-用法详解" class="headerlink" title="PYTHON中strip()、lstrip()、rstrip()用法详解"></a>PYTHON中strip()、lstrip()、rstrip()用法详解</h1><p>Python中有三个去除头尾字符、空白符的函数，它们依次为:</p>
<p><code>strip</code>： 用来去除头尾字符、空白符(换行、回车、制表符、空格)<br><code>lstrip</code>：用来去除开头字符、空白符(换行、回车、制表符、空格)<br><code>rstrip</code>：用来去除结尾字符、空白符(换行、回车、制表符、空格)    </p>
<p><strong>注意</strong>：这些函数都只会删除头和尾的字符，中间的不会删除</p>
<p>用法分别为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string.strip([chars])</span><br><span class="line">string.lstrip([chars])</span><br><span class="line">string.rstrip([chars])</span><br></pre></td></tr></table></figure></p>
<p>参数<code>chars</code>是可选的，当<code>chars</code>为空，默认删除<code>string</code>头尾的空白符   </p>
<p>当<code>chars</code>不为空时，函数会被<code>chars</code>解成一个个的字符，然后将这些字符去掉    </p>
<p>它返回的是去除头尾字符(或空白符)的<code>string</code>副本，<code>string</code>本身不会发生改变</p>
<p>举例说明如下：</p>
<ol>
<li><p>当chars为空时，默认删除空白符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; str &#x3D; &#39; ab cd &#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; str.strip() #删除头尾空格</span><br><span class="line">&#39;ab cd&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; str.lstrip() #删除开头空格</span><br><span class="line">&#39;ab cd &#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; str.rstrip() #删除结尾空格</span><br><span class="line">&#39; ab cd&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当chars不为空时，函数会被chars解成一个个的字符，然后将这些字符去掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; str2 &#x3D; &#39;1a2b12c21&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; str2.strip(&#39;12&#39;) #删除头尾的1和2</span><br><span class="line">&#39;a2b12c&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; str2.lstrip(&#39;12&#39;) #删除开头的1和2</span><br><span class="line">&#39;a2b12c21&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; str2.rstrip(&#39;12&#39;) #删除结尾的1和2</span><br><span class="line">&#39;1a2b12c&#39;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础总结——mosh版本</title>
    <url>/2020/06/01/python%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94mosh%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON视频讲解-MOSH-总结"><a href="#PYTHON视频讲解-MOSH-总结" class="headerlink" title="PYTHON视频讲解(MOSH)总结"></a>PYTHON视频讲解(MOSH)总结</h1><h2 id="和C-C-的区别"><a href="#和C-C-的区别" class="headerlink" title="和C/C++的区别"></a>和C/C++的区别</h2><ol>
<li><p><code>python</code>的<code>print</code>是一个函数，其中代表换行的参数默认换行，所以每次执行一次<code>print</code>都会自动换行</p>
</li>
<li><p><code>python</code>的<code>bool</code>值是<code>False</code>和<code>True</code>，首字母大写，而<code>C/C++</code>的<code>bool</code>类型值是<code>false</code>和<code>true</code>，首字母小写  </p>
</li>
<li><p><code>python</code>的输出函数是<code>print</code>，而<code>C</code>的输出语句是<code>printf</code></p>
</li>
<li><p><code>python</code>的输入语句是<code>input()</code>，这个函数把括号内的东西输出，并接受输入的值，所以可以有如下写法<code>name = input(&quot;what&#39;s your name&quot;)</code></p>
</li>
<li><p><code>input</code>把接收的值转化为字符串</p>
</li>
<li><p><code>10/3 = 3.333</code>，这与<code>C/C++</code>不同<br><code>10//3 = 3</code>，这与<code>C/C++</code>相同<br><code>3**2 = 9</code>，<code>C/C++</code>中没有此用法</p>
</li>
<li><p><code>C++</code>中的类与<code>python</code>中的类有一点区别<br>假设都定义了<code>School</code>这个类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++:</span><br><span class="line">School one;</span><br><span class="line"></span><br><span class="line">python:</span><br><span class="line">one &#x3D; School()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ol>
<li><p><code>type</code>(变量) 打印变量的类型  </p>
</li>
<li><p>三个引号<code>&#39;&#39;&#39; &#39;&#39;&#39;</code>，三引号中间的变量可以换行，此外还有双引号和单引号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">email &#x3D; &#39;&#39;&#39;</span><br><span class="line">Hello!</span><br><span class="line">This is Fu JANG &#39;s blog.</span><br><span class="line">Welcome to u.</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">print(email)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Hello!</span><br><span class="line">This is Fu JANG &#39;s blog.</span><br><span class="line">Welcome to u.</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于第二点的代码（三引号）<code>email[0]</code>就是<code>H</code>，<code>email[-1]</code>就是<code>换行符</code>，<code>email[-2]</code>就是<code>.</code>，而对于以下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">email &#x3D; &#39;Hello&#39;</span><br><span class="line">print(email[-1])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">o</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[0:3]</code>左闭右开<br><code>[0:]</code> 0到末尾<br><code>[:3]</code>与第一个等效<br><code>[:]</code> 全部</p>
</li>
<li><p><code>f&#39;{变量名}’</code>  占位符，程序会用对应变量的值去填充大括号  </p>
</li>
<li><p><code>len()</code>  返回字符串的长度</p>
</li>
<li><p><code>.upper()</code>把字符串中字母全部转 为大写，但不改变原字符串<br><code>.lower()</code>把字符串中字母全部转为小写，但不改变原字符串<br><code>.title()</code>把字符串中单词首字母字母全部转为大写，但不改变原字符串<br> <code>.find(&#39;&#39;)</code>找到这个字符在字符串中的第一个索引<br> 若<code>&#39;&#39;</code>中为一串字符，则返回第一个字符的索引<br> 若<code>&#39;&#39;</code>中的字符在字符串中不存在，则返回<code>-1</code><br> <code>.replace(&#39;原&#39;, &#39;新&#39;)</code> 若字符串中没有原字符，则不替换</p>
</li>
<li><p><code>&#39; &#39; in 变量</code> 返回一个布尔值，代表该字符是否在此变量中  </p>
</li>
<li><p><code>round()</code>四舍五入<br><code>abs()</code>取绝对值</p>
</li>
<li><p>引用模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">import math</span><br><span class="line">print(math.ceil(2.9)) 封</span><br><span class="line">print(math.floor(2.9)) 底</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if</code>语句：<br><code>if:</code><br><code>elif:</code><br><code>else:</code>  </p>
</li>
<li><p>逻辑运算符：<br><code>and or not</code>   </p>
</li>
<li><p><code>while</code>循环，当条件不符合时，执行<code>else</code>，<code>break</code>的程序不执行<code>else</code><br><code>while:</code><br><code>else:</code>  </p>
</li>
<li><p><code>range(10)</code> <code>0</code>到<code>9</code><br><code>range(5,10)</code> <code>5</code>到<code>9</code><br><code>range(5,10,2)</code> <code>5,7,9</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码：</span><br><span class="line">for item in range(10):</span><br><span class="line">	print(item)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表：方括号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	[1,2,3],</span><br><span class="line">	[4,5,6],</span><br><span class="line">	[7,8,9]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表定义的方法<br><code>.append()</code> 在最后面插入<br> <code>.insert(0,10)</code> 在索引为0的位置加10<br> <code>.remove(5)</code> 删除第一个5<br> <code>.clear()</code> 清空列表<br> <code>.pop()</code> 删最后<br> <code>.index(5)</code> 传第一个5的索引<br> <code>.count(5)</code> 传5的个数<br> <code>.sort()</code> 不返回值，从小到大排序<br> <code>.reverse()</code> 从大到小排序<br> <code>.copy()</code> 复制</p>
</li>
<li><p><code>(,,)</code> 元组 不可变<br><code>.count()</code> 计数<br><code>.index()</code> 传索引  </p>
</li>
<li><p>压缩属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; (1,2,3)</span><br><span class="line">x, y, z &#x3D; m</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">customer &#x3D; &#123;</span><br><span class="line">    &quot;name&quot; : &quot;FuJANG&quot;,</span><br><span class="line">    &quot;sex&quot; : &quot;man&quot;,</span><br><span class="line">    &quot;address&quot; : &quot;China&quot;,</span><br><span class="line">    &quot;age&quot; : 6,</span><br><span class="line">    &quot;is_handsome&quot; : True</span><br><span class="line">&#125;</span><br><span class="line">print(customer[&quot;name&quot;])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">FuJANG</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码0</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典定义的方法<br><code>.get(&quot; &quot;)</code> 若键不存在则返回<code>None</code><br><code>.get(&quot;key&quot;, &quot;value&quot;)</code> 提供一个默认的值，并不修改字典，当在字典中对应的<code>key</code>存在时，默认值无效<br>可用此形式更改、添加字典<code>[&quot; &quot;] = &quot; &quot;</code></p>
</li>
<li><p>表示形式<br>列表<code>[ , , ]</code><br>元组<code>( , , )</code><br>字典<code>{  , , }</code>  </p>
</li>
<li><p><code>abc = &quot;字符串”</code><br><code>for ch in abc:</code>遍历字符串中的所有字符<br><code>abc.split(&quot;空格&quot;)</code> 根据空格分割字符串中的单词并储存在一个列表中</p>
</li>
</ol>
<h2 id="函数与模块"><a href="#函数与模块" class="headerlink" title="函数与模块"></a>函数与模块</h2><ol>
<li><p>定义一个函数<br> 每个函数后最好加上两个空行（标准格式），先定义函数后才可引用，<code>()</code>中可以加参数，如<code>(name)</code>,调用时需要传一个值如<code>(&quot;Mosh&quot;)</code>，关键字参数一般放在最后<br> 没有<code>return</code>的函数默认返回<code>None</code><br> 当<code>return x, y</code>时，<code>python</code>把<code>x, y</code>解释为一个元组<code>(x, y)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def 函数名():</span><br><span class="line">	内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>try...expect</code>来处理异常错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try：</span><br><span class="line">	×××</span><br><span class="line">expect 错误类型:</span><br><span class="line">	×××</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>class</code>定义一个类，首字母大写，不用下划线<br>  <code>def</code>定义一个函数，首字母小写，用下划线链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point:</span><br><span class="line">	def ×××(self, ×××):</span><br><span class="line">		×××</span><br><span class="line"></span><br><span class="line">	def ×××</span><br><span class="line"></span><br><span class="line">用类声明对象</span><br><span class="line">point1 &#x3D; Point()</span><br><span class="line">调用定义的方法</span><br><span class="line">point1.×××()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以在程序的任何位置设置属性，属性没有必要一定在类里定义</span><br><span class="line">point1.属性名 &#x3D; 10</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>python</code>中的构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point:</span><br><span class="line">	def __init__(self, x, y):</span><br><span class="line">		self.x &#x3D; x</span><br><span class="line">		self.y &#x3D; y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">point1 &#x3D; Point(10, 20)</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承：当一个类中没有任何东西时，为了规范格式，通常加一个<code>pass</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Normal:</span><br><span class="line">	def walk(self):</span><br><span class="line">		×××</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog(Normal):</span><br><span class="line">	pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat(Normal):</span><br><span class="line">	def bark(self):</span><br><span class="line">		print(&quot;×××&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import hello</span><br><span class="line">hello.×××()</span><br><span class="line"></span><br><span class="line">from hello import ×××</span><br><span class="line">×××()</span><br><span class="line"></span><br><span class="line">import hello as he</span><br><span class="line">he.×××()</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立一个包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">① New → Directory → __init__.py</span><br><span class="line">② New → Python Package</span><br><span class="line"></span><br><span class="line">import 包.文件</span><br><span class="line">包.文件.函数()</span><br><span class="line"></span><br><span class="line">from 包.文件 import 函数</span><br><span class="line">函数()</span><br><span class="line"></span><br><span class="line">from 包 import 文件</span><br><span class="line">文件.函数()</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置模块的调用举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># randint 为闭区间</span><br><span class="line">import random</span><br><span class="line">random.random() 随机跳出一个0和1间的数字</span><br><span class="line">random.randint(10, 20) 10到20间的一个整数值</span><br><span class="line">random.choice(numbers) 假如numbers是一个列表，则随机跳出列表中的一个元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置模块与下载模块<br><code>python</code>中有内置模块，当找不到想使用的模块时，可以去<code>pypi.org</code>寻找相应的模块下载命令，然后在终端上用命令下载相应的模块</p>
</li>
</ol>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础总结(1)</title>
    <url>/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络基础总结-1"><a href="#计算机网络基础总结-1" class="headerlink" title="计算机网络基础总结(1)"></a>计算机网络基础总结(1)</h1><ol>
<li>局域网：覆盖范围小、自己花钱买设备、带宽固定、自己维护、100米、10M 100M 1000M<br>广域网：距离远、花钱租带宽<br>Internet：由ISP组成、有自己的机房、对网民提供访问Internet连接</li>
<li>ISP：Internet服务提供商（Internet service provide）</li>
<li>DNS：把网站域名解析成IP地址</li>
<li>子网掩码：告诉计算机哪里是网络部分，哪里是主机部分</li>
<li>路由器的作用是在不同网段转发数据</li>
<li>计算机的网卡有mac地址（物理地址），全球唯一，mac地址在计算机出场时已经被固定在网卡中：48位二进制（12位十六进制）</li>
<li><p>计算机访问过程：  </p>
<p>先把要访问的域名发送给DNS服务器，DNS服务器把域名解析成IP地址返回  </p>
<p>数据包由数据、原IP地址、目标IP地址组成  </p>
<p>数据帧由数据、原IP地址、目标IP地址、此时的mac地址、下一个目的地的mac地址组成  </p>
<p>计算机发送数据帧后，数据帧在运输的过程中两个mac地址不断变化，因此不断重新封装，但是数据包没变   </p>
<p>数据帧在运输过程中不断经过路由器，路由器看数据包中的IP地址，决定下一步走哪个mac地址</p>
<p>目标服务器收到请求后，往计算机回传数据，会把数据切割成小块，并给每一块编号，然后取一部分放到目标服务器的缓存当中，再然后在缓存中取出一块，加上此服务器IP地址、目标计算机IP地址、此时的mac地址、下一个目的地的mac开始发送，发送后，此数据块不会被缓存区删除，因为发送的过程中可能会丢失，当目标计算机收到此数据块放到计算机中的缓存区后，发送请求接受下一个数据块的消息到此服务器时，此数据块才会在缓存区被删除  </p>
<p>当计算机的缓存满了时，会读取，然后再存缓存 </p>
<p>第一张图说明：<br> <img src="https://ae01.alicdn.com/kf/Hdb3d351ef0844379b41ec593f99d16506.jpg" alt="">  </p>
<p> 第二张图说明：<br> <img src="https://ae01.alicdn.com/kf/Hdb637a9eee4a485f886ec3430de942ddU.jpg" alt=""></p>
</li>
<li><p>OSI参考模型（国际标准把计算机通信进行的定义）</p>
<ol>
<li>应用层：所有能产生网络流量的程序</li>
<li>表示层：在传输之前是否进行加密或压缩处理、传的是二进制还是ASCII码</li>
<li>会话层：电脑和某服务器建立起的联系，比如电影前进后退进、查木马都是会话层的体现 netstat -n 命令可在终端查看此电脑建立的会话  </li>
<li>传输层：可靠传输（比如某服务器传输数据到计算机、把数据分块传输，如果发送了某一块之后没收到请求下一块的信息，就会接着发送这个数据块，防止数据块丢失）、流量控制（比如服务器发送数据太快了，则计算机发消息告诉服务器调整发送速度）、不可靠传输（比如DNS解析域名，一个数据包就能说明问题与得到答案，不需要建立会话）</li>
<li>网络层：负责选择最佳路径、规划IP地址</li>
<li>数据链路层：帧的开始和结束、透明传输（将数据中与开头或结尾表示相同的部分进行转义）、差错校验（检错错误，数据中多加一部分数据进行校验，但不纠错，只检查，错误的就扔掉，纠错是在传输层进行）  </li>
<li>物理层：接口标准、电器标准、如何在物理链路上传输更快的速度</li>
</ol>
</li>
<li><p>每一层都是一个较为独立的模块，每一个模块变化都不会影响其他的模块；但每一层都有关系：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层-&gt;人（-&gt;代表xx为xx提供服务） </p>
</li>
<li><p>网络出现故障，应该从最底层物理层往上一层一层进行检查  </p>
<ol>
<li>物理层故障：查看连接状态、查看发送和接收的数据包</li>
<li>数据链路层故障：mac地址冲突、ADSL欠费、网速没办法协商一致、计算机连接到错误的VLAN(虚拟局域网)</li>
<li>网络层故障：配置了错误的IP地址、子网掩码、配置错误的网关、路由器没有配置到达目标网络的路由、数据有没有通过各个网关到达指定位置  </li>
<li>应用层故障：应用程序配置错误</li>
</ol>
</li>
<li><p>打开终端输入命令ping一个网址，若数据有来有回，则证明网通了</p>
</li>
<li>OSI参考模型和网络安全<ol>
<li>物理层安全</li>
<li>数据链路层安全：ADSL账号密码、VLAN、交换机端口绑定mac地址</li>
<li>网络层安全：在路由器上时使用ACL控制数据包流量、防火墙</li>
<li>应用层安全：开发的应用程序没漏洞</li>
</ol>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H66237f88bb294f1db97200f8cd552ddbd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>计算机网络基础——韩立刚视频总结</tag>
      </tags>
  </entry>
  <entry>
    <title>translate first day</title>
    <url>/2020/05/31/translate-first-day/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="A-week-of-distractions-from-Trump-shows-a-leader-in-crisis"><a href="#A-week-of-distractions-from-Trump-shows-a-leader-in-crisis" class="headerlink" title="A week of distractions from Trump shows a leader in crisis"></a>A week of distractions from Trump shows a leader in crisis</h1><p>(CNN)On Monday, as the nation marked Memorial Day, President Donald Trump mocked his campaign rival for wearing a face mask. On Wednesday, as the national death toll from coronavirus reached a wretched milestone, Trump and his family flew to Florida in an attempted focus on space travel.</p>
<p>By Friday, as smoke was lifting in Minneapolis after a night of racial unrest, he announced the United States would withdraw from the World Health Organization. A day later, after another night of protests, he declared himself safe inside his heavily fortified mansion and insinuated his own supporters would rally outside that evening.</p>
<p>In between, there was a dark suggestion of murder, false conspiracies about voting through the mail, a fight over where to hold his nominating convention and a dramatic escalation of ill will with the very social media platform that facilitated almost all the other diversions in the first place.</p>
<p>Trump’s efforts to change the subject at moments of peril have been a hallmark of his entire career in politics and, when successful, a constant source of frustration for his rivals. But rarely have they appeared more blatant or off-key than now, as a battered nation emerges from a pandemic that has left more than 100,000 dead and as racial unrest brews again.<br>That it is all happening five months before Trump faces an election in which polls show him trailing only heightens the sense of a leader in crisis, even as he insists he has a handle on both matters and attempts to proceed as planned with his presidency. Trump, cognizant of his precarious political position, has retrenched.</p>
<p>Unwilling or unable to strike a unifying tone, Trump lashed out Saturday morning when he criticized the Democratic mayors of Washington and Minneapolis while appearing to summon his own supporters to rally outside the White House.</p>
<p>After announcing his was safe, warning he was protected by “vicious dogs” and “ominous weapons,” Trump provided a play-by-play of Friday evening’s protests, of which he said he’d “watched every move.” Trump wrote: “Tonight, I understand, is MAGA NIGHT AT THE WHITE HOUSE???”</p>
<p>Advisers insist Trump is focused on reviving the country after three months of pandemic that have led, along with the six-figure death toll, to record levels of unemployment and entire industries shuttered. Trump has aggressively pushed for states to reopen even when they don’t necessarily meet the parameters set out by his task force, which has seen its meetings sharply curtailed and its health experts’ public roles reduced.</p>
<p>At the same time, Trump has sought over the past week to shine the presidential spotlight into dustier corners filled with festering racial grievances and antique conspiracies, all of which have been debunked. He has waged feuds old and new and unveiled strategically timed policy announcements at a moment when his leadership is being questioned.</p>
<p>The events that unfolded after the President issued a tweet early Friday laden with racist overtones underscored the degree to which he has used inflammatory statements to ignite controversy and enthuse his supporters, even as he denied later that those were his intentions.</p>
<p>Aides spent Friday debating whether Trump should address the situation in Minnesota during a planned appearance in the Rose Garden, which had been called to announce new actions against China and the US withdrawal from the World Health Organization.</p>
<p>Some of his advisers encouraged him to speak about Minnesota because his election-year rival had already delivered an address on the topic. Others were more skeptical, convinced Trump would only face more questions about his tweet that used a phrase first uttered by a Miami police chief in 1967 to describe a crackdown in black neighborhoods.</p>
<p>More than 12 hours after tweeting “when the looting starts, the shooting starts” as images of Minneapolis fire and riots played on cable news, Trump insisted on Twitter that his message was not, in fact, a reference to brutal civil rights-era police tactics. But he ignored the topic in the Rose Garden, choosing instead to focus on China and retreating to the Oval Office as reporters shouted questions.</p>
<p>It was only around 5 p.m. ET — after a full day of public silence — that Trump announced he’d spoken with the family of George Floyd, the black man who had died after being pinned to the ground by his neck by a white police officer.</p>
<p>“It certainly looked like there was no excuse for it,” he said of the violent arrest during a roundtable event meant to focus on coronavirus.</p>
<p>The episode followed Trump’s longtime model of igniting controversy before retreating hours later. If anything, leaving his message lingering without explanation was a diversion in itself and another example of Trump’s inability — or unwillingness — to put aside the divisive itch he’s long cultivated.</p>
<p>The role of national consoler has never come easily to Trump, nor have attempts at unifying a country riven by politics and ideology. In many instances he’s simply shown no interest in assuming the tone or accepting the responsibilities that US presidents have shouldered throughout history.</p>
<p>He doesn’t believe it’s up to him to demonstrate responsible mask-wearing, and he retweeted a message earlier this week that appeared to mock former Vice President Joe Biden’s mask-and-aviators ensemble.</p>
<p>Most of the country may say Trump should wear a mask in public — a Quinnipiac University poll this week put the figure at 67% — but among white men the number stands only at 49%, enough for his stance to pass political muster with his most reliable bloc of supporters.</p>
<p>As coronavirus began ravaging parts of the country, he did declare himself a wartime President waging battle against the “invisible enemy.” But with war comes death — in this case, more US deaths than the Vietnam and Korean wars combined — and Trump was slow to acknowledge the 100,000 milestone reached midweek.</p>
<p>He was aboard Air Force One when the death toll officially ticked into six digits, returning to Washington after his plans to witness the first manned US space launch in nearly a decade had been thwarted by the weather.</p>
<p>He had hoped that the trip, with his entire family in tow, would help shift a national storyline from the miserable pandemic toward a more optimistic one of scientific potential. But the launch was scrubbed when thunderstorms rolled in and Trump was forced to return to Washington.</p>
<p>The President didn’t address the grim figure as he returned to the White House with the first lady on Wednesday.</p>
<p>He finally tweeted about it on Thursday morning, deeming it “a very sad milestone.” But he did not make time to address it in person.</p>
<p>Instead, he has wielded sinister conspiracies and false allegations.</p>
<p>He’s railed against vote-by-mail, which many governors are seeking to expand amid a highly contagious viral pandemic and which has not proved to be rife with fraud. Despite his issues with the practice, Trump himself voted by mail in February, even though he was in Florida — the state where he votes — on the day that early voting locations opened and drove past one that’s across from his golf course at least six times.</p>
<p>He has actively worked to relitigate the circumstances that led to Robert Mueller’s Russia investigation, including this week, when he fan-danced around the still-unnamed allegation against his predecessor Barack Obama.</p>
<p>On Friday evening, his newly installed director of national intelligence appeared to further the cause by releasing the transcripts of phone calls between Trump’s onetime national security adviser and the then-Russian ambassador to the United States.</p>
<p>The darkest of Trump’s fixations remains the unfounded insinuation that a morning cable news host played a role in killing a young aide almost two decades ago, a blatant falsehood that led this week to pleas from the young woman’s widower for Twitter to disallow the messages.</p>
<p>The social media giant did not block those messages but did attempt to fact-check his claims about vote-by-mail, a move that set Trump off and led to a hurried effort inside the White House to finalize an executive order few believe will withstand legal scrutiny and that could, potentially, cause even more regulation of the President’s tweets. Hours after he signed it, Twitter slapped a warning on his Minnesota tweet, saying it glorified violence.</p>
<p>At one time, Trump used his once-a-week campaign rallies to unleash the vitriol and paranoia that his supporters love and that he believes are the very characteristics that led to his unlikely victory in 2016.</p>
<p>Rallies are out of the question for now — though aides say they’re looking to revive them sooner rather than later.</p>
<p>This story has been updated with additional developments.</p>
<p><img src="https://ae01.alicdn.com/kf/Haf7cd3754a7a4a1390938116e7db9917N.jpg" alt=""></p>
]]></content>
      <categories>
        <category>TRANSLATE</category>
      </categories>
      <tags>
        <tag>TRANSLATE</tag>
      </tags>
  </entry>
</search>

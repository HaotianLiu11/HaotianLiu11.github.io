<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0x02递推与递归</title>
    <url>/2020/05/30/0x02%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x02递推与递归"><a href="#0x02递推与递归" class="headerlink" title="0x02递推与递归"></a>0x02递推与递归</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>一个实际问题的各种可能情况构成的集合通常称为“状态空间”，而程序的运行则是对状态空间的遍历</p>
<p>对于一个待求解的问题，当它局限在某处边界、某个小范围或者某种特殊情况下时，其答案往往是已知的。如果能够将该解答的应用场景扩大到原问题的状态空间，并且扩展过程的每个步骤具有相似性，就可以考虑使用递推或者递归求解</p>
<p>以已知的“问题边界”为起点向“原问题”正向推导的扩展方式就是递推。然而在很多时候，推导的路线难以确定，这时以“原问题”为起点尝试寻找把状态空间缩小到已知的“问题边界”路线，再通过该路线反向回溯的遍历方式就是递归  </p>
<p>使用递推或递归要求“原问题”与“问题边界”之间的每个变换步骤具有相似性，这样我们才能设计一段程序来实现该步骤，将其重复作用于问题之中。换句话说，程序在每个步骤上应该面对相同种类的问题，这些问题都是原问题的一个子问题，可能仅在规模或者某些限制条件上有所区别，并且能够使用“求解原问题的程序”进行求解</p>
<p>对于递归算法，有了上面这个前提，我们就可以让程序在每个变换步骤中执行三个操作：</p>
<ol>
<li>缩小问题状态空间的规模。这意味着程序尝试寻找在“原问题”与“问题边界”之间的变换路线，并向正在探索的路线迈出一步</li>
<li>尝试求解规模缩小以后的问题，结果可能是成功，也可能是失败</li>
<li>如果成功，即找到了规模缩小后的问题的答案，那么将答案扩展到当前问题；如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直至最终确定当前问题无法继续求解</li>
</ol>
<p>以上三个操作有两点特别关键：一是“如何尝试求解规模缩小以后的问题”。因为规模缩小以后的问题是原问题的一个子问题，所以我们可以把它视为一个新的原问题，由相同的程序进行求解，这就是所谓的“<strong>自身调用自身</strong>”；二是如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“<strong>回溯时还原现场</strong>”，关于递归与回溯，举一道简单的例题</p>
<h3 id="LEETCODES1457-二叉树中的伪回文路径"><a href="#LEETCODES1457-二叉树中的伪回文路径" class="headerlink" title="LEETCODES1457. 二叉树中的伪回文路径"></a><a href="https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">LEETCODES1457. 二叉树中的伪回文路径</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        cnt[root-&gt;val]++;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> item : cnt)</span><br><span class="line">                <span class="keyword">if</span> (item.second % <span class="number">2</span>)</span><br><span class="line">                    t++;</span><br><span class="line">            cnt[root-&gt;val]--;</span><br><span class="line">            <span class="keyword">return</span> t &lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) res += pseudoPalindromicPaths(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) res += pseudoPalindromicPaths(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        cnt[root-&gt;val]--;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>y总原话：从这道题中我们可以看出<code>回溯时还原现场</code>的要求，每一次<code>return</code>之前都要记得恢复，有两次<code>return</code>，所以两次都要记得恢复。我们要记住一点：如果进来的时候修改了，那么在退出之前就应该恢复  </p>
</blockquote>
<p>重申：如果求解问题失败或者是一种情况走到尽头，程序需要重新回到当前问题去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题产生影响的事情应该全部失效，这就是所谓的“<strong>回溯时还原现场</strong>”</p>
<h2 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a>递归总结</h2><p>可以看到，递归程序的基本单元是由“缩小”、“求解”、“扩展”组成的一种变换步骤，只是在“求解”时因为问题的相似性，不断重复使用了这样一种变换步骤，直至在一致的问题边界上直接确定答案。对于其中任意一条从“原问题”到“边界问题”的变换路线，横向来看，它跳的每一层是一次递归程序的执行；纵向来看，它的左右两边分别是寻找路线和沿其推导的流程。为了保证每层的“缩小”与“拓展”能够衔接在同一形式的问题上，“求解”操作自然要保证在执行前后程序面对的问题的状态是相同的，这也就是“还原现场”的必要性所在</p>
<h2 id="递推与递归的简单应用"><a href="#递推与递归的简单应用" class="headerlink" title="递推与递归的简单应用"></a>递推与递归的简单应用</h2><p>在使用枚举算法蛮力探索问题的整个”状态空间“时，经常需要递归。按照规模大小，有如下的几种常见的枚举形式和遍历方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">枚举形式</th>
<th style="text-align:center">状态空间规模</th>
<th style="text-align:center">一般遍历方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">多项式</td>
<td style="text-align:center">n^k k为常数</td>
<td style="text-align:center">循环(for)、递推</td>
</tr>
<tr>
<td style="text-align:center">指数</td>
<td style="text-align:center">k^n k为常数</td>
<td style="text-align:center">递归、位运算</td>
</tr>
<tr>
<td style="text-align:center">排列</td>
<td style="text-align:center">n!</td>
<td style="text-align:center">递归、C++next_permutation</td>
</tr>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">C_n^m</td>
<td style="text-align:center">递归+减枝</td>
</tr>
</tbody>
</table>
</div>
<h2 id="递归的机器实现"><a href="#递归的机器实现" class="headerlink" title="递归的机器实现"></a>递归的机器实现</h2><p>一台典型的<code>32</code>位计算机采用“堆栈结构”来实现函数调用，它在汇编语言中，把函数所需的第<code>k</code>个、第<code>k-1</code>个，……，第<code>1</code>个参数依次入栈，然后执行<code>call(address)</code>指令。该指令把返回地址（当前语句的下一条语句地址）入栈，然后跳转到<code>address</code>位置的语句。在函数返回时，它执行<code>ret</code>指令。该指令把返回地址出栈，并跳转到该地址继续执行</p>
<p>对于函数中定义的<code>C++</code>局部变量，在每次执行<code>call</code>与<code>ret</code>指令时，也会在栈中相应的保存与复原，而作用范围超过该函数的变量，以及通过<code>new</code>和<code>malloc</code>函数动态分配的空间则保存在另一块成为<code>堆</code>的结构中。栈指针、返回值、局部的运算会借助<code>CPU</code>的“寄存器”完成</p>
<p>由此我们得知：</p>
<ol>
<li>局部变量在每层递归中都占有一份空间，声明过多或递归过深就会超出”栈“所能存储的范围，造成栈溢出</li>
<li>非局部变量对于各层递归都共享一份空间，需要及时维护、还原现场，以防止在各层递归之间存储和读取的数据相互影响</li>
</ol>
<p>了解了递归的及其实现之后，我们就可以使用模拟的方法，把递归程序改写为非递归程序。具体来说，我们可以用一个数组来模拟栈，使用变量来模拟栈指针和返回值，使用<code>switch/case</code>或者<code>goto/label</code>来模拟语句跳转</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治法把一个问题划分成若干个规模更小的同类子问题，对这些子问题递归求解，然后在回溯时通过它们推导出原问题的解</p>
<p><img src="https://ae01.alicdn.com/kf/H66237f88bb294f1db97200f8cd552ddbd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>0x01位运算</title>
    <url>/2020/05/28/0x01%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x01-位-运-算"><a href="#0x01-位-运-算" class="headerlink" title="0x01 位 运 算"></a>0x01 位 运 算</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>用<code>xor</code>表示异或运算，在<code>m</code>位二进制数中，通常称最低位为<code>0</code>位，从右到左依此类推，最高位为<code>m-1</code>位。</p>
</li>
<li><p><code>|-1|</code>的原码为<code>00000001</code><br><code>|-1|</code>的反码为<code>11111110</code><br><code>-1</code>的补码为<code>11111111</code>，十六进制表示为<code>0xff</code><br><code>8</code>位二进制对应的最大值<code>127</code>的十六进制表示为<code>0x7f</code><br>在计算机中数字以其补码的形式保存，正数的补码等于其原码，负数的补码等于其对应正数的原码取反码再<code>+1</code></p>
</li>
<li><p>对于<code>32</code>位二进制数<code>C</code>(设十进制的值为<code>S</code>)，其按位取反得到的编码<code>~C</code>对应的十进制的值为<code>-1-S</code>(正负都满足此规律)</p>
</li>
<li><p>补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在<code>32</code>位补码下做最高位不进位的二进制加减法运算。发生算术溢出时，<code>32</code>位无符号整数相当于自动对<code>2^32</code>取模，这也解释了有符号整数溢出时为何会出现负数的现象。</p>
</li>
<li><p>在算法竞赛中常用十六进制来表示一个常数，这样书写需要八个字符。<br>| 10进制 | 16进制 |<br>| :-: | :-: |<br>| 21 4748 3647 | 0x7f ff ff ff |<br>| 10 6110 9567 | 0x3f 3f 3f 3f |<br>| -1 | 0xff ff ff ff | </p>
</li>
<li><p><code>4</code>个字节的<code>int</code>表示的最大值为<code>21 4748 3647</code><br><code>4</code>个字节的<code>unsigned int</code>表示的最大值为<code>42 9496 7295</code> </p>
</li>
<li><p><code>0x3f 3f 3f 3f</code>是一个很有用的值，它满足两个条件：<br>其一，整数的两倍不超过int能表示的最大正整数<br>其二，二进制下每八位都相同<br>因此，我们可以用<code>memset(a, 0x3f, sizeof a)</code>来给<code>a</code>数组的每一个元素都赋值为正无穷，虽然<code>0x7f</code>能给每一个元素赋值成最大，但是为了避免溢出情况，推荐用<code>0x3f</code>。</p>
<ol>
<li><code>1 &lt;&lt; n = 2^n, n &lt;&lt; 1 = 2n</code><br><code>n &gt;&gt; 1 = n / 2.0 向下取整</code><br>需要注意的是，整数做<code>/</code>运算执行的是向<code>0</code>取整<br><code>(-3) &gt;&gt; 1 = -2, (-3) / 2 = -1</code></li>
</ol>
</li>
<li><p>除非特殊提示，我们默认右移采用的是算术右移的实现方式</p>
<blockquote>
<p>逻辑右移不考虑符号位，右移一位，左边补零即可。<br> 算术右移考虑符号位，右移一位，若符号位为1，就在左边补1；否则，就补0。<br> 所以算术右移也可以进行有符号位的除法,右移n位就等于除2的n次方。<br> 例如，8位二进制数11001101分别右移一位。<br> 逻辑右移就是[0]1100110<br> 算术右移就是[1]1100110  </p>
</blockquote>
</li>
</ol>
<h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><p>二进制状态压缩是指将一个长度为<code>m</code>的<code>bool</code>数组用一个<code>m</code>位二进制整数表示并存储的方法，利用如下操作实现对原<code>bool</code>数组对应下标元素的存取。  </p>
<ol>
<li>取出整数<code>n</code>的第<code>k</code>位：<code>(n&gt;&gt;k)&amp;1</code></li>
<li>取出整数<code>n</code>的后<code>k</code>位<code>(0到k-1位)</code>：<code>((1&lt;&lt;K)-1)&amp;n</code></li>
<li>把整数<code>n</code>的第<code>k</code>位反转：<code>(1&lt;&lt;k) nor n</code></li>
<li>把整数<code>n</code>的第<code>k</code>位赋值为<code>1</code>：<code>(1&lt;&lt;k)|n</code>  </li>
<li>把整数<code>n</code>的第<code>k</code>位赋值为<code>0</code>：<code>(~(1&lt;&lt;k))&amp;n</code>  </li>
</ol>
<p>当<code>m</code>不大时，我们可以使用一个整数存储，当m很大时，我们可以用若干个整数存储<code>(int数组)</code>，也可以用<code>C++STL</code>为我们提供的<code>bitset</code>实现。</p>
<h2 id="成对变换"><a href="#成对变换" class="headerlink" title="成对变换"></a>成对变换</h2><p>通过计算可发现，对于非负整数<code>n</code>:  </p>
<ol>
<li>当<code>n</code>为偶数时，<code>n xor 1 = n + 1</code></li>
<li>当<code>n</code>为奇数时，<code>n xor 1 = n - 1</code></li>
</ol>
<p>因此<code>0与1</code>, <code>2与3</code>, <code>4与5</code> … 关于<code>xor 1</code>运算构成成对变换。  </p>
<p>这一性质经常用于图论邻接表中边集的存储。在具有无向边(双向边)的图中把一对正反方向的边分别存储在邻接表数组的第<code>n</code>与<code>n+1</code>位置(其中<code>n</code>为偶数)，就可以通过<code>xor 1</code>的运算获得与当前边<code>(x,y)</code>反向的边<code>(y,x)</code>的存储位置。</p>
<h2 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h2><p><code>lowbit(n)</code>定义为非负整数<code>n</code>在二进制表示下“最低位的1及其后边所有的0”构成的数值。  </p>
<p>例子：<code>lowbit(10)=2</code>  </p>
<p>其原理为：<code>lowbit(n)=n&amp;(~n-1)=n&amp;(-n)</code></p>
<p><code>lowbit</code>运算配合<code>Hash</code>可以找出整数二进制下所有是<code>1</code>的位，所花费的时间与<code>1</code>的个数同级。为了达到这个目的，我们只需要不断把<code>n</code>赋值为<code>n-lowbit(n)</code>直至<code>n=0</code>。我们可以把每次减去的数(其一定为2的幂)求<code>log</code>得到对应的<code>1</code>所在的位数，因为<code>C++math.h</code>库中的<code>log</code>函数复杂度常数较大，所以我们可以预处理一个数组，通过<code>Hash</code>的方法代替<code>log</code>运算。  </p>
<p>此外<code>lowbit</code>运算也是树状数组中的一个基本运算。</p>
<h1 id="0x01位运算例题"><a href="#0x01位运算例题" class="headerlink" title="0x01位运算例题"></a>0x01位运算例题</h1><blockquote>
<p>点击每道题题目即可获取原题链接</p>
</blockquote>
<h2 id="a-b"><a href="#a-b" class="headerlink" title="a^b"></a><a href="https://www.acwing.com/problem/content/91/" target="_blank" rel="noopener">a^b</a></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>long long</code>可以表示的最大值为<code>922 3372 0368 5477 5807</code><br><code>unsigned long long</code>可以表示的最大值为<code>1844 6744 0737 0955 1615</code>  </p>
<p>由此观之<code>a^b</code>大于<code>ULL</code>类型可以表示的最大值，所以要用快速幂的思想来求解这道题。</p>
<p><img src="https://ae01.alicdn.com/kf/H4fabba6e8a6644e88cb9ee4fe512f4ecH.jpg" alt=""><br>且取模的性质如下</p>
<ul>
<li>(a + b) % p = (a % p + b % p) % p</li>
<li>(a - b) % p = (a % p - b % p) % p </li>
<li>(a <em> b) % p = (a % p </em> b % p) % p </li>
<li>a ^ b % p = ((a % p)^b) % p </li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> % c;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (<span class="keyword">long</span> <span class="keyword">long</span>)ans * a % c;</span><br><span class="line">        a = (<span class="keyword">long</span> <span class="keyword">long</span>)a * a % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    <span class="keyword">int</span> ans = power(a, b, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>我们可以用<code>b&amp;1</code>运算表示<code>b</code>的二进制下的最低位，并用<code>b&gt;&gt;1</code>来舍去最低位。在递归的过程中把<code>&gt;&gt;</code>和<code>&amp;</code>结合，其时间复杂度为<code>O(logb)</code></p>
<h2 id="64位整数乘法"><a href="#64位整数乘法" class="headerlink" title="64位整数乘法"></a><a href="https://www.acwing.com/problem/content/92/" target="_blank" rel="noopener">64位整数乘法</a></h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">power</span><span class="params">(LL a, LL b, LL c)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans + a) % c;</span><br><span class="line">        a = a * <span class="number">2</span> % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL a, b, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    LL ans = power(a, b, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>我们可以用<code>b&amp;1</code>运算表示<code>b</code>的二进制下的最低位，并用<code>b&gt;&gt;1</code>来舍去最低位。在递归的过程中把<code>&gt;&gt;</code>和<code>&amp;</code>结合，其时间复杂度为<code>O(logb)</code>，与上一题不同的是位数问题，但是每次<code>%p</code>之后都能保证不超过<code>2*10^18</code>，在<code>long long</code>的范围内</p>
<h2 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a><a href="https://www.acwing.com/problem/content/93/" target="_blank" rel="noopener">最短Hamilton路径</a></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们可以采用朴素算法,其时间复杂度为<code>O(n*n!)</code>，<code>n!</code>为枚举<code>n</code>个点的全排列，<code>n</code>代表枚举路径的长度求得结果，这个算法的时间复杂度太高，不符合。而我们可以用二进制状态压缩<code>DP</code>来把时间复杂度优化到<code>O((n^2)*(2^n))</code>,我们用<code>F[i,j]</code>表示点被经过的状态对应二进制数<code>i</code>，且目前处于点<code>j</code>的最短路径   </p>
<p>在起点时<code>F[1,0]=0</code>，即目前处于点<code>0</code>且只经过了点<code>0</code>的最短路径为<code>0</code>。为方便起见，我们将数组中其他元素设为无穷大，最终目的是求<code>F[(1&lt;&lt;n),n-1]</code>的值，即经过所有点且最终处于<code>n-1</code>的最短路径</p>
<p>在任意时刻，有公式<code>F[i,j]=min(F[i,j],F[i^(1&lt;&lt;j),k]+weight[k,j])</code>，根据分析可得<code>k</code>一定是倒数第二个经过的点。我们枚举<code>k</code>，当<code>k</code>对应在<code>i</code>的二进制为<code>1</code>时，我们讨论这种情况并比较</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> weight[N][N], F[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;weight[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">    F[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="keyword">if</span> ((i ^ <span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        F[i][j] = <span class="built_in">min</span>(F[i][j], F[i ^ <span class="number">1</span> &lt;&lt; j][k] + weight[k][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, F[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>0x11栈</title>
    <url>/2020/06/06/0x11%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x11栈"><a href="#0x11栈" class="headerlink" title="0x11栈"></a>0x11栈</h1><h2 id="ACWING41-包含min函数的栈"><a href="#ACWING41-包含min函数的栈" class="headerlink" title="ACWING41.包含min函数的栈"></a><a href="https://www.acwing.com/problem/content/90/" target="_blank" rel="noopener">ACWING41.包含min函数的栈</a></h2><p>栈结构原本就支持<code>O(1)</code>的入栈、出栈操作，但不支持查询最小值的操作。一个比较直接的思路是，我们知道二叉堆是一种支持插入、取出堆顶、查询最小值的数据结构，如果在维护一个栈的同时再维护一个存储同样元素的二叉堆，就可以支持题目中要求的操作，然而，它的时间复杂度是<code>O(logN)</code>，如果我们只用一个变量记录最小值，当发生出栈操作时，如果最小值恰好被出栈，就无法得知新的最小值是什么。这启发我们使用一个线性结构来保存历史上每个时刻的最小值，这样我们就可以在出栈后进行还原   </p>
<p>我们建立两个栈，栈<code>A</code>存储原本的数据、栈<code>B</code>用单调栈来实现，当我们向栈中压入一个数时，如果该数 ≤ 单调栈的栈顶元素，则将该数同时压入单调栈中；否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数，这样所有操作的时间复杂度都是<code>O(1)</code>    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minvalue;</span><br><span class="line"></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minvalue.empty() || x &lt;= minvalue.top()) minvalue.push(x);</span><br><span class="line">        value.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minvalue.top() == value.top()) minvalue.pop();</span><br><span class="line">        value.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minvalue.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="ACWING128-编辑器"><a href="#ACWING128-编辑器" class="headerlink" title="ACWING128.编辑器"></a><a href="https://www.acwing.com/problem/content/130/" target="_blank" rel="noopener">ACWING128.编辑器</a></h2><p>本题的特殊点在于，<code>I D L R</code>四种操作都在光标位置处发生，并且操作完成后光标至多移动一个位置，根据这种“始终在序列中间某个指定位置进行修改”的性质，我们不难想到一个对顶栈的做法  </p>
<p>建立两个栈，栈<code>L</code>存储从序列开头到当前光标位置的这一段子序列，栈<code>R</code>存储从当前光标位置到序列结尾的这一段子序列，二者都以光标所在的那一端作为栈顶，这两个栈合起来就保存了整个序列。因为查询操作的<code>K</code>不超过光标位置，所以我们用一个动态数组<code>F</code>维护栈<code>L</code>的前缀和最大值即可，通过这两个对顶栈，我们在<code>O(1)</code>的时间内实现了每种操作和询问    </p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N], ll, rr;</span><br><span class="line"><span class="keyword">int</span> f[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    l[++ll] = x;</span><br><span class="line">    sum[ll] = sum[ll - <span class="number">1</span>] + x;</span><br><span class="line">    f[ll] = <span class="built_in">max</span>(f[ll - <span class="number">1</span>], sum[ll]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">char</span> ops[<span class="number">2</span>];</span><br><span class="line">    f[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ops;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">if</span> (*ops == <span class="string">'I'</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*ops == <span class="string">'D'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ll) ll--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*ops == <span class="string">'L'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ll) r[++rr] = l[ll--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*ops == <span class="string">'R'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rr) add(r[rr--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; f[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING129-火车进栈"><a href="#ACWING129-火车进栈" class="headerlink" title="ACWING129. 火车进栈"></a><a href="https://www.acwing.com/problem/content/131/" target="_blank" rel="noopener">ACWING129. 火车进栈</a></h2><p>题目要求按字典序输出前<code>20</code>种顺序，我们来看大部分的状态，都可以进行两种操作：第一种，栈顶元素输出；第二种，下一个数字进栈，当我们按照顺序把元素依次进栈时，下一次进栈的元素一定大于栈中的元素和输出的元素，所以为了输出字典序，我们先进行出栈操作，后进行进栈操作，用深搜的过程中，我们需要维护四种<code>state</code>，第一个是输出的元素，第二个是栈中的元素，第三个是未进栈的元素，第四个是已经输出的序列的数量（等于<code>20</code>停止）    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, remain = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!remain) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        remain--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : path) <span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        path.push_back(stk.top());</span><br><span class="line">        stk.pop();</span><br><span class="line">        dfs(u);</span><br><span class="line">        stk.push(path.back());</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        stk.push(u);</span><br><span class="line">        dfs(u + <span class="number">1</span>);</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING130-火车进出栈问题"><a href="#ACWING130-火车进出栈问题" class="headerlink" title="ACWING130.火车进出栈问题"></a><a href="https://www.acwing.com/problem/content/132/" target="_blank" rel="noopener">ACWING130.火车进出栈问题</a></h2><blockquote>
<p>我被这题搞死了，未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hd768bd7dd9b74f66abfafe1c877ce715C.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>0x06倍增</title>
    <url>/2020/06/03/0x06%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x06倍增"><a href="#0x06倍增" class="headerlink" title="0x06倍增"></a>0x06倍增</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>倍增，字面意思就是“成倍的增长”。这是指我们在进行递推时，如果状态空间很大，通常的线性递推无法满足时间与空间复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间中在<code>2</code>的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过“任意整数可以表示成若干个<code>2</code>的次幂项的和”这一性质 ，使用之前求出的代表值拼成所需的值。所以使用倍增算法也要求我们递推的问题的状态空间关于<code>2</code>的次幂具有可划分性  </p>
<p>“倍增”与“二进制划分”两个思想相互结合，降低了求解很多问题的时间与空间复杂度。我们之前学习的快速幂其实就是“倍增”与“二进制划分”思想的一种体现。在此文章中，我们研究序列上的倍增问题，包括求解<code>RMQ</code>（区间最值）问题的<code>ST</code>算法，关于求解最近公共祖先<code>LCA</code>等在树上的倍增应用，我将在后续文章进行探讨   </p>
<p>试想这样一个问题：给定一个长度为<code>N</code>的数列<code>A</code>，然后进行若干次询问，每次给定一个整数<code>T</code>，求出最大的<code>k</code>，满足数列<code>A</code>中前<code>k</code>个数的和小于等于<code>T</code>。你的算法必须是在线的（必须即时回答每一个询问，不能等待收到所有询问后再统一处理），假设<code>T</code>小于等于数组<code>A</code>中所有数的和  </p>
<p>朴素做法当然是从前向后枚举<code>K</code>，每次询问花费的时间与答案的大小有关，最坏情况为<code>O(N)</code>  </p>
<p>如果我们能够先花费<code>O(N)</code>的时间预处理<code>A</code>数组的前缀和数组<code>S</code>，就可以二分<code>K</code>的位置，比较<code>S[K]</code>与<code>T</code>的大小来确定二分上下界的变化，每次询问花费的时间都是<code>O(logN)</code>。这个算法在平均情况下表现很好，但是它的缺点是如果每次询问给定的整数<code>T</code>都非常小，造成答案<code>K</code>也非常小，那么该算法可能还不如从前往后枚举更优（因为假如每次只怼前<code>3</code>个，此时<code>O(log)</code>的算法可能不如<code>O(3)</code>的好）   </p>
<p>我们可以设计这样一种倍增算法：  </p>
<ol>
<li>令<code>p=1</code>，<code>k=0</code>，<code>sum=0</code>  </li>
<li>比较<code>A</code>数组中<code>k</code>之后的<code>p</code>个数的和与<code>T</code>的关系，也就是说，如果<code>sum+S[k+p]-S[k]&lt;=T</code>，则令<code>sum+=S[k+p]-S[k]</code>，<code>k+=p</code>，<code>p*=2</code>，即累加上<code>p</code>个数的和，然后把<code>p</code>的跨度增长一倍，如果<code>sum+S[k+p]-S[k]&gt;T</code>，则另<code>p/=2</code>  </li>
<li>重复上一步，直至<code>p</code>的值变为<code>0</code>，此时<code>k</code>就是答案  </li>
</ol>
<p>这个算法始终在答案大小的范围内实施“倍增”与“二进制划分”的思想，通过若干长度为<code>2</code>的次幂的区间拼成最后的<code>k</code>，时间复杂度级别为答案的对数，能够应对<code>T</code>的各种大小情况  </p>
<h2 id="ACWING109-天才ACM"><a href="#ACWING109-天才ACM" class="headerlink" title="ACWING109.天才ACM"></a><a href="https://www.acwing.com/problem/content/111/" target="_blank" rel="noopener">ACWING109.天才ACM</a></h2><p>首先，对于一个集合<code>S</code>，显然应该取<code>S</code>中最大的<code>M</code>个数和最小的<code>M</code>个数，最大的和最小的构成一对、次大和次小构成一对…这样求出的校验值最大。而为了让数组<code>A</code>分成的段数最少，每一段都应该在校验值不超过<code>T</code>的情况下，尽量包含更多的数，所以我们从头开始对<code>A</code>进行分段，让每一段尽量长，到达结尾时分成的段数就是答案   </p>
<p>于是，需要解决的问题是：当确定一个左端点<code>L</code>之后，右端点<code>R</code>在满足<code>A[L]到A[R]</code>的校验值不超过<code>T</code>的前提下，最大能取到多少   </p>
<p>求长度为<code>N</code>的一段校验值需要排序配对，时间复杂度为<code>O(NlogN)</code>。当校验值上限<code>T</code>比较小时，如果在整个<code>L到N</code>的区间二分右端点<code>R</code>，二分第一步就要检验<code>(N-L)/2</code>这么长的一段，最终右端点<code>R</code>却可能只扩展了一点儿，浪费了很多时间。与上一道题目一样，我们需要一个与右端点<code>R</code>扩展的长度相适应的算法———倍增   </p>
<p>可以采用与上一题类似的倍增过程：  </p>
<ol>
<li>初始化<code>p=1</code>，<code>R=L</code></li>
<li>求出<code>[L,R+p]</code>这一段区间的校验值，若检验值小于等于<code>T</code>，则<code>R+=P</code>，<code>p*=2</code>，否则<code>P/=2</code>   </li>
<li>重复上一步，直到<code>p</code>的值变为<code>0</code>，此时<code>R</code>即为所求  </li>
</ol>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir(i, a, b) for (int i = a; i &lt;= b; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(a) (a) * (a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                  \</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);              \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, p[N], ans, l, r;</span><br><span class="line">ll b[N], a[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid, k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">            b[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b[k++] = a[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid)</span><br><span class="line">        b[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        b[k++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    fir(i, mid, r)</span><br><span class="line">        a[i] = p[i];</span><br><span class="line">    sort(a + mid, a + r + <span class="number">1</span>);</span><br><span class="line">    merge(l, mid, r);</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r - l + <span class="number">1</span> &gt;&gt; <span class="number">1</span> &amp;&amp; i &lt;= m; i++)</span><br><span class="line">        sum += sqr(b[r - i + <span class="number">1</span>] - b[l + i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">            a[i] = b[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    l = r = <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    fir(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    l = r = <span class="number">1</span>;</span><br><span class="line">    a[l] = p[l];</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= n)</span><br><span class="line">        <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">            ans++;</span><br><span class="line">            l = (++r);</span><br><span class="line">            a[l] = p[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r + len &lt;= n &amp;&amp; check(l, r + <span class="number">1</span>, r + len)) &#123;</span><br><span class="line">            r += len;</span><br><span class="line">            len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            len &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == n)</span><br><span class="line">        ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        work();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这题的代码差点儿把我杀死，不写了，未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hef994b8d2de64cc38bd77fc14c753637d.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>0x16Trie</title>
    <url>/2020/06/07/0x16Trie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x16Trie"><a href="#0x16Trie" class="headerlink" title="0x16Trie"></a>0x16Trie</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><code>Trie</code>（字典树）是一种实现字符串快速检索的多叉树结构。<code>Trie</code>的每个节点都拥有若干个字符指针，若在插入或检索字符串时扫描到一个字符<code>C</code>，就沿着当前节点的<code>C</code>字符指针，走到该指针指向的节点。下面我们来详细讨论<code>Trie</code>的基本操作过程   </p>
<ol>
<li>初始化<br>一棵空<code>Trie</code>仅包含一个根节点，该点的字符指针均指向空</li>
<li>插入<br>当需要插入一个字符串<code>S</code>时，我们令一个指针<code>P</code>起初指向根节点，然后依次扫描<code>S</code>中的每个字符<code>C</code>：<ol>
<li>若<code>P</code>的<code>C</code>字符指针指向一个已经存在的节点<code>Q</code>，则令<code>P=Q</code></li>
<li>若<code>P</code>的<code>C</code>字符指针指向空，则新建一个节点<code>Q</code>，令<code>P</code>的<code>C</code>字符指针指向<code>Q</code>，然后令<code>P=Q</code></li>
<li>当<code>S</code>中的字符扫描完毕时，在当前<code>P</code>节点上标记它是一个字符串的末尾</li>
</ol>
</li>
<li>检索<br>当需要检索一个字符串<code>S</code>在<code>Trie</code>中是否存在时，我们另一个指针<code>P</code>起初指向根节点，然后依次扫描<code>S</code>中的每个字符<code>C</code><ol>
<li>若<code>P</code>的<code>C</code>字符指针指向空，则说明<code>S</code>没有被插入过<code>Trie</code>，结束检索</li>
<li>若<code>P</code>的<code>C</code>字符指针指向一个已经存在的节点<code>Q</code>，则令<code>P=Q</code></li>
<li>当<code>S</code>中的字符串扫描完毕时，若当前节点<code>P</code>被标记为一个字符串的末尾，则说明<code>S</code>在<code>Trie</code>中存在，否则说明<code>S</code>没有被插入过<code>Trie</code></li>
</ol>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H77faad7230a142c39ea039f3c3c79af9Q.jpg" alt=""></p>
<p>在上图所示的例子中，需要插入和检索的字符串都由小写字母构成，所以<code>Trie</code>的每个节点具有<code>26</code>个字符指针，分别为<code>a</code>到<code>z</code>。上图展示了在一棵空树中依次插入<code>cab</code>、<code>cos</code>、<code>car</code>、<code>cat</code>、<code>cate</code>、<code>rain</code>后的<code>Trie</code>形态，绿色标记了单词的末尾节点。可以看出在<code>Trie</code>中，字符数据都体现在树的边（指针）上，树的节点仅保存一些额外信息，例如单词结尾标记等，其空间复杂度是<code>O(NC)</code>，其中<code>N</code>是节点个数，<code>C</code>是字符集的大小  </p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// idx为节点的编号</span></span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING142-前缀统计"><a href="#ACWING142-前缀统计" class="headerlink" title="ACWING142.前缀统计"></a><a href="https://www.acwing.com/problem/content/144/" target="_blank" rel="noopener">ACWING142.前缀统计</a></h2><p>把这<code>N</code>个字符串插入一棵<code>Trie</code>树，<code>Trie</code>树的每个节点上存储一个整数<code>cnt</code>，记录该节点是多少个字符串的末尾节点（为了处理插入重复字符串的情况，这里要记录个数，而不能只做结尾标记），对于每个询问，在<code>Trie</code>树中检索要查询的串的每个子串，在检索的过程中累加每次子串查询得到的<code>cnt</code>值，最后得到最终答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][temp]) son[p][temp] = ++idx;</span><br><span class="line">        p = son[p][temp];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][temp]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][temp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            ans += query(s.substr(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="143-最大异或对"><a href="#143-最大异或对" class="headerlink" title="143.最大异或对"></a><a href="https://www.acwing.com/problem/content/description/145/" target="_blank" rel="noopener">143.最大异或对</a></h2><p>我们首先想到的是朴素算法，暴力的在所有数中枚举两个数使这两个数做<code>XOR</code>运算的值最大，但是由于数据范围过大，这种算法是超时的，所以我们需要考虑其他思路   </p>
<p>朴素的算法是两层嵌套的<code>for</code>循环，我们可以优化朴素算法，借助<code>Trie</code>把第二层<code>for</code>循环从<code>O(N)</code>优化到<code>O(30)</code>，这样其时间复杂度就由<code>O(N*N)</code>变成了<code>O(30*N)</code>    </p>
<p>我们可以把每个整数看作其二进制位数为<code>31</code>的<code>01</code>字符串，当数值较小时在前补<code>0</code>（因为题目要求所有数大于<code>0</code>，而最高位存储的是符号位，所以最高位一定为<code>0</code>，做异或运算无意义，因此为<code>31</code>位），我们把把每个数的二进制串插入到<code>Tire</code>中（其中叶子节点为最低位），接下来假如第一重<code>for</code>循环枚举到<code>Ai</code>，那我们需要找到与<code>Ai</code>对应的整数，使其与<code>Ai</code>做异或运算的值最大，当我们从最高位开始找<code>Ai</code>对应的整数时，因为<code>XOR</code>运算“相同得<code>0</code>，不同得<code>1</code>”的性质，我们每次都希望找到与<code>Ai</code>对应位的相反的数（为<code>0</code>找<code>1</code>，为<code>1</code>找<code>0</code>），这样才能使两个数对应位做异或运算后为<code>1</code>，得到的值才尽可能大，如果“与<code>Ai</code>的当前为相反的字符指针”指向空节点，则只好访问与<code>Ai</code>当前位相同的字符指针，这样就可以找到所有数中和<code>Ai</code>做异或运算值最大的数   </p>
<p><img src="https://ae01.alicdn.com/kf/H75c88544d85c41b6a1c91b076ab0aa19J.jpg" alt=""></p>
<p>这就是这道题的思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">3100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[M][<span class="number">2</span>], a[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (son[p][!u]) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, search(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还差一道题</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hb792fbc57db34e61a8ee7483d8f04dd01.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>0x13链表与邻接表</title>
    <url>/2020/06/11/0x13%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x13链表与邻接表"><a href="#0x13链表与邻接表" class="headerlink" title="0x13链表与邻接表"></a>0x13链表与邻接表</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>为了避免双向链表在左右两端或者空链表中访问越界，我们通常建立额外的两个节点<code>head</code>与<code>tail</code>代表链表头尾，把实际数据节点存储在<code>head</code>与<code>tail</code>之间，来减少链表边界处的判断，降低编程复杂度</p>
<h3 id="ACWING136-邻值查找"><a href="#ACWING136-邻值查找" class="headerlink" title="ACWING136.邻值查找"></a><a href="https://www.acwing.com/problem/content/138/" target="_blank" rel="noopener">ACWING136.邻值查找</a></h3><p>解法一：链表</p>
<p>读入数据后串成链表，再对数组排序，此时找第<code>N</code>个数的前驱和后继，比较<code>N</code>与前驱、后继的差的绝对值，得到目标值后，再删除<code>N</code>，继续找<code>N-1</code>的前驱、后继，时间复杂度为<code>O(NlogN)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line">PII a[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].first;</span><br><span class="line">        a[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        l[i] = i - <span class="number">1</span>, r[i] = i + <span class="number">1</span>;</span><br><span class="line">        p[a[i].second] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>].first = <span class="number">0xffffffff</span>;</span><br><span class="line">    a[n + <span class="number">1</span>].first = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = p[i], left = l[j], right = r[j];</span><br><span class="line">        <span class="keyword">int</span> lv = <span class="built_in">abs</span>(a[left].first - a[j].first);</span><br><span class="line">        <span class="keyword">int</span> rv = <span class="built_in">abs</span>(a[right].first - a[j].first);</span><br><span class="line">        <span class="keyword">if</span> (lv &lt;= rv) ans[i] = &#123;lv, a[left].second&#125;;</span><br><span class="line">        <span class="keyword">else</span> ans[i] = &#123;rv, a[right].second&#125;;</span><br><span class="line">        l[right] = left, r[left] = right;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt; ans[i].first &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[i].second &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二：平衡树</p>
<p>把<code>A1 A2 A3 ... An</code>依次插入一个集合，则在插入<code>Ai</code>之前，集合中保存的就是满足<code>1&lt;=J&lt;i</code>的所有<code>Aj</code>。根据题意，我们只需在集合中查找与<code>Ai</code>最接近的值</p>
<p>若能维护一个有序集合，则集合中与<code>Ai</code>最接近的值一定在<code>Ai</code>的前驱与后继当中，比较前驱与后继与<code>Ai</code>的差即可   </p>
<p>而平衡二叉树就是一个支持动态插入、查询前驱以及查询后继的数据结构。在<code>C++</code>中，<code>STLset</code>也为我们提供了这些功能</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表是树与图的一般化存储方式，还能用于实现开散列<code>Hash</code>表。实际上，邻接表可以看成“带有索引数组的多个数据链表”构成的结构集合。在这样的结构中存储的数据会被分成若干类，每一类的数据构成一个链表，每一类还有一个代表元素，称为该类对应链表的表头。所有表头构成一个表头数组，作为一个可以随机访问的索引，从而可以通过表头数组定位到每一类数据对应的链表</p>
<p>在一个具有<code>N</code>个点<code>M</code>条边的有向图结构中，我们可以把每条边所属的“类别”定义为该边的起点标号。这样所有边被分为<code>N</code>类，其中第<code>X</code>类就由“从<code>X</code>出发的所有边”组成。通过表头<code>head[X]</code>，我们很容易定位到第<code>X</code>类对应的链表，从而访问从点<code>X</code>出发的所有边</p>
<p>对于无向图，我们把每条无向边看作两条有向边插入即可。有一个小技巧是，结合成对变换的位运算性质，我们可以在程序最开始时，把第一条边存储在<code>2 3</code>位置上，这样每条边都会存储在<code>2 3 4 5</code>这样的位置上。通过对下标进行<code>XOR 1</code>的运算，就可以直接定位到与当前边反向的边。换句话说，如果<code>ver[i]</code>时第<code>i</code>条边的终点，那么<code>ver[i xor 1]</code>时第<code>i</code>条边的起点</p>
<p><img src="https://ae01.alicdn.com/kf/H0ad54ff7541c4354884259942c0c3c0f1.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>2020/6/12未来规划粗略总结</title>
    <url>/2020/06/12/2020-6-12%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92%E7%B2%97%E7%95%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS.</p>
</blockquote>
<hr>
<h1 id="个人未来规划以及此公众号发展方向的一些调整"><a href="#个人未来规划以及此公众号发展方向的一些调整" class="headerlink" title="个人未来规划以及此公众号发展方向的一些调整"></a>个人未来规划以及此公众号发展方向的一些调整</h1><p>因为我正在学习数据结构与算法，所以目前会把这方面做好，所以陆续会出文章讲解这方面的知识，由于我是搞ACM的，所以所有文章都是以竞赛的标准去总结的，所以无论各位读者的目的是为了工作还是为了学校学习的绩点，甚至是某些照顾我的前辈读者，我相信且有信心大家能从中收获许多</p>
<p>转眼间我已经快大二了，ACM是个无底洞，不能一直搞，得留一条后路</p>
<p>ACM能拿到成绩保研最好，准备的后路就是毕业工作，争取进大厂，银牌可能保研去不上好学校，但银牌起码是大厂一块基本的敲门砖，所以我的成绩起码为银牌</p>
<p>这都是后话，既然我热爱ACM，热爱算法，能投身于此，已经足够快乐了，不是吗</p>
<p>虽然说是留一条后路，但是计算机网络、数据库、操作系统那些东西对我而言并不是枯燥无味的，我和爱ACM一样热爱他们，因为它们都属于编程这一类，所以学起来应该没问题</p>
<p>我计划利用大一这即将到来的最后一个长假，来把ACM基础算法啃完，至少啃完一本基础的竞赛书，并做足够的题</p>
<p>至于编程之路，算法只是其中的一小部分，我目前还掌握一些SQL语句、计算机网络基础、python基本语法、C/C++基本语法、java基本语法，其中语言只有C++由系统学习过，读完一本大砖头《C++PrimerPlus》，别的语言没有看过经典书、只是看了入门书或者视频</p>
<p>目前阶段是搞算法竞赛，等到大二开始就每天抽出五小时准备后路（深入编程之路），个人方向还没有选好，先挑基础的开始学习，如linux操作系统，虽然已经明确python不是自己未来主流语言，但是还是决定从大二开始也要逐渐深入python（花闲余时间）</p>
<p>至于大三，就开始去找实习了，这就是目前的规划了，希望有建议的前辈指教</p>
<p>今天早睡，哈哈，明天开始我的复国大计</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/148c824d-4eb8-48d3-9825-51625347b0f0.png" alt=""></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>0x04二分</title>
    <url>/2020/05/31/0x04%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x04二分"><a href="#0x04二分" class="headerlink" title="0x04二分"></a>0x04二分</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>二分的基础的用法是在单调序列或单调函数中进行查找，因此当问题的答案具有单调性时，就可以通过二分把求解问题转换为判定（根据复杂度理论，判定的难度小于求解），进一步地，我们还可以扩展到通过三分法去解决单峰函数的极值以及相关问题</p>
<p>对于整数域上的二分，需要注意中止边界、左右区间取舍时的开闭情况，避免漏掉答案或者造成死循环；对于实数域上的二分，需要注意精度问题</p>
<h2 id="整数集合上的二分"><a href="#整数集合上的二分" class="headerlink" title="整数集合上的二分"></a>整数集合上的二分</h2><p>本文章的写法保证最终答案处于闭区间<code>[l,r]</code>以内，循环以<code>l=r</code>结束，每次二分的中间值<code>mid</code>会归属于左半段与右半段二者之一</p>
<p><strong>模板如下</strong>：</p>
<p>在单调递增序列<code>a</code>中查找<code>&gt;=x</code>的数中最小的一个（<code>x</code>或<code>x</code>的后继）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= x) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[l];</span><br></pre></td></tr></table></figure><br>在单调递增序列<code>a</code>中查找<code>&lt;=x</code>的数中最大的一个（<code>x</code>或<code>x</code>的前驱）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt;= x) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[l];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如上面两段代码所示，这种二分写法可能会有两种形式：<br>1.缩小范围时，<code>r=mid</code>， <code>l=mid+1</code>，取中间值时，<code>mid=(l+r)&gt;&gt;1</code><br>2.缩小范围时，<code>l=mid</code>， <code>r=mid-1</code>，取中间值时，<code>mid=(l+r+1)&gt;&gt;1</code><br>如果不对<code>mid</code>的取法加以区分，假如第二段代码也采用<code>mid=(l+r)&gt;&gt;1</code>，那么当<code>r-l</code>等于<code>1</code>时，就有<code>mid=(l+r)&gt;&gt;1=l</code>，接下来若进入<code>l=mid</code>分支，可行区间未缩小，造成死循环；若进入<code>r=mid-1</code>分支，造成<code>l&gt;r</code>，循环不能以<code>l=r</code>结束；相反若<code>mid=(l+r+1)&gt;&gt;1</code> ，则第二段代码则正确得到结果。因此对两个形式采用配套的<code>mid</code>取法是必要的。此外还要注意：我们在二分实现中采用了右移运算符<code>&gt;&gt;1</code>，而不是整数除法<code>/2</code>。这是因为右移运算是向下取整，而整数除法是向<code>0</code>取整，在二分值域包含负数时后者不能正常工作。</p>
</blockquote>
<p><strong>我用一个例题来体现这两个模板的差别</strong>：<br><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">ACWING789.数的范围</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> nums[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= x) r = mid; <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != x) <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt;= x) l = mid; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出这两个模板的另一个区别：当目标值不止一个时，第一个模板是取到左边，也就是在单调递增序列<code>a</code>中查找<code>&gt;=x</code>的数中最小的一个；第二个模板是取到右边，也就是在单调递增序列<code>a</code>中查找<code>&lt;=x</code>的数中最大的一个；当目标值只有只有一个时，两个模板的结果没有差别  </p>
<p>仔细分析这两种<code>mid</code>的取法，我们还发现：<code>mid=(l+r)&gt;&gt;1</code>不会取到<code>r</code>这个值，<code>mid=(l+r+1)&gt;&gt;1</code>不会取到<code>l</code>这个值，我们可以利用这一性质来处理无解的情况，把最初的二分区间分别扩大为<code>[1,n+1]</code>和<code>[0,n]</code>，把<code>a</code>数组的一个越界下标包含进来。如果最后二分终止于扩大后的这个越界下标上，则说明目标值不在<code>a</code>中；当然我们也可以直接看最终求得的<code>l</code>下标在<code>a</code>数组中对应的值是否为目标值  </p>
<p>二分的终止条件就是<code>l==r</code>，该值就是答案所在位置</p>
<p><code>C++STL</code>的<code>lower_bound</code>和<code>upper_bound</code>函数实现了在一个序列中二分查找某个整数<code>x</code>的后继</p>
<blockquote>
<p>未完待续</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>0x07贪心</title>
    <url>/2020/06/02/0x07%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="0x07贪心"><a href="#0x07贪心" class="headerlink" title="0x07贪心"></a>0x07贪心</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>贪心是一种在每次决策时采取当前意义下最优策略的算法，因此，使用贪心法要求问题的整体最优性可以由局部最优性导出。贪心算法的正确性需要证明，常见的证明手段有：  </p>
<ol>
<li>微扰（邻项交换）<br>证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果的变差，经常用于以“排序”为贪心策略的证明</li>
<li>范围缩放<br>证明任何对局部最优策略作用范围的扩展都不会造成整体结果的变差  </li>
<li>决策包容性<br>证明在任意局面下，做出局部最优策略以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略的可能性包含其他所有策略提供的可能性  </li>
<li>反证法</li>
<li>数学归纳法</li>
</ol>
<blockquote>
<p>我们通过几道例题来介绍贪心算法的应用</p>
</blockquote>
<h2 id="ACWING110-防晒"><a href="#ACWING110-防晒" class="headerlink" title="ACWING110.防晒"></a><a href="https://www.acwing.com/problem/content/112/" target="_blank" rel="noopener">ACWING110.防晒</a></h2><p>按照<code>minSPF</code>递减的顺序把奶牛排序，依次考虑每头奶牛  </p>
<p>对于每头奶牛，扫描一遍所有的防晒霜，在这头奶牛能用（能用指的是该防晒霜的强度符合这头奶牛的范围，并且瓶数还有剩余）的防晒霜里找<code>SPF</code>值最大的使用  </p>
<p>以上算法的贪心策略是在满足条件的前提下每次选择<code>SPF</code>最大的防晒霜，这个策略正确的原因是：我们考虑这一步策略的作用范围扩展到后续其他奶牛之后产生的影响。每瓶防晒霜是否可用，会被<code>minSPF</code>和<code>maxSPF</code>两个条件限制，因为奶牛已经按照<code>minSPF</code>递减排序，所以每一个不低于当前奶牛<code>minSPF</code>值的防晒霜，都不会低于后面其他奶牛的<code>minSPF</code>。也就是说，对于当前奶牛可用的任意两瓶防晒霜<code>x</code>和<code>y</code>，如果<code>SFP[X]&lt;SFP[y]</code>，那么后面的奶牛只可能出现三种情况之一  </p>
<ol>
<li><p><code>x</code>和<code>y</code>都能用<br><img src="https://ae01.alicdn.com/kf/H2cc96d8dff754e51a734da64de4234dd0.jpg" alt=""></p>
</li>
<li><p><code>x</code>和<code>y</code>都不能用<br><img src="https://ae01.alicdn.com/kf/H9ee214eba1ab4d3db7de671fcec790cfN.jpg" alt=""></p>
</li>
<li><p><code>x</code>能用，<code>y</code>不能用<br><img src="https://ae01.alicdn.com/kf/H956b6a5e4b7743629416b5c1c262da0bn.jpg" alt=""></p>
</li>
</ol>
<p>因此当前奶牛选择较大的<code>y</code>去用，对于整体的影响肯定比选择较小的<code>x</code>去用要好，另外，每头奶牛对答案的贡献至多是<code>1</code>，即使让当前奶牛放弃日光浴，留下防晒霜给后面的某一头奶牛去用，对答案的贡献也不会更大，综上所述，尽量满足当前的奶牛，并选择<code>SPF</code>值尽量大的防晒霜是一个正确的贪心策略</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2510</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">PII cows[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; spfs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; cows[i].first &gt;&gt; cows[i].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> spf, cover;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; spf &gt;&gt; cover;</span><br><span class="line">        spfs[spf] += cover;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows, cows + n);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    spfs[<span class="number">0</span>] = spfs[<span class="number">1001</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">auto</span> spf = spfs.upper_bound(cows[i].second);</span><br><span class="line">        spf--;</span><br><span class="line">        <span class="keyword">if</span> (spf-&gt;first &gt;= cows[i].first) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (--spf-&gt;second == <span class="number">0</span>)</span><br><span class="line">                spfs.erase(spf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACWING111-畜栏预定"><a href="#ACWING111-畜栏预定" class="headerlink" title="ACWING111.畜栏预定"></a><a href="https://www.acwing.com/problem/content/113/" target="_blank" rel="noopener">ACWING111.畜栏预定</a></h2><p>按照开始吃草的时间把牛排序，用小根堆维护所有畜栏中最后一头牛结束吃草的时间的最小值，每循环到一头牛，如果这头牛的吃草开始时间比这个小根堆的堆顶大，则把这个牛插入到这个小根堆堆顶对应的畜栏中，再重新维护小根堆；如果小根堆的堆顶比这头牛的开始吃草时间大，则新建一个畜栏，插入到小根堆中</p>
<p>这种策略成功的原因在于：把每个畜栏的时间都充分利用，如果存在多个畜栏可以存放此牛，则选择最后一头牛结束吃草时间最小的畜栏，这样可以充分利用每个畜栏的时间；把每个牛的开始吃草时间从小到大排序的原因是，这样就可以让后面的牛插入在畜栏的后面，如果不排序，则每个畜栏前面可能有时间空隙放牛，这是不符合要求的，很难做出来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line">pair&lt;PII, <span class="keyword">int</span>&gt; cows[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cows[i].first.first &gt;&gt; cows[i].first.second;</span><br><span class="line">        cows[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(cows, cows + n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.empty() || heap.top().first &gt;= cows[i].first.first) &#123;</span><br><span class="line">            id[cows[i].second] = heap.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">            heap.push(&#123;cows[i].first.second, heap.<span class="built_in">size</span>() + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> stall = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            stall.first = cows[i].first.second;</span><br><span class="line">            id[cows[i].second] = stall.second;</span><br><span class="line">            heap.push(stall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; heap.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; id[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/Hef70c4f4a75e40738e47ea16124d9091W.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>API之stringstream用法</title>
    <url>/2020/05/30/API%E4%B9%8Bstringstream%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之stringstream用法"><a href="#API之stringstream用法" class="headerlink" title="API之stringstream用法"></a>API之stringstream用法</h1><p>本文主要介绍 C++ 中 stringstream 类的常见用法。</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><code>&lt;sstream&gt;</code>定义了三个类：<code>istringstream</code>、<code>ostringstream</code>和<code>stringstream</code>，分别用来进行流的输入、输出和输入输出操作。本文以<code>stringstream</code>为主，介绍流的输入和输出操作</p>
<p><code>&lt;sstream&gt;</code>主要用来进行数据类型转换，由于<code>&lt;sstream&gt;</code>使用<code>string</code>对象来代替字符数组（<code>snprintf</code>方式），就避免缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符的问题。简单说，相比c库的数据类型转换而言，<code>&lt;sstream&gt;</code>更加安全、自动和直接</p>
<h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h2><h3 id="2-1数据类型转换"><a href="#2-1数据类型转换" class="headerlink" title="2.1数据类型转换"></a>2.1数据类型转换</h3><p>这里展示一个代码示例，该示例介绍了将<code>int</code>类型转换为<code>string</code>类型的过程。示例代码（<code>stringstream_test1.cpp</code>）如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line">    <span class="built_in">string</span> strResult;</span><br><span class="line">    <span class="keyword">int</span> nValue = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将int类型的值放入输入流中</span></span><br><span class="line">    sstream &lt;&lt; nValue;</span><br><span class="line">    <span class="comment">// 从sstream中抽取前面插入的int类型的值，赋给string类型</span></span><br><span class="line">    sstream &gt;&gt; strResult;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[cout]strResult is: "</span> &lt;&lt; strResult &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[printf]strResult is: %s\n"</span>, strResult.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[cout]strResult is: 1000   </span><br><span class="line">[printf]strResult is: 1000</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2多个字符串拼接"><a href="#2-2多个字符串拼接" class="headerlink" title="2.2多个字符串拼接"></a>2.2多个字符串拼接</h3><p>本示例介绍在<code>stringstream</code>中存放多个字符串，实现多个字符串拼接的目的（其实完全可以使用 <code>string</code>类实现），同时，介绍<code>stringstream</code>的清空方法。示例代码（<code>stringstream_test2.cpp</code>）如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">"first"</span></span><br><span class="line">            &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; <span class="string">"string,"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">" second string"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strResult is: "</span> &lt;&lt; sstream.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 sstream</span></span><br><span class="line">    sstream.str(<span class="string">""</span>);</span><br><span class="line">    sstream &lt;&lt; <span class="string">"third string"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After clear, strResult is: "</span> &lt;&lt; sstream.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strResult is: first string, second string</span><br><span class="line">After clear, strResult is: third string</span><br></pre></td></tr></table></figure></p>
<p>从上述代码执行结果能够知道：</p>
<ul>
<li>可以使用<code>str()</code>方法，将<code>stringstream</code>类型转换为<code>string</code>类型</li>
<li>可以将多个字符串放入<code>stringstream</code>中，实现字符串的拼接目的</li>
<li>如果想清空<code>stringstream</code>，必须使用<code>sstream.str(&quot;&quot;)</code>; 方式:<code>clear()</code>方法适用于进行多次数据类型转换的场景。详见示例<code>2.3</code></li>
</ul>
<h3 id="2-3stringstream的清空"><a href="#2-3stringstream的清空" class="headerlink" title="2.3stringstream的清空"></a>2.3stringstream的清空</h3><p>清空<code>stringstream</code>有两种方法：<code>clear()</code>方法以及<code>str(&quot;&quot;)</code>方法，这两种方法有不同的使用场景。<code>str(&quot;&quot;)</code>方法的使用场景，在上面的示例中已经介绍了，这里介绍<code>clear()</code>方法的使用场景。示例代码（<code>stringstream_test3.cpp</code>）如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line">    <span class="keyword">int</span> first, second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符串</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">"456"</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; first;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在进行多次类型转换前，必须先运行clear()</span></span><br><span class="line">    sstream.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入bool值</span></span><br><span class="line">    sstream &lt;&lt; <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; second;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">456</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>注意：在本示例涉及的场景下（多次数据类型转换），必须使用<code>clear()</code>方法清空<code>stringstream</code>，不使用<code>clear()</code>方法或使用<code>str(&quot;&quot;)</code>方法，都不能得到数据类型转换的正确结果。下图分别是未使用<code>clear()</code>方法、使用<code>str(&quot;&quot;)</code>方法时的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">456</span><br><span class="line">4197008</span><br><span class="line"></span><br><span class="line">456</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="2-4测试"><a href="#2-4测试" class="headerlink" title="2.4测试"></a>2.4测试</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">"firstiiii"</span></span><br><span class="line">            &lt;&lt; <span class="string">" "</span></span><br><span class="line">            &lt;&lt; <span class="string">"string,"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">" second string"</span>;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    sstream &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strResult is: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sstream &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strResult is: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sstream.str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strResult is: firstiiii</span><br><span class="line">strResult is: string,</span><br><span class="line">firstiiii string, second string</span><br></pre></td></tr></table></figure><br>由此可知，我们可以用它来分割字符串中的单词</p>
<h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h2><p><a href="https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">LEETCODE1455. 检查单词是否为句中其他单词的前缀</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isPrefixOfWord</span><span class="params">(<span class="built_in">string</span> sentence, <span class="built_in">string</span> searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ssin</span><span class="params">(sentence)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ssin &gt;&gt; <span class="keyword">word</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">word</span>.substr(<span class="number">0</span>, searchWord.<span class="built_in">size</span>()) == searchWord)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H0b4d4cb9ed5441f7b122f043b18076c9H.jpg" alt=""></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>2020/6/12博客更新总结</title>
    <url>/2020/06/12/2020-6-12%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2020-6-12博客更新总结"><a href="#2020-6-12博客更新总结" class="headerlink" title="2020/6/12博客更新总结"></a>2020/6/12博客更新总结</h1><p>觉得博客太乱了，文章发布的太频繁，所以把一些文章合并了，也重新整理了一下标签和分类</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>ACM</li>
<li>C/C++</li>
<li>CODEFORCES</li>
<li>LEETCODE</li>
<li>PYTHON</li>
<li>博客搭建</li>
<li>计算机网络</li>
</ul>
<p>目前的分类就这么多，日后还会再加</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul>
<li>C/C++常用API</li>
<li>CODEFORCES/比赛</li>
<li>LEETCODE/比赛</li>
<li>PYTHON语法</li>
<li>力扣/python</li>
<li>博客搭建</li>
<li>算法竞赛进阶指南</li>
<li>计算机网络</li>
</ul>
<p>日后还会添加具体算法的标签，例如：</p>
<ul>
<li>bfs</li>
<li>dfs</li>
<li>trie</li>
<li>two points</li>
<li>sort</li>
</ul>
<h2 id="重点改进"><a href="#重点改进" class="headerlink" title="重点改进"></a>重点改进</h2><p>把<code>python</code>解力扣的文章合为一起，每一百篇题解算一篇文章，这样就减去了一些水文</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>0x21树与图的遍历</title>
    <url>/2020/06/11/0x21%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法竞赛进阶指南</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点</title>
    <url>/2020/05/04/PYTHON%E4%B8%ADisdigit-%E3%80%81isalpha-%E3%80%81isalnum-%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点"><a href="#PYTHON中isdigit-、isalpha-、isalnum-三个函数的区别和注意点" class="headerlink" title="PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点"></a>PYTHON中isdigit()、isalpha()、isalnum()三个函数的区别和注意点</h1><h2 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit()"></a>isdigit()</h2><p><code>python</code>关于<code>isdigit()</code>内置函数的官方定义：  </p>
<blockquote>
<p>S.isdigit() -&gt; bool<br>        Return True if all characters in S are digits<br>        and there is at least one character in S, False otherwise.    </p>
</blockquote>
<p>翻译：</p>
<p><code>S.isdigit()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>字符串中至少有一个字符且如果<code>S</code>中的所有字符都是数字，那么返回结果就是<code>True</code>；否则，就返回<code>False</code>   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S1 = <span class="string">'12345'</span>       <span class="comment">#纯数字</span></span><br><span class="line">S2 = <span class="string">'①②'</span>          <span class="comment">#带圈的数字</span></span><br><span class="line">S3 = <span class="string">'汉字'</span>        <span class="comment">#汉字</span></span><br><span class="line">S4 = <span class="string">'%#￥'</span>        <span class="comment">#特殊符号</span></span><br><span class="line">S5 = <span class="string">'12345a'</span>      <span class="comment">#数字和字母</span></span><br><span class="line"></span><br><span class="line">print(S1.isdigit())</span><br><span class="line">print(S2.isdigit())</span><br><span class="line">print(S3.isdigit())</span><br><span class="line">print(S4.isdigit())</span><br><span class="line">print(S5.isdigit())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果：</span></span><br><span class="line"><span class="literal">True</span>     </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="isalpha"><a href="#isalpha" class="headerlink" title="isalpha()"></a>isalpha()</h2><p><code>python</code>关于<code>isalpha()</code>内置函数的官方定义：</p>
<blockquote>
<p>S.isalpha() -&gt; bool<br>        Return True if all characters in S are alphabetic<br>        and there is at least one character in S, False otherwise.</p>
</blockquote>
<p>翻译：<br><code>S.isalpha()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>字符串中至少有一个字符且如果S中的所有字符都是字母，那么返回结果就是<code>True</code>；否则，就返回<code>False</code>   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S1 = <span class="string">'abc汉字'</span>     <span class="comment">#汉字+字母</span></span><br><span class="line">S2 = <span class="string">'ab字134'</span>     <span class="comment">#包含数字</span></span><br><span class="line">S3 = <span class="string">'*&amp;&amp;'</span>         <span class="comment">#特殊符号</span></span><br><span class="line"></span><br><span class="line">print(S1.isalpha())</span><br><span class="line">print(S2.isalpha())</span><br><span class="line">print(S3.isalpha())</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum()"></a>isalnum()</h2><p><code>python</code>关于<code>isalnum()</code>内置函数的官方定义：  </p>
<blockquote>
<p>S.isalnum() -&gt; bool<br>        Return True if all characters in S are alphanumeric<br>        and there is at least one character in S, False otherwise.</p>
</blockquote>
<p>翻译：  </p>
<p><code>S.isalnum()</code>返回的是布尔值：<code>True</code>、<code>False</code><br><code>S</code>中至少有一个字符且如果<code>S</code>中的所有字符都是字母数字，那么返回结果就是<code>True</code>；否则，就返回<code>False</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S1 = <span class="string">'abc汉字1'</span>    <span class="comment">#字母+汉字+数字</span></span><br><span class="line">S2 = <span class="string">'①②③'</span>      <span class="comment">#带圈的数字</span></span><br><span class="line">S3 = <span class="string">'%……&amp;'</span>       <span class="comment">#特殊符号</span></span><br><span class="line"></span><br><span class="line">print(S1.isalnum())</span><br><span class="line">print(S2.isalnum())</span><br><span class="line">print(S3.isalnum())</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p><code>python</code>官方定义中的字母：大家默认为英文字母+汉字即可</p>
</li>
<li><p><code>python</code>官方定义中的数字：大家默认为<code>Unicode</code>数字、<code>byte</code>数字（单字节）、全角数字（双字节）、罗马数字、带圈的数字即可</p>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>API之to_string用法</title>
    <url>/2020/06/04/API%E4%B9%8Bto-string%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之to-string用法"><a href="#API之to-string用法" class="headerlink" title="API之to_string用法"></a>API之to_string用法</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">float</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">double</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>将数值转化为字符串。返回对应的字符串。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> pi = <span class="string">"pi is "</span> + <span class="built_in">std</span>::to_string(<span class="number">3.1415926</span>);</span><br><span class="line">    <span class="built_in">string</span> perfect = to_string(<span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">7</span> + <span class="number">14</span>) + <span class="string">" is a perfect number"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; perfect &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi is 3.141593</span><br><span class="line">28 is a perfect number</span><br></pre></td></tr></table></figure><br><img src="https://ae01.alicdn.com/kf/H0b4d4cb9ed5441f7b122f043b18076c9H.jpg" alt=""></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中join函数的用法</title>
    <url>/2020/05/04/PYTHON%E4%B8%ADjoin%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中join函数的用法"><a href="#PYTHON中join函数的用法" class="headerlink" title="PYTHON中join函数的用法"></a>PYTHON中join函数的用法</h1><p>Python中有<code>.join()</code>和<code>os.path.join()</code>两个函数，具体作用如下：  </p>
<p><code>.join()</code>：连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串<br><code>os.path.join()</code>：将多个路径组合后返回</p>
<h2 id="对序列进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对序列进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对序列进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对序列进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="string">' '</span>.join(a)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="string">''</span>.join(a)</span><br><span class="line"></span><br><span class="line"><span class="number">12345</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'-'</span>.jion(a)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'.'</span>.join(a)</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>
<h2 id="对字符串进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对字符串进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对字符串进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对字符串进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=<span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="string">' '</span>.join(b)</span><br><span class="line"></span><br><span class="line">h e l l o   w o r l d</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'-'</span> .join(b)</span><br><span class="line"></span><br><span class="line">h-e-l-l-o- -w-o-r-l-d</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">':'</span>.jion(b)</span><br><span class="line"></span><br><span class="line">h:e:l:l:o: :w:o:r:l:d</span><br></pre></td></tr></table></figure>
<h2 id="对元组进行操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对元组进行操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对元组进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对元组进行操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">' '</span>.join(c)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'-'</span>.join(c)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">':'</span>.join(c)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>:<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="对字典进行无序操作（分别使用’-‘、’-‘与’-’作为分隔符）"><a href="#对字典进行无序操作（分别使用’-‘、’-‘与’-’作为分隔符）" class="headerlink" title="对字典进行无序操作（分别使用’ ‘、’-‘与’:’作为分隔符）"></a>对字典进行无序操作（分别使用’ ‘、’-‘与’:’作为分隔符）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;<span class="string">'name1'</span>:<span class="string">'a'</span>,<span class="string">'name2'</span>:<span class="string">'b'</span>,<span class="string">'name3'</span>:<span class="string">'c'</span>,<span class="string">'name4'</span>:<span class="string">'d'</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">' '</span>.jion(d)</span><br><span class="line"></span><br><span class="line">name1 name2 name3 name4</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">'-'</span>.join(d)</span><br><span class="line"></span><br><span class="line">name1-name2-name3-name4</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">':'</span>.join(d)</span><br><span class="line"></span><br><span class="line">name1:name2:name3:name4</span><br></pre></td></tr></table></figure>
<h2 id="对目录进行操作"><a href="#对目录进行操作" class="headerlink" title="对目录进行操作"></a>对目录进行操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.path.join(<span class="string">'/hello/'</span>,<span class="string">'good/date'</span>,<span class="string">'datbody'</span>)</span><br><span class="line"></span><br><span class="line">hello/good/date/datbody</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中max函数的lambda表达式用法</title>
    <url>/2020/05/03/PYTHON%E4%B8%ADmax%E5%87%BD%E6%95%B0%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中max函数的lambda表达式用法"><a href="#PYTHON中max函数的lambda表达式用法" class="headerlink" title="PYTHON中max函数的lambda表达式用法"></a>PYTHON中max函数的lambda表达式用法</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>由一道<code>leetcode</code>题来引入<code>PYTHON</code>中<code>max</code>函数的<code>lambda</code>表达式用法<br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        p = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            p1 = self.get_palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            p2 = self.get_palindrome(s, i, i)</span><br><span class="line">            p = max([p, p1, p2], key=<span class="keyword">lambda</span> x: len(x))</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_palindrome</span><span class="params">(self, s: str, l: int, r: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br></pre></td></tr></table></figure>
<p><code>max([p, p1, p2], key=lambda x: len(x))</code>的含义就是本文章的内容</p>
<h2 id="lambda表达式介绍"><a href="#lambda表达式介绍" class="headerlink" title="lambda表达式介绍"></a>lambda表达式介绍</h2><p>在学习<code>python</code>的过程中，<code>lambda</code>的语法时常会使人感到困惑，<code>lambda</code>是什么，为什么要使用<code>lambda</code>，是不是必须使用<code>lambda</code>？</p>
<ol>
<li><code>lambda</code>是什么？<br>我们来看此表达式：<code>g = lambda x:x+1</code>，看一下执行的结果：<code>g(1)==2</code>、<code>g(2)==3</code>,当然，你也可以这样使用：<code>lambda x:x+1(1)</code>，结果为<code>2</code><br>可以这样认为,<code>lambda</code>作为一个表达式，定义了一个匿名函数，上例的代码<code>x</code>为入口参数，<code>x+1</code>为函数体，用函数来表示为:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><code>lambda</code>定义了一个匿名函数</li>
<li><code>lambda</code>并不会带来程序运行效率的提高，只会使代码更简洁</li>
<li>如果可以使用<code>for...in...if</code>来完成的，坚决不用<code>lambda</code></li>
<li>如果使用<code>lambda</code>，<code>lambda</code>内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。</li>
<li>总结：<code>lambda</code>是为了减少单行函数的定义而存在的</li>
</ol>
<h2 id="max函数中的lambda表达式"><a href="#max函数中的lambda表达式" class="headerlink" title="max函数中的lambda表达式"></a>max函数中的lambda表达式</h2><p>现在回到我们的max函数中，就十分容易理解了:<br>函数形式：<code>max( x ,key=lambda a : b )</code>，x可以是任何数值，可以有多个x值<br>这个函数的意思是：我们先把x值带入lambda函数转换成b值，然后再将b值进行比较<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">haha0=max(<span class="string">'az'</span>,<span class="string">'za'</span>, key=<span class="keyword">lambda</span> a: a[<span class="number">0</span>])</span><br><span class="line">haha1=max(<span class="string">'az'</span>,<span class="string">'za'</span>, key=<span class="keyword">lambda</span> a: a[<span class="number">1</span>])</span><br><span class="line">haha2=max(range(<span class="number">10</span>),key=<span class="keyword">lambda</span> a:a&gt;<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">print(haha0)        <span class="comment">#输出za</span></span><br><span class="line">print(haha1)        <span class="comment">#输出az</span></span><br><span class="line">print(haha2)        <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure></p>
<p>以<code>haha0</code>为例子：我们传入<code>az</code>，<code>za</code>，为了方便解释称之为虚拟比较，但是因为我们引入了<code>lambda</code>表达式，所以，我们实际上比较的是，<code>az</code>中的第一位<code>a</code>和<code>za</code>中第一位的<code>z</code>，由<code>ascii</code>码表可以知道<code>a</code>是小于<code>z</code>的，所以在这里最大的是<code>z</code>，那么我们返回的就是<code>z</code>的虚拟比较变量，也就是本来的<code>za</code>。</p>
<p><code>haha2</code>的用法十分少见，实际上比较的是:<br><code>F F F T T T T T T T ( False 和 True )</code></p>
<p><code>T</code>是肯定比<code>F</code>大的，但是一堆<code>True</code>哪里能互相比较大小呢，所以就输出第一个<code>True</code>值的虚拟比较变量，也就是<code>4</code></p>
<p><code>max</code>中带有<code>lambda</code>的这个写法的意义在于代码变得更简洁</p>
<p>假如我们有一个字典，里面记录着人名和相应年龄，现在我们想要在里面筛选出年龄最大的那个人的一条字典记录<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=&#123;<span class="string">"老王"</span> :<span class="number">18</span> , <span class="string">"小李"</span>:<span class="number">99</span>&#125;</span><br><span class="line">haha3=max(x.items(), key=<span class="keyword">lambda</span> a: a[<span class="number">1</span>])</span><br><span class="line">print(haha3)        <span class="comment">#输出('小李', 99)</span></span><br></pre></td></tr></table></figure></p>
<p>要注意使用字典的话一定要x.items()，不能直接输入x值，达不到我们想要的效果   </p>
<p>其实我们大可不必这么写，直接从字典中提取出年龄列表进行比较：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=&#123;<span class="string">"老王"</span> :<span class="number">18</span> , <span class="string">"小李"</span>:<span class="number">99</span>&#125;</span><br><span class="line">y=[]</span><br><span class="line"><span class="keyword">for</span> name,age <span class="keyword">in</span> x.items():</span><br><span class="line">    y.append(age)</span><br><span class="line">haha4=max(y)</span><br><span class="line">print(haha4)</span><br></pre></td></tr></table></figure></p>
<p>只是这样写是比较麻烦以及浪费内存的不是么？我想这就是<code>max</code>函数中设置<code>lambda</code>表达式的意义  </p>
<p>再举两个例子：    </p>
<ol>
<li>取第一维<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [(<span class="number">1</span>,<span class="number">2.5</span>), (<span class="number">1.5</span>, <span class="number">3.2</span>), (<span class="number">1.3</span>, <span class="number">4.0</span>), (<span class="number">2.2</span>, <span class="number">1.8</span>)]</span><br><span class="line">y,z = max(num, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">print(y, z)      <span class="comment">#结果为2.2 1.8</span></span><br></pre></td></tr></table></figure></li>
<li>取第二维<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [(<span class="number">1</span>,<span class="number">2.5</span>), (<span class="number">1.5</span>, <span class="number">3.2</span>), (<span class="number">1.3</span>, <span class="number">4.0</span>), (<span class="number">2.2</span>, <span class="number">1.8</span>)]</span><br><span class="line">y,z = max(num, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">print(y, z)      <span class="comment">#结果为1.3 4.0</span></span><br></pre></td></tr></table></figure>
<img src="https://ae01.alicdn.com/kf/H12f0feac72244f349b51fc9f740d048fh.jpg" alt=""></li>
</ol>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES/ROUND/648/DIV2</title>
    <url>/2020/06/10/CODEFORCES-ROUND-648-DIV2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CODEFORCES-ROUND-648-DIV2"><a href="#CODEFORCES-ROUND-648-DIV2" class="headerlink" title="CODEFORCES/ROUND/648/DIV2"></a>CODEFORCES/ROUND/648/DIV2</h1><h2 id="A-Matrix-Game"><a href="#A-Matrix-Game" class="headerlink" title="A.Matrix Game"></a><a href="https://codeforces.com/contest/1365/problem/A" target="_blank" rel="noopener">A.Matrix Game</a></h2><h3 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h3><p><code>1100</code>，标签：<code>implementation</code>   </p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>有一个<code>n</code>乘<code>m</code>的矩阵，由<code>0</code>和<code>1</code>组成，当一个<code>0</code>的同行同列没有<code>1</code>时，可以把这个<code>0</code>变为<code>1</code>，两个人轮流把<code>0</code>变成<code>1</code>，最后无法执行此操作的人输（也就是轮到某一人时，此时矩阵上剩余的<code>0</code>都无法变成<code>1</code>，此人输）</p>
<p>第一行输入测试次数，每次测试第一行输入<code>n</code>和<code>m</code>，然后<code>n</code>行输入矩阵元素（每行<code>m</code>个），输出最后获胜者</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思维题，读入的时候记录一下<code>1</code>所占的行和列数，用总的<code>n</code>和<code>m</code>减去行和列数求得剩余的行和列数，之后每翻一个<code>0</code>，此剩余的行数和列数减一，所以能翻的<code>0</code>的个数就是<code>min(剩余的行数,剩余的列数)</code>，用此最小值判断奇偶即可求出获胜者</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">                <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">                    a.insert(i);</span><br><span class="line">                    b.insert(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> aa = n - a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> bb = m - b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">min</span>(aa, bb);</span><br><span class="line">        <span class="keyword">if</span> (c % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Vivek"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Ashish"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Trouble-Sort"><a href="#B-Trouble-Sort" class="headerlink" title="B.Trouble Sort"></a><a href="https://codeforces.com/contest/1365/problem/B" target="_blank" rel="noopener">B.Trouble Sort</a></h2><h3 id="难度-1"><a href="#难度-1" class="headerlink" title="难度"></a>难度</h3><p><code>1300</code>，标签：<code>implementation</code></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>第一行输入测试数目，每次测试输入一个数<code>N</code>，代表数组的元素，接下来一行输入<code>N</code>的值代表数组中的元素，再下一行输入<code>N</code>个<code>0</code>或<code>1</code>代表此数组元素的类型，类型不同的元素可以交换，问能否通过交换让此数组变成升序排列 </p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>当这<code>N</code>个数由<code>0</code>和<code>1</code>组成时，一定可以换成升序排列，因为只要有一对类型不一样的值，它们就可以无限换，当这<code>N</code>个数全为<code>0</code>或<code>1</code>组成时，特判一下原本的数组是否为升序排序</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>;</span><br><span class="line"><span class="keyword">int</span> a1[N], a2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(a1, <span class="number">0</span>, <span class="keyword">sizeof</span> a1);</span><br><span class="line">        <span class="built_in">memset</span>(a2, <span class="number">0</span>, <span class="keyword">sizeof</span> a2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a1[i], a2[i] = a1[i];</span><br><span class="line">        <span class="keyword">int</span> flag0 = <span class="number">0</span>, flag1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0</span>) flag0 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> flag1 = <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag0 == <span class="number">1</span> &amp;&amp; flag1 == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sort(a1, a1 + n);</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a1[i] != a2[i]) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>; x = <span class="number">1</span>; <span class="keyword">break</span>;&#125;; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x==<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Rotation-Matching"><a href="#C-Rotation-Matching" class="headerlink" title="C.Rotation Matching"></a><a href="https://codeforces.com/contest/1365/problem/C" target="_blank" rel="noopener">C.Rotation Matching</a></h2><h3 id="难度-2"><a href="#难度-2" class="headerlink" title="难度"></a>难度</h3><p><code>1400</code>，标签：<code>implementation</code></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>输入一个数<code>N</code>，接下来两行每行输入<code>N</code>个数，代表数组<code>A</code>和<code>B</code>，<code>A</code>和<code>B</code>的元素值相同，但顺序不同，如果<code>A</code>和<code>B</code>数组下标相同的元素值相同，则称这两个元素相等，求执行某些操作后<code>A</code>数组中的元素与<code>B</code>数组中的元素相等的个数的最大值。操作为：把<code>A</code>或<code>B</code>数组的元素全部向左或向右循环移动任意位，如<code>A</code>为<code>1 2 3</code>则向左移动<code>1</code>位为<code>2 3 1</code></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>与其让两个数组移动，不如让一个数组固定，另一个数组移动，因为数据范围的限制，我们只能用<code>O(N)</code>的时间复杂度，假设我们规定都向右移，移动的数组为<code>A</code>，那么我们用哈希表记录<code>A</code>中每个元素向右移动到<code>B</code>中对应值的位数，最后取相同位数出现最多的次数即可</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        a[temp] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        b[(a[temp] - i + n) % n]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Solve-The-Maze"><a href="#D-Solve-The-Maze" class="headerlink" title="D.Solve The Maze"></a><a href="https://codeforces.com/contest/1365/problem/D" target="_blank" rel="noopener">D.Solve The Maze</a></h2><h3 id="难度-3"><a href="#难度-3" class="headerlink" title="难度"></a>难度</h3><p><code>1700</code>，标签：<code>bfs</code>  </p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个矩阵，<code>G</code>代表好人，<code>B</code>代表坏人，<code>#</code>代表墙，<code>.</code>代表空，你可以在<code>.</code>的地方加上墙，问能否让好人都到达矩阵的右下角，坏人都不能到达矩阵的右下角，输入的矩阵的右下角一定为<code>.</code>，其中<code>G、B、.</code>可以穿过，墙不能穿过，好人坏人只能上下左右移动</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>先把坏人四周加上墙，然后从右下角<code>BFS</code>检查能否到达所有好人，而不能到达所有坏人</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> arr[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">istrue</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m; &#125;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] == <span class="string">'B'</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> ni = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> nj = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (istrue(ni, nj) &amp;&amp; arr[ni][nj] == <span class="string">'.'</span>) </span><br><span class="line">                            arr[ni][nj] = <span class="string">'#'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">bool</span> v[n+<span class="number">5</span>][m+<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">        <span class="keyword">if</span> (arr[n][m] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            v[n][m] = <span class="number">1</span>;</span><br><span class="line">            que.push(&#123;n, m&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ni = cur.first + dir[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nj = cur.second + dir[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (istrue(ni, nj) &amp;&amp; !v[ni][nj] &amp;&amp; arr[ni][nj] != <span class="string">'#'</span>) &#123;</span><br><span class="line">                    que.push(&#123;ni, nj&#125;);</span><br><span class="line">                    v[ni][nj] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> good = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">if</span> ((arr[i][j] == <span class="string">'G'</span> <span class="keyword">and</span> !v[i][j]) <span class="keyword">or</span> (arr[i][j] == <span class="string">'B'</span> <span class="keyword">and</span> v[i][j])) &#123;</span><br><span class="line">                    good = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (good ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Maximum-Subsequence-Value"><a href="#E-Maximum-Subsequence-Value" class="headerlink" title="E.Maximum Subsequence Value"></a><a href="https://codeforces.com/contest/1365/problem/E" target="_blank" rel="noopener">E.Maximum Subsequence Value</a></h2><h3 id="难度-4"><a href="#难度-4" class="headerlink" title="难度"></a>难度</h3><p><code>1900</code>，标签：<code>brute force</code></p>
<h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>这道题语言无法形容，直接上图</p>
<p><img src="https://ae01.alicdn.com/kf/Hf485d5e0b9e348d7b936aa2ab358dcabm.jpg" alt=""></p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>鸽巢原理，当<code>n</code>小于三，<code>k</code>一定小于<code>3</code>，<code>max</code>为<code>1</code>，只要遍历<code>n</code>个数找或运算最大的就行了</p>
<p>当<code>n</code>大于<code>3</code>时，<code>K</code>可能大于<code>3</code>，因为<code>max</code>为<code>k-2</code>，所以三层枚举一定会枚举到一个算<code>i</code>的情况，如果再加一个数，原先是<code>0</code>的一定不能变成<code>1</code>，原先是<code>1</code>的反而可能变成<code>0</code>，范围反而变小，所以枚举<code>3</code>个就能找到最大值了</p>
<p>因为如果枚举<code>3</code>个或运算得到的结果某一位都为<code>0</code>，那么再加一个这一位为<code>1</code>的数，整体这一位也一定不为<code>1</code>，因为<code>max</code>为<code>k-2</code>，最多有两位<code>i</code>为<code>0</code>，三层枚举已经有三个为<code>0</code>了，由于数据范围很小，所以满足时间复杂度</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN =<span class="number">505</span>;</span><br><span class="line">ll arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,arr[i]|arr[j]|arr[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Swaps-Again"><a href="#F-Swaps-Again" class="headerlink" title="F.Swaps Again"></a><a href="https://codeforces.com/contest/1365/problem/F" target="_blank" rel="noopener">F.Swaps Again</a></h2><h3 id="难度-5"><a href="#难度-5" class="headerlink" title="难度"></a>难度</h3><p><code>2100</code>，标签：<code>constructive algorithms</code></p>
<h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给两个数组，可以把两个数组中相同位数的前缀和后缀互换位置，问多次操作后两个数组能否相等</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>做法：把<code>A</code>数组前后对应的放到一个<code>pair</code>里，然后检查<code>B</code>数组前半段的每个元素是否满足每个<code>pair</code>都占一个</p>
<p>证明：先推出来它可以随便交换左边第<code>x</code>和右边第<code>x</code>，然后推出来它可以<code>reverse</code>左边一个区间和右边对称区间。于是对于任意<code>pair</code>可以交换到任意位置，且任意<code>pair</code>内部可以交换</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; pairs;</span><br><span class="line">        vector&lt;int&gt; a(n), b(n);</span><br><span class="line">        <span class="keyword">bool</span> possible = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; a[n / <span class="number">2</span>] != b[n / <span class="number">2</span>])</span><br><span class="line">            possible = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = &#123;<span class="built_in">min</span>(a[i], a[n-i<span class="number">-1</span>]), <span class="built_in">max</span>(a[i],a[n-i<span class="number">-1</span>])&#125;;</span><br><span class="line">            pairs[p]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = &#123;<span class="built_in">min</span>(b[i], b[n - <span class="number">1</span> - i]), <span class="built_in">max</span>(b[i], b[n - <span class="number">1</span> - i])&#125;;</span><br><span class="line">            <span class="keyword">if</span> (pairs[p] &lt;= <span class="number">0</span>)</span><br><span class="line">                possible = <span class="number">0</span>;</span><br><span class="line">            pairs[p]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (possible)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Secure-Password"><a href="#G-Secure-Password" class="headerlink" title="G.Secure Password"></a><a href="https://codeforces.com/contest/1365/problem/G" target="_blank" rel="noopener">G.Secure Password</a></h2><blockquote>
<p>一道很难的交互题，超出能力范围，以后再写，未完待续</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/31/t1moIH.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES/比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中zip()与zip(*)的用法</title>
    <url>/2020/05/06/PYTHON%E4%B8%ADzip-%E4%B8%8Ezip-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中zip-与zip-的用法"><a href="#PYTHON中zip-与zip-的用法" class="headerlink" title="PYTHON中zip()与zip(*)的用法"></a>PYTHON中zip()与zip(*)的用法</h1><p>可以看成是<code>zip()</code>为压缩，<code>zip(*)</code>是解压</p>
<h2 id="zip-与zip"><a href="#zip-与zip" class="headerlink" title="zip()与zip(*)"></a>zip()与zip(*)</h2><p>举一个示例代码来说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">a_b_zip = zip(a, b)  <span class="comment"># 打包为元组的列表,而且元素个数与最短的列表一致</span></span><br><span class="line">print(<span class="string">"type of a_b_zip is %s"</span> % type(a_b_zip))  <span class="comment"># 输出zip函数的返回对象类型</span></span><br><span class="line">a_b_zip = list(a_b_zip)  <span class="comment"># 因为zip函数返回一个zip类型对象，所以需要转换为list类型</span></span><br><span class="line">print(a_b_zip)</span><br><span class="line">print(<span class="string">"------------------------------------------"</span>)</span><br><span class="line">a_c_zip = zip(a, c)</span><br><span class="line">a_c_zip = list(a_c_zip)</span><br><span class="line">print(a_c_zip)</span><br><span class="line"></span><br><span class="line">nums = [[<span class="string">'a1'</span>, <span class="string">'a2'</span>, <span class="string">'a3'</span>], [<span class="string">'b1'</span>, <span class="string">'b2'</span>, <span class="string">'b3'</span>], [<span class="string">'c1'</span>, <span class="string">'c2'</span>, <span class="string">'c3'</span>]]</span><br><span class="line">iterator = zip(*nums)  <span class="comment"># 参数为list数组时，是压缩数据，相当于zip()函数</span></span><br><span class="line">print(<span class="string">"type of iterator is %s"</span> % type(iterator))  <span class="comment"># 输出zip(*zipped)函数返回对象的类型</span></span><br><span class="line">iterator = list(iterator)  <span class="comment"># 因为zip(*zipped)函数返回一个zip类型对象，所以需要转换为list类型</span></span><br><span class="line">print(iterator)</span><br><span class="line">print(<span class="string">"------------------------------------------"</span>)</span><br><span class="line">print(<span class="string">"a_b_zip ："</span>, a_b_zip)</span><br><span class="line">print(<span class="string">"zip(*a_b_zip) ："</span>, list(zip(*a_b_zip)))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">type of a_b_zip <span class="keyword">is</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">zip</span>'&gt;</span></span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">------------------------------------------</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">type of iterator <span class="keyword">is</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">zip</span>'&gt;</span></span><br><span class="line">[('a1', 'b1', 'c1'), ('a2', 'b2', 'c2'), ('a3', 'b3', 'c3')]</span><br><span class="line">------------------------------------------</span><br><span class="line">a_b_zip ： [(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">zip(*a_b_zip) ： [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>
<p>ps：<code>zip()</code>函数的返回对象转换成<code>list</code>不是必须的，只是为了方便输出，<code>list</code>输出很直观</p>
<h2 id="用zip-反转字典"><a href="#用zip-反转字典" class="headerlink" title="用zip()反转字典"></a>用zip()反转字典</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br><span class="line">m.items()</span><br><span class="line">print(list(zip(m.values(), m.keys())))</span><br><span class="line">mi &#x3D; dict(zip(m.values(), m.keys()))</span><br><span class="line">print(mi)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;d&#39;)]</span><br><span class="line">&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中print格式化输出用法</title>
    <url>/2020/05/06/PYTHON%E4%B8%ADprint%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Python中print用法里面-、-s-、-d-代表的意思"><a href="#Python中print用法里面-、-s-、-d-代表的意思" class="headerlink" title="Python中print用法里面% 、%s 、 % d 代表的意思"></a>Python中print用法里面% 、%s 、 % d 代表的意思</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>%s</code>表示格化式一个对象为字符<br><code>%d</code>表示格化式一个对象为整数<br><code>%</code>字符：标记转换说明符的开始<br>在<code>%</code>的左侧放置一个字符串（格式化字符串），右侧放置希望格式化的值    </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"Hello, %s"%"zhang3" =&gt; "Hello, zhang3"</span><br><span class="line">"%d"%33 =&gt; "33"</span><br><span class="line">"%s:%d"%("ab",3) =&gt; "ab:3"</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'%s plus %s equals %s'</span> % (<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">'1 plus 2 equals 2'</span></span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">LOTTERY_PRE = <span class="string">"LXG_LOT_"</span></span><br><span class="line">LOTTERY_ITEM = LOTTERY_PRE + <span class="string">'%s_ITEM'</span></span><br><span class="line">new_version = <span class="string">"20181007220245756"</span></span><br><span class="line">new_lobbery_item = LOTTERY_ITEM % new_version</span><br><span class="line">print(new_lobbery_item)</span><br><span class="line"></span><br><span class="line">输出 LXG_LOT_20181007220245756_ITEM</span><br></pre></td></tr></table></figure></li>
<li>%s 字符串<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string=<span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"string=%s"</span> % string) <span class="comment"># output: string=hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是hello</span></span><br><span class="line">print(<span class="string">"string=%2s"</span> % string) <span class="comment"># output: string=hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格</span></span><br><span class="line"><span class="comment"># 所以%7s的打印结果是  hello</span></span><br><span class="line">print(<span class="string">"string=%7s"</span> % string)<span class="comment"># output: string=  hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格</span></span><br><span class="line"><span class="comment"># 所以%-7s的打印结果是hello  !</span></span><br><span class="line">print(<span class="string">"string=%-7s!"</span> % string)<span class="comment"># output: string=hello  !</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是he</span></span><br><span class="line">print(<span class="string">"string=%.2s"</span> % string) <span class="comment"># output: string=he</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身</span></span><br><span class="line"><span class="comment"># 所以%.7s的打印结果是hello</span></span><br><span class="line">print(<span class="string">"string=%.7s"</span> % string)<span class="comment"># output: string=hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串</span></span><br><span class="line"><span class="comment"># 当截取的字符串长度小于a时，还需要在其左侧补空格</span></span><br><span class="line">print(<span class="string">"string=%7.2s"</span> % string )<span class="comment"># output: string=     he</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"string=%2.7s"</span> % string )<span class="comment"># output: string=hello</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"string=%10.7s"</span> % string) <span class="comment"># output: string=    hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用%.s来表示精度，两个*的值分别在后面小括号的前两位数值指定</span></span><br><span class="line">print(<span class="string">"string=%*.*s"</span> % (<span class="number">7</span>,<span class="number">2</span>,string)) <span class="comment"># output: string=     he</span></span><br></pre></td></tr></table></figure></li>
<li>%d 整型<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num=<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %d打印时结果是14</span></span><br><span class="line">print(<span class="string">"num=%d"</span> % num) <span class="comment"># output: num=14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %1d意思是打印结果为1位整数，当整数的位数超过1位时，按整数原值打印，所以%1d的打印结果还是14</span></span><br><span class="line">print(<span class="string">"num=%1d"</span> % num) <span class="comment"># output: num=14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数左侧补空格，所以%3d的打印结果是 14</span></span><br><span class="line">print(<span class="string">"num=%3d"</span> % num) <span class="comment"># output: num= 14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %-3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数右侧补空格，所以%3d的打印结果是14_</span></span><br><span class="line">print(<span class="string">"num=%-3d!"</span> % num) <span class="comment"># output: num=14 !</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %05d意思是打印结果为5位整数，当整数的位数不够5位时，在整数左侧补0，所以%05d的打印结果是00014</span></span><br><span class="line">print(<span class="string">"num=%05d"</span> % num) <span class="comment"># output: num=00014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %.3d小数点后面的3意思是打印结果为3位整数，</span></span><br><span class="line"><span class="comment"># 当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果是014</span></span><br><span class="line">print(<span class="string">"num=%.3d"</span> % num) <span class="comment"># output: num=014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %.0003d小数点后面的0003和3一样，都表示3，意思是打印结果为3位整数，</span></span><br><span class="line"><span class="comment"># 当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果还是014</span></span><br><span class="line">print(<span class="string">"num=%.0003d"</span> % num) <span class="comment"># output: num=014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %5.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，再在左侧补空格，</span></span><br><span class="line"><span class="comment"># 规则就是补0优先，最终的长度选数值较大的那个，所以%5.3d的打印结果还是  014</span></span><br><span class="line">print(<span class="string">"num=%5.3d"</span> % num)<span class="comment"># output: num=  014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %05.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，</span></span><br><span class="line"><span class="comment"># 由于是05，再在左侧补0，最终的长度选数值较大的那个，所以%05.3d的打印结果还是00014</span></span><br><span class="line">print(<span class="string">"num=%05.3d"</span> % num) <span class="comment"># output: num=00014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用%.d来表示精度，两个*的值分别在后面小括号的前两位数值指定</span></span><br><span class="line">print(<span class="string">"num=%*.*d"</span> % (<span class="number">4</span>,<span class="number">3</span>,num)) <span class="comment"># output: num= 014</span></span><br></pre></td></tr></table></figure></li>
<li>%f 浮点型<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># %a.bf，a表示浮点数的打印长度，b表示浮点数小数点后面的精度</span></span><br><span class="line"><span class="comment"># 只是%f时表示原值，默认是小数点后5位数</span></span><br><span class="line">print(<span class="string">"PI=%f"</span> % math.pi) <span class="comment"># output: PI=3.141593</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只是%9f时，表示打印长度9位数，小数点也占一位，不够左侧补空格</span></span><br><span class="line">print(<span class="string">"PI=%9f"</span> % math.pi) <span class="comment"># output: PI= 3.141593</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有.而没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补0</span></span><br><span class="line">print(<span class="string">"PI=%03.f"</span> % math.pi) <span class="comment"># output: PI=003</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够左侧补空格</span></span><br><span class="line">print(<span class="string">"PI=%6.3f"</span> % math.pi) <span class="comment"># output: PI= 3.142</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %-6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够右侧补空格</span></span><br><span class="line">print(<span class="string">"PI=%-6.3f!"</span> % math.pi) <span class="comment"># output: PI=3.142 !</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以用%.f来表示精度，两个*的值分别在后面小括号的前两位数值指定</span></span><br><span class="line">print(<span class="string">"PI=%*.*f"</span> % (<span class="number">6</span>,<span class="number">3</span>,math.pi)) <span class="comment"># output: PI= 3.142</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H270ec52cb1794e5cb700f741bdd71aafA.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>LEETCODE双周赛26</title>
    <url>/2020/06/04/LEETCODE%E5%8F%8C%E5%91%A8%E8%B5%9B26/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="LEETCODE双周赛26"><a href="#LEETCODE双周赛26" class="headerlink" title="LEETCODE双周赛26"></a>LEETCODE双周赛26</h1><h2 id="1446-连续字符"><a href="#1446-连续字符" class="headerlink" title="1446.连续字符"></a><a href="https://leetcode-cn.com/problems/consecutive-characters/submissions/" target="_blank" rel="noopener">1446.连续字符</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>双指针（滑动窗口）</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPower</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == s[j]) j++;</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, j - i);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;            </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1447-最简分数"><a href="#1447-最简分数" class="headerlink" title="1447.最简分数"></a><a href="https://leetcode-cn.com/problems/simplified-fractions/" target="_blank" rel="noopener">1447.最简分数</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>gcd+遍历</p>
</blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y ? gcd(y, x % y) : x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">simplifiedFractions</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gcd(j, i) == <span class="number">1</span>)</span><br><span class="line">                    result.push_back(to_string(i) + <span class="string">"/"</span> + to_string(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448.统计二叉树中好节点的数目"></a><a href="https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">1448.统计二叉树中好节点的数目</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>简简单单的dfs，记录遍历的节点的最大值</p>
</blockquote>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, INT_MIN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> maxn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = maxn &lt;= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) ans += dfs(root-&gt;left, <span class="built_in">max</span>(maxn, root-&gt;val));</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) ans += dfs(root-&gt;right, <span class="built_in">max</span>(maxn, root-&gt;val));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1449-数位成本和为目标值的最大数字"><a href="#1449-数位成本和为目标值的最大数字" class="headerlink" title="1449.数位成本和为目标值的最大数字"></a><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">1449.数位成本和为目标值的最大数字</a></h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>完全背包</p>
</blockquote>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) f[<span class="number">0</span>][i] = <span class="number">-1e8</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= cost[i - <span class="number">1</span>]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - cost[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">9</span>][target] &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>, j = target; i; i--)</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= cost[i - <span class="number">1</span>] &amp;&amp; f[i][j] == f[i][j - cost[i - <span class="number">1</span>]] + <span class="number">1</span>) &#123;</span><br><span class="line">                res += to_string(i);</span><br><span class="line">                j -= cost[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hdd96bb61417945ca90a15b8b5b98b5a1g.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE</category>
      </categories>
      <tags>
        <tag>LEETCODE/比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中strip()、lstrip()、rstrip()用法详解</title>
    <url>/2020/05/04/PYTHON%E4%B8%ADstrip-%E3%80%81lstrip-%E3%80%81rstrip-%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中strip-、lstrip-、rstrip-用法详解"><a href="#PYTHON中strip-、lstrip-、rstrip-用法详解" class="headerlink" title="PYTHON中strip()、lstrip()、rstrip()用法详解"></a>PYTHON中strip()、lstrip()、rstrip()用法详解</h1><p>Python中有三个去除头尾字符、空白符的函数，它们依次为:</p>
<p><code>strip</code>： 用来去除头尾字符、空白符(换行、回车、制表符、空格)<br><code>lstrip</code>：用来去除开头字符、空白符(换行、回车、制表符、空格)<br><code>rstrip</code>：用来去除结尾字符、空白符(换行、回车、制表符、空格)    </p>
<p><strong>注意</strong>：这些函数都只会删除头和尾的字符，中间的不会删除</p>
<p>用法分别为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string.strip([chars])</span><br><span class="line">string.lstrip([chars])</span><br><span class="line">string.rstrip([chars])</span><br></pre></td></tr></table></figure></p>
<p>参数<code>chars</code>是可选的，当<code>chars</code>为空，默认删除<code>string</code>头尾的空白符   </p>
<p>当<code>chars</code>不为空时，函数会被<code>chars</code>解成一个个的字符，然后将这些字符去掉    </p>
<p>它返回的是去除头尾字符(或空白符)的<code>string</code>副本，<code>string</code>本身不会发生改变</p>
<p>举例说明如下：</p>
<ol>
<li><p>当chars为空时，默认删除空白符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">' ab cd '</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.strip() <span class="comment">#删除头尾空格</span></span><br><span class="line"><span class="string">'ab cd'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.lstrip() <span class="comment">#删除开头空格</span></span><br><span class="line"><span class="string">'ab cd '</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.rstrip() <span class="comment">#删除结尾空格</span></span><br><span class="line"><span class="string">' ab cd'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当chars不为空时，函数会被chars解成一个个的字符，然后将这些字符去掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">'1a2b12c21'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2.strip(<span class="string">'12'</span>) <span class="comment">#删除头尾的1和2</span></span><br><span class="line"><span class="string">'a2b12c'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2.lstrip(<span class="string">'12'</span>) <span class="comment">#删除开头的1和2</span></span><br><span class="line"><span class="string">'a2b12c21'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2.rstrip(<span class="string">'12'</span>) <span class="comment">#删除结尾的1和2</span></span><br><span class="line"><span class="string">'1a2b12c'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>API之lowerer_bound/upper_bound用法</title>
    <url>/2020/06/02/API%E4%B9%8Blowerer-bound-upper-bound%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="API之lowerer-bound-upper-bound用法"><a href="#API之lowerer-bound-upper-bound用法" class="headerlink" title="API之lowerer_bound/upper_bound用法"></a>API之lowerer_bound/upper_bound用法</h1><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound()"></a>lower_bound()</h2><p><code>lower_bound(beg, end, val, comp)</code>  </p>
<p><strong>参数</strong>：</p>
<ol>
<li><p>一个数组元素的地址（或者数组名来表示这个数组的首地址，用来表示这个数组的开头比较的元素的地址，不一定要是数组的首地址，只是用于比较的“首”地址）</p>
</li>
<li><p>一个数组元素的地址（对应的这个数组里边任意一个元素的地址，表示这个二分里边的比较的”结尾’地址）</p>
</li>
<li><p>就是一个要二分查找的那个数</p>
</li>
<li><p><code>greater&lt;int&gt;()</code>代表降序，<code>less&lt;int&gt;()</code>代表升序，默认是升序，也就是数组元素从小到大排列</p>
</li>
</ol>
<p><strong>返回值</strong>:</p>
<p>返回值就是返回第一次出现大于等于那个要查找的数的地址</p>
<p><strong>注意</strong>：</p>
<ol>
<li><p>返回值是地址，不是指那个要查找的数的下标，所以就注定了在这个函数的后边就要减去一个尾巴，那就是这个数组的数组名，即这个数组的首地址,只有这样才代表那个要查找的数字的下标</p>
</li>
<li><p>那就是要大于等于那个数，等于好理解，大于怎么理解呢，比如说我并没有找到那个数，加入一个的数组里边就有5个数，分别是1,1,1,3,5,而我需要找的那个数就是2，怎么返回呢？就是返回那个第一个大于2的数的地址，就是返回3的地址，那么再有一组数据就是5个数1,1,1,3,3，还是需要找寻2，那么该返回什么呢？那就是第一个3的地址</p>
</li>
</ol>
<p><strong>示例</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k, n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">"的第一个大于等于它的位置在"</span> &lt;&lt; ((lower_bound(a, a + n, k)) - a) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>结果</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 3 3 5 5 5 5 6 </span><br><span class="line">3</span><br><span class="line">3的第一个大于等于它的位置在4</span><br><span class="line">5</span><br><span class="line">5的第一个大于等于它的位置在6</span><br></pre></td></tr></table></figure></p>
<h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound()"></a>upper_bound()</h2><p><code>upper_bound</code>函数的用法<code>lower_bound</code>函数的用法相似，不过这个唯一的不同就是返回的是第一个比我要找的那个数大的数的地址，注意，这里并没有等于，也就是说如果在5个数1,1,2,2,4，里边寻找3，那么就会返回4的地址</p>
<p><strong>示例</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k, n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">"的第一个大于它的位置在"</span> &lt;&lt; ((upper_bound(a, a + n, k)) - a) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>结果</strong>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 3 3 5 5 5 5 6 </span><br><span class="line">5</span><br><span class="line">5的第一个大于它的位置在10</span><br><span class="line">1</span><br><span class="line">1的第一个大于它的位置在4</span><br></pre></td></tr></table></figure></p>
<h2 id="set和map中的upper-bound-lower-bound"><a href="#set和map中的upper-bound-lower-bound" class="headerlink" title="set和map中的upper_bound/lower_bound"></a>set和map中的upper_bound/lower_bound</h2><p>和上述一样的功能，不过其本身<code>class</code>内的放法比调用用外部的<code>upper_bound/lower_bound</code>效率高</p>
<h2 id="灵活使用"><a href="#灵活使用" class="headerlink" title="灵活使用"></a>灵活使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; spfs;</span><br><span class="line"><span class="keyword">auto</span> spf = spfs.upper_bound(cows[i].second);</span><br><span class="line">spf--;</span><br></pre></td></tr></table></figure>
<p>这就实现了找小于等于<code>cows[i].second</code>的数中最大值的功能</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++常用API</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中反转字符串的三种方法</title>
    <url>/2020/05/04/PYTHON%E4%B8%AD%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中反转字符串的三种方法"><a href="#PYTHON中反转字符串的三种方法" class="headerlink" title="PYTHON中反转字符串的三种方法"></a>PYTHON中反转字符串的三种方法</h1><h2 id="1-切片法（最简洁的一种）"><a href="#1-切片法（最简洁的一种）" class="headerlink" title="1.切片法（最简洁的一种）"></a>1.切片法（最简洁的一种）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse1</span><span class="params">()</span>:</span></span><br><span class="line">    s = input(<span class="string">"请输入需要反转的内容："</span>)</span><br><span class="line">    <span class="keyword">return</span> s[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(reverse1())</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line"></span><br><span class="line">请输入需要反转的内容：莺啼岸柳弄春晴 柳弄春晴夜月明</span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This is extended slice syntax. It works by doing [begin:end:step] - by leaving begin and end off and specifying a step of -1, it reverses a string.<br>这是扩展片语法。它的工作方式是[begin:end:step]-离开begin和end并指定步骤-1，它反转字符串。</p>
</blockquote>
<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse2</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> reverse2(s[<span class="number">1</span>:])+s[<span class="number">0</span>]</span><br><span class="line">print(reverse2(<span class="string">"莺啼岸柳弄春晴 柳弄春晴夜月明"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line"></span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<h2 id="3-借用列表的reverse-方法"><a href="#3-借用列表的reverse-方法" class="headerlink" title="3.借用列表的reverse()方法"></a>3.借用列表的reverse()方法</h2><blockquote>
<p>reverse()函数将列表的内容进行了反转，借助这个特性，可以先将字符串转换成列表，利用reverse()函数进行反转后，再处理成字符串。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse3</span><span class="params">(s)</span>:</span></span><br><span class="line">    l=list(s)</span><br><span class="line">    l.reverse()</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">""</span>.join(l))</span><br><span class="line">print(reverse3(<span class="string">"莺啼岸柳弄春晴 柳弄春晴夜月明"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line"></span><br><span class="line">明月夜晴春弄柳 晴春弄柳岸啼莺</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hfcd7e2903a7c4c7fa83684713e6c0b37b.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>张一鸣：我的大学四年收获及工作感悟</title>
    <url>/2020/06/21/%E5%BC%A0%E4%B8%80%E9%B8%A3%EF%BC%9A%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E6%94%B6%E8%8E%B7%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS.</p>
</blockquote>
<hr>
<h1 id="张一鸣：我的大学四年收获及工作感悟"><a href="#张一鸣：我的大学四年收获及工作感悟" class="headerlink" title="张一鸣：我的大学四年收获及工作感悟"></a>张一鸣：我的大学四年收获及工作感悟</h1><blockquote>
<p>张一鸣，男，1983年出生，福建永定人，北京字节跳动科技有限公司创始人、CEO，今日头条创始人、原CEO。<br>张一鸣2005年毕业于南开大学软件工程专业，曾参与创建酷讯、九九房等多家互联网公司，历任酷讯技术委员会主席、九九房创始人兼CEO。2012年，张一鸣创办字节跳动。<br>2013年，他先后入选《福布斯》“中国30位30岁以下的创业者”和《财富》“中国40位40岁以下的商业精英”，是中国国内互联网行业最受关注的青年领袖之一。<br>2020年4月6日，张一鸣以950亿元人民币财富名列《胡润全球百强企业家》第89位。2020年5月12日，张一鸣以785.3亿元人民币财富名列《2020新财富500富人榜》第19位。       </p>
</blockquote>
<h2 id="大学里的三点收获"><a href="#大学里的三点收获" class="headerlink" title="大学里的三点收获"></a>大学里的三点收获</h2><p>2001年我考入了南开大学，起初大学的生活是让人有点失落的，但慢慢地从安静朴素的校园和踏实努力的氛围中，我还是找到了自己的节奏。大学期间我主要在做三件事情 ，一是写代码，因为我是搞技术的；二是看书，看了很多很多书；三是修电脑。基于此自己也有三点收获：耐心，知识，伙伴。</p>
<p>第一点收获：耐心。有耐心，能独处，并基于长期思考做判断，而不为短期因素所干扰，耐心地等待你设想和努力的事情逐步发生，这对创业来说是非常重要的事情。事实上，你经常想象的很美好，设计的也很完整，你也很努力，但你所期待的事情，经常需要很长时间才能发生。这种耐心，绝对是在南开磨练出来的。</p>
<p>大学的时候我是怎么面对枯燥的生活？人物传记是非常好的心灵鸡汤。我读了很多人物传记，如果说有收获，就是发现那些伟大的人，在没有成为伟大的人之前，也是过着看起来枯燥的生活，每天都在做一些微不足道的事情，但这些事情最后从点连成线，成就了他们。</p>
<p>我毕业后参与创立了酷讯、饭否、99房、到现在的今日头条，每一段创业经历，都挺寂寞的。现在回想，耐心非常重要，不仅是等待的耐心，还要有耐心做深入思考，还要有耐心地找到更多更好的合作伙伴。</p>
<p>第二点收获：看书。寂寞的大学生活，给了我人生最安静的阅读时光。我用别人打游戏、打牌的时间，阅读了各种各样的书，或者说乱七八糟的书，包括各个专业的书，包括人物传记，也有各种境内外的报刊杂志。</p>
<p>当然，那时候，我也有困惑，觉得看的这些东西和思考的问题都很有意思，但在生活中没什么用。直到后来我进入互联网行业并开始创业，各种各样的知识才连成线，帮我理解行业、理解管理，更快地掌握不熟悉的领域，包括如何让信息得到更有效率的组织和分发，从而改变各行各业的效率。</p>
<p>2011年，我观察到一个现象，地铁上读报的人、卖报的人越来越少，年初还有，年底几乎没有了， 同时，2011年是智能手机出货量的高峰，是2008年、2009年、2010年三年智能手机出货量的总和。我想，这是信息传播介质的变革，手机很可能会取代纸媒成为信息传播的最主要载体，又因为人和手机的对应关系，手机随身携带，个性化推荐的需求一定会增加，于是我创办了今日头条。</p>
<p>第三点收获：结交了很多的伙伴。我在读大学的时候结识了很多优秀的同伴。作为一个不怎么参与集体活动的理工男，怎么保持社交呢？主要靠修电脑和编程建网站……后来，同学聚会，打招呼的方式基本是：hi，你的电脑还是我装的。我装过的电脑有几十台，当然大部分是女同学……不但要帮忙装电脑还要经常保修。没错，就像你们想象的那样，修电脑为我带来了人生重大的收获——当时的女朋友，现在的太太。</p>
<p>在校园里，我接了不少外包的项目。包括我太太她们系的网站(当然是免费的)。因为这门手艺加上兼职，大四的时候，我每月能有超过两三千的收入，在当时，绝对是土豪。那时候，和同学一起泡实验室，熬到半夜一两点，会请大家集体去烤串。一周能吃2-3次。</p>
<p>当时和我吃烧烤的人很多是对编程感兴趣，而且志趣相投的同学朋友，有我同一级的，微电子专业的，软件工程专业的，还有师兄师弟，后来也相继加入我创办的公司，成为了我们公司的技术骨干，也是创业伙伴。</p>
<h2 id="我的工作感悟"><a href="#我的工作感悟" class="headerlink" title="我的工作感悟"></a>我的工作感悟</h2><p>2005 年，我从南开大学毕业，加入一家叫酷讯的公司。我是最早期加入的员工之一，一开始只是一个普通工程师，但在工作第二年，我在公司管了四五十个人的团队，负责所有后端技术，同时也负责很多产品相关的工作。</p>
<p>有人问我：为什么你在第一份工作中就成长很快？是不是你在那个公司表现特别突出？其实不是。当时公司招聘标准很高，跟我同期入职的就有两个清华计算机系的博士。那我是不是技术最好？是不是最有经验？都不是。后来我想了想，当时自己有哪些特质。</p>
<p>首先，我工作时，从不分哪些工作是我该做的，哪些不是我该做的。我做完自己的工作后，对于大部分同事的问题，只要我能帮助解决，我都去做。当时，Code Base中大部分代码我都看过。新人入职时，只要我有时间，我都给他讲解一遍。通过讲解，我自己也能得到成长。</p>
<p>工作的前两年，我基本上每天都是十二点、一点回家，回家后也编程到挺晚。确实是因为有兴趣，而不是公司有要求。所以我很快从负责一个抽取爬虫的模块，到负责整个后端系统，开始带一个小组，后来带一个小部门，再后来带一个大部门。</p>
<p>当时我负责技术，但遇到产品上有问题，也会积极地参与讨论，想产品的方案。很多人说这个不是我该做的事情。但我想说：你的责任心，希望把事情做好的动力，会驱动你做更多事情，让你得到很大的锻炼。</p>
<p>我当时是工程师，但参与产品的经历，对我后来转型做产品有很大帮助。我参与商业的部分，对我现在的工作也有很大帮助。记得在2007年底，我跟公司的销售总监一起去见客户。这段经历让我知道，怎样的销售才是好的销售。当我组建今日头条招人时，这些可供参考的案例，让我在这个领域不会一无所知。</p>
<h2 id="我的创业初心"><a href="#我的创业初心" class="headerlink" title="我的创业初心"></a>我的创业初心</h2><p>我很尊敬Elon Mask ，他不仅创办了TESLA ，而且还创办了一家叫Space X的公司，目标是革新太空科技，终极目标是人类能够在其他星球生活。</p>
<p>Space X现在是全世界第一家私人向太空发射火箭并实现回收的公司，尽管在前沿领域里不断探索的过程非常艰难，身后甚至连跟随者都没有，但Elon Mask一直相信：只要理论上能够成立，理论上可以做到最好，那就应该去努力实现它。</p>
<p>我特别欣赏这种追求卓越和领先的勇气。年轻人创业，就是要去创造新的技术，做那些理论上存在但还没有实现的东西，给世界带来根本性的进步。创业，有人想的是要赚笔钱，有人想的则是要做件事，我觉得自己是后者。</p>
<p>如果你偶然发现青霉素能消炎，你是先考虑用它去救人还是赚钱呢？应该都是先想到救人。我也是一样。到了这个时代，有个性化的方式来推荐信息，我就想把它做出来。</p>
<p>如果我想卖掉这家公司，现在就可以拿到一大笔钱。但我奋斗的目标不是赚钱和享乐，支撑我的是自我实现，希望有更多的创造体验，更丰富的人生经历，希望遇到更多优秀的人。</p>
<p>现在的创业环境和以前相比已经非常好了，创业能取得多大的成果，最重要的是，你到底愿意做多大的事情。年轻人关键是立志高远，享受拼的过程，不自满，不懈怠。要把成功的目标，设定的尽可能远。</p>
<p>优秀年轻人的五个特点<br>后来，我陆续加入到各种创业团队。在这个过程中，我跟很多毕业生共处过，现在还和他们很多人保持联系。跟你分享一下，我看到的一些好和不好的情况。总结一下，这些优秀年轻人有哪些特点呢？</p>
<p>第一个特点：有好奇心，能够主动学习新事物、新知识和新技能。我有个前同事，理论基础挺好，但每次都是把自己的工作做完就下班了。</p>
<p>他在这家公司呆了一年多，但对网上的新技术、新工具都不去了解，非常依赖别人，当他想要实现一个功能，就需要有人帮他做后半部分，因为他自己只能做前半部分。如果是有好奇心的人，前端、后端、算法都去掌握，至少有所了解的话，那么很多调试分析，自己一个人就可以做。</p>
<p>第二个特点：对不确定性保持乐观。比方说，今日头条刚开始时，我跟大家讲：我们要做1亿的日启动次数，很多人觉得，你这家小公司怎么可能做得到呢？如果对此持怀疑态度，就不敢努力去尝试。只有乐观的人会相信，会愿意去尝试。</p>
<p>其实我加入酷讯时也是这样，那家公司当时想做下一代搜索引擎（最后也没有做成，只做了旅游的垂直搜索）。我不知道其他人怎么想的，我自己觉得很兴奋。我确实没有把握，也不知道怎么做，但当时就去学，就去看所有相关的东西。我觉得最后也许不一定做成，或者没有完全做到，但这个过程也会很有帮助——只要对事情的不确定性保持乐观，你会更愿意去尝试。</p>
<p>第三个特点：不甘于平庸。走入社会后的年轻人，应该设定更高的标准。大学期间的同学、一起共事的同事中，有很多非常不错的人才，技术、成绩都比我好，但10年过去了，很多人没有达到我当初的预期。</p>
<p>很多人毕业后，目标设定就不高。我回顾了一下，发现有同事加入银行IT部门：有的是毕业后就加入，有的是工作一段时间后加入。为什么我把这个跟「不甘于平庸」挂在一起呢？因为他们很多人加入，是为了快点解决北京户口，或者得到买经济适用房的机会。</p>
<p>如果一个人一毕业，就把目标定在这儿：在北京五环内买一个小两居、小三居，把精力都花在这上面，那么工作就会受到很大影响，他的行为会发生变化，不愿意冒风险。</p>
<p>如果不甘于平庸，希望做得非常好的话，其实不会为这些东西担心，这很重要。我说不平庸，并不是专指薪酬要很高或者技术很好，而是你对自己的标准一定要高。也许你前两年变化得慢，但10年后再看，肯定会非常不一样。</p>
<p>第四个特点：不傲娇，要能延迟满足感。在这里举个反例：两个我印象比较深刻的年轻人，素质、技术都蛮不错，也都挺有特点。我当时是他们的主管，发现他们在工作中deliver（传递）的感觉始终不好。</p>
<p>他们觉得其他同事做得不如他们，其实不是：他们确实可以算作在当时招的同事里面 TOP20% ，但他们觉得自己是 TOP1% 。所以很多基础一点的工作，比如要做一个调试工具，他就不愿意做，或者需要跟同事配合的工作，他就配合得不好。</p>
<p>本来都是资质非常好的人才，人非常聪明、动手能力也强，但没有控制好自己的傲娇情绪。我觉得这和「不甘于平庸」不矛盾。「不甘于平庸」是你目标要设得很高，「不傲娇」是你对现状要踏实。</p>
<p>另一个例子是，当时我们有个做产品的同事，也是应届生招进来，当时大家都觉得他不算特别聪明，就让他做一些辅助性的工作，统计一下数据，做一下用户反弹之类，但现在他已经是一家十亿美金公司的副总裁。</p>
<p>后来我想想，他的特点就是肯去做，负责任，从不推诿，只要有机会承担的事情，他总尽可能地做好。每次也不算做得特别好，但我们总是给他反馈。他去了那家公司后，把一个用户量不足 10 万的边缘频道负责起来，越做越好。由于是边缘频道，没有配备完整的团队，所以他一个人承担了很多职责，也得到了很多锻炼。</p>
<p>第五个特点：对重要的选择要有判断力。选什么专业、选什么公司、选什么职业、选什么发展路径，自己要有判断力，不要被短期选择所左右。比如，原先有很多人愿意去外企，不愿意去新兴公司。</p>
<p>2006 年、2007年的时候，很多师弟、师妹问我职业选择，我都建议他们去百度，不要去IBM、微软。但实际上，很多人都是出于短期考虑：外企可能名气大、薪酬高一点。</p>
<p>虽然这个道理，大家都听过很多遍。刚毕业时薪酬差三五千块，真的可以忽略不计。短期薪酬差别并不重要。但实际上，能摆脱这个、能有判断力的人，也不是特别多。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/148c824d-4eb8-48d3-9825-51625347b0f0.png" alt=""></p>
]]></content>
      <categories>
        <category>大佬经历</category>
      </categories>
      <tags>
        <tag>大佬经历</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEFORCES/ROUND/647/DIV2</title>
    <url>/2020/06/06/CODEFORCES-ROUND-647-DIV2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CODEFORCES-ROUND-647-DIV2"><a href="#CODEFORCES-ROUND-647-DIV2" class="headerlink" title="CODEFORCES/ROUND/647/DIV2"></a>CODEFORCES/ROUND/647/DIV2</h1><h2 id="A-Johnny-and-Ancient-Computer"><a href="#A-Johnny-and-Ancient-Computer" class="headerlink" title="A.Johnny and Ancient Computer"></a><a href="https://codeforces.com/problemset/problem/1362/A" target="_blank" rel="noopener">A.Johnny and Ancient Computer</a></h2><h3 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h3><p><code>1000</code>，标签：<code>implementation</code>   </p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给一个两个正整数，一个初始值，一个目标值，可以对初始值进行位运算，向左移动三位或两位或一位，或者向右移动三位或一位或两位，要求向右移动时必须除尽，舍弃小数部分的右移运算被禁止，求移动到目标值的最小次数，如果无法得到目标值则输出<code>-1</code>      </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果目标值大于初始值，则左移，反之在可以右移的情况下右移，先移动位数多的，后移动位数小的，移动一次答案加一   </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                  \</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);              \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &gt; b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;&gt; <span class="number">3</span> &gt;= b &amp;&amp; a % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    a = a &gt;&gt; <span class="number">3</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;&gt; <span class="number">2</span> &gt;= b &amp;&amp; a % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    a = a &gt;&gt; <span class="number">2</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;&gt; <span class="number">1</span> &gt;= b &amp;&amp; a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    a = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a == b)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; nums &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt; b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt;&lt; <span class="number">3</span> &lt;= b) &#123;</span><br><span class="line">                    a = a &lt;&lt; <span class="number">3</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a &lt;&lt; <span class="number">2</span> &lt;= b) &#123;</span><br><span class="line">                    a = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a &lt;&lt; <span class="number">1</span> &lt;= b) &#123;</span><br><span class="line">                    a = a &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    nums++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a == b)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; nums &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Johnny-and-His-Hobbies"><a href="#B-Johnny-and-His-Hobbies" class="headerlink" title="B.Johnny and His Hobbies"></a><a href="https://codeforces.com/problemset/problem/1362/B" target="_blank" rel="noopener">B.Johnny and His Hobbies</a></h2><h3 id="难度-1"><a href="#难度-1" class="headerlink" title="难度"></a>难度</h3><p><code>1200</code>，标签：<code>brute force</code></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给一个集合，里面元素为数字，求一个最小的正整数<code>K</code>，使每个集合的每个元素与<code>K</code>进行<code>XOR</code>运算后集合元素等于原集合元素，意味着集合的元素顺序改变，但元素大小不改变  </p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>取第一个元素，求分别<code>XOR</code>其他元素的<code>K</code>，再对每个元素异或<code>K</code>，看看运算后的集合是否等于原集合，求出最小的<code>K</code>    </p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                  \</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);              \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1500</span>];</span><br><span class="line"><span class="keyword">int</span> aa[<span class="number">1500</span>];</span><br><span class="line"><span class="keyword">int</span> bb[<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(aa, <span class="number">0</span>, <span class="keyword">sizeof</span> aa);</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">            aa[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1025</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j ^ nums[<span class="number">0</span>]) == nums[i]) &#123;</span><br><span class="line">                    tt = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tt != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(bb, <span class="number">0</span>, <span class="keyword">sizeof</span> bb);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a; j++) &#123;</span><br><span class="line">                    bb[nums[j] ^ tt]++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1500</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (aa[k] != bb[k]) flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="literal">true</span>) ans = <span class="built_in">min</span>(ans, tt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Johnny-and-Another-Rating-Drop"><a href="#C-Johnny-and-Another-Rating-Drop" class="headerlink" title="C.Johnny and Another Rating Drop"></a><a href="https://codeforces.com/problemset/problem/1362/C" target="_blank" rel="noopener">C.Johnny and Another Rating Drop</a></h2><h3 id="难度-2"><a href="#难度-2" class="headerlink" title="难度"></a>难度</h3><p><code>1400</code>，标签：<code>math</code>、<code>dp</code></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数，问从<code>1</code>到此正整数（设为每个数Ki）的二进制形式与前一位（Ki-1）的二进制形式的每位二进制不一样的数量是多少，如果两个二进制位数不同，用<code>0</code>来填充   </p>
<p>假如正整数为<code>5</code></p>
<p>则<code>0</code>到<code>5</code>的二进制分别为：<code>000</code> <code>001</code> <code>010</code> <code>011</code> <code>100</code> <code>101</code><br><code>000</code>和<code>001</code>不同的位为最低位，数量为<code>1</code><br>所以从<code>1</code>到<code>5</code>分别为：<code>1</code> <code>2</code> <code>1</code> <code>3</code> <code>1</code>，总共为<code>8</code>  </p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>两种思路：第一种找规律，第二种数位<code>dp</code>   </p>
<p>思路<code>1</code>：可以发现最低位二进制一直是<code>01</code>变化，所以其贡献是<code>n</code>，倒数第二位，同理可推出贡献为<code>n/2</code>，所以推到二进制第<code>i</code>位，贡献是<code>n&lt;&lt;(i−1)</code>   ，累加就可以了   </p>
<p>思路<code>2</code>：打开<code>OEIS</code>，输入数列，求出<code>DP</code>公式，递归即可，香   </p>
<p>这里给出思路<code>1</code>的代码  </p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                  \</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);              \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">"\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = num;</span><br><span class="line">        <span class="keyword">while</span> (num) &#123;</span><br><span class="line">            ans += temp / i;</span><br><span class="line">            i *= <span class="number">2</span>;</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Johnny-and-Contribution"><a href="#D-Johnny-and-Contribution" class="headerlink" title="D.Johnny and Contribution"></a><a href="https://codeforces.com/problemset/problem/1361/A" target="_blank" rel="noopener">D.Johnny and Contribution</a></h2><h3 id="难度-3"><a href="#难度-3" class="headerlink" title="难度"></a>难度</h3><p><code>1700</code>，标签：<code>greedy</code>，<code>constructive algorithms</code>    </p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有个傻逼想写博客，每个文章一个主题，一个主题可以被多个文章写，文章之间可以互相引用，但是互相引用的文章的主题不能相同   </p>
<p>这个傻逼写博客有个毛病，写文章时，选择的主题序号要最小，比如一个文章的引用文章的主题为<code>1</code>和<code>3</code>，那么此逼在写这个文章时用的主题序号为<code>2</code>  </p>
<p>假设给定文章数目<code>N</code>，从<code>1</code>到<code>N</code>的文章的主题规定为一个序列，现在这个逼从头写文章，问他写文章的次序，如果文章的主题不能达到此序列，输出<code>-1</code>   </p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>转化为一个图，每个文章为一个节点，文章间的引用当作节点之间的边，主题当作节点的权值  </p>
<p>先把所有边记录下来，然后把最后要得到的图的节点按照权值从小到大排序，之后按照节点权值选择先填的节点，在填充节点的过程中，如果此节点填充的值为<code>M</code>，则它的相连节点（且已被填充）的个数必须为<code>M-1</code>，且相连的节点（已填充）的权值必须是从<code>1</code>到<code>M-1</code>，如果不满足则输出<code>-1</code>，最后输出填充的顺序   </p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forn(i, n) for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for1(i, n) for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS                      \</span></span><br><span class="line">    ios::sync_with_stdio(flase); \</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);                  \</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">8e18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], p[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x] &lt; a[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    forn(i, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        e[u].push_back(v);</span><br><span class="line">        e[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    for1(i, n) <span class="built_in">cin</span> &gt;&gt; a[i], p[i] = i;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, cmp);</span><br><span class="line">    for1(i, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = p[i];</span><br><span class="line">        <span class="keyword">int</span> val = a[u];</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u])</span><br><span class="line">            <span class="keyword">if</span> (ans[v]) s.insert(ans[v]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != val - <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x != cnt) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[u] = a[u];</span><br><span class="line">    &#125;</span><br><span class="line">    for1(i, n) <span class="built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Johnny-and-Grandmaster"><a href="#E-Johnny-and-Grandmaster" class="headerlink" title="E.Johnny and Grandmaster"></a><a href="https://codeforces.com/problemset/problem/1361/B" target="_blank" rel="noopener">E.Johnny and Grandmaster</a></h2><h3 id="难度-4"><a href="#难度-4" class="headerlink" title="难度"></a>难度</h3><p><code>1900</code>，标签：<code>greedy</code></p>
<h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给两个数<code>N</code>和<code>P</code>，输入<code>N</code>个数，把<code>N</code>个数分为两个集合，以<code>P</code>为底，把每个集合的元素作为幂次，把集合的每个元素作为幂次算出来的值相加和为S，求出两个集合的S的差值最小为多少   </p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>思路<code>1</code>：从大到小枚举<code>p^k</code>，拿一个变量<code>cur</code>记录当前的枚举数字的幂次，<code>dif</code>记录当前集合中的数字的大小是当前枚举的数字的倍数，<code>ans</code>记录最终的值。枚举新一轮的时候，当<code>dif==0</code>的时候说明集合中的所有数字被抵消了或者循环刚开始，那么<code>cur</code>直接等于此次循环枚举数字的幂次即可，<code>ans</code>也直接等于当前的数字的值模<code>mod</code>即可。如果<code>dif!=0</code>说明当前集合不为<code>0</code>，我们就让集合中的数字减去当前枚举的数字，可以考虑把<code>cur</code>先化为跟当前枚举数字的幂次相同，这样<code>dif</code>就会不断乘底数<code>p</code>，如果<code>dif</code>变得大于<code>1e6</code>(也可以精确点写成<code>i</code>),说明当前集合中的数字已经是当前枚举数字的至少<code>1e6</code>倍大，那么就没必要接着枚举了，因为<code>N</code>的长度最大才是<code>1e6</code>，直接减去后面所有的数字即可，因为即使减去了后面所有的数字也一定还有剩余。如果小于<code>1e6</code>，就让<code>dif--</code>（减去当前枚举的这个数字后倍数自然会减一），计算幂时我们用到了快速幂的思想    </p>
<p>思路<code>2</code>：开双模数，有一定几率倍卡，但是概率太小忽略不计。首先知道一点，集合中的数字不可能减少为负数。那么每次减少一个数，看两个答案<code>ans1</code>，<code>ans2</code>是否同为<code>0</code>，同为<code>0</code>说明集合中的值被减少为<code>0</code>，然后就加上下一个枚举的数字，然后继续减后面的数字，重复这个过程，最后输出<code>ans1</code>就行了。<code>ans1</code>和<code>ans2</code>是按照不同的模数来算的，<code>ans1</code>的模数是题目要求的模数，<code>ans2</code>的模数是自己随便定的大模数</p>
<p>这里给出思路<code>1</code>的代码  </p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * c % P;</span><br><span class="line">        c = c * c % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (n &amp; <span class="number">1L</span>L) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        <span class="keyword">int</span> dif = <span class="number">0</span>, cur = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dif) &#123;</span><br><span class="line">                cur = a[i];</span><br><span class="line">                dif = <span class="number">1</span>;</span><br><span class="line">                ans += qpow(p, a[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (cur &gt; a[i]) &#123;</span><br><span class="line">                    cur --;</span><br><span class="line">                    dif *= p;</span><br><span class="line">                    <span class="keyword">if</span> (dif &gt; i) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur == a[i]) &#123;</span><br><span class="line">                    dif --;</span><br><span class="line">                    ans -= qpow(p, a[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                        ans -= qpow(p, a[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans % P + P) % P;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Johnny-and-Megan’s-Necklace"><a href="#F-Johnny-and-Megan’s-Necklace" class="headerlink" title="F.Johnny and Megan’s Necklace"></a><a href="https://codeforces.com/contest/1362/problem/F" target="_blank" rel="noopener">F.Johnny and Megan’s Necklace</a></h2><h3 id="难度-5"><a href="#难度-5" class="headerlink" title="难度"></a>难度</h3><p><code>2500</code>，标签：<code>dfs and similar</code></p>
<blockquote>
<p>未完待续</p>
</blockquote>
<p><img src="https://ae01.alicdn.com/kf/H0ba75266cb0440beb2cf8772fb0034c9O.jpg" alt=""></p>
]]></content>
      <categories>
        <category>CODEFORCES</category>
      </categories>
      <tags>
        <tag>CODEFORCES/比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>黄峥：我的人生经历和创业理念</title>
    <url>/2020/06/21/%E9%BB%84%E5%B3%A5%EF%BC%9A%E6%88%91%E7%9A%84%E4%BA%BA%E7%94%9F%E7%BB%8F%E5%8E%86%E5%92%8C%E5%88%9B%E4%B8%9A%E7%90%86%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS.</p>
</blockquote>
<hr>
<blockquote>
<p>黄峥，浙江杭州人。拼多多创始人、董事长兼首席执行官。<br>2002年，本科毕业于浙江大学，2004年获得美国威斯康星大学麦迪逊分校计算机硕士学位，随后加入美国谷歌。2006年回国，参与谷歌中国办公室的创立。2007年，从谷歌离职创业，先后创立电商代运营公司和游戏公司。2015年4月，创立拼好货，开创社交电商新模式。2016年9月，拼好货、拼多多宣布合并，黄峥担任新公司的董事长兼首席执行官。<br>2020年4月6日，黄峥以1280亿元人民币财富名列《胡润全球百强企业家》第53位 。2020年5月12日，黄峥以1368.4亿元人民币财富名列《2020新财富500富人榜》第8位。 </p>
</blockquote>
<h1 id="黄峥：我的人生经历和创业理念"><a href="#黄峥：我的人生经历和创业理念" class="headerlink" title="黄峥：我的人生经历和创业理念"></a>黄峥：我的人生经历和创业理念</h1><p>分享一篇黄峥故事，有点长，耐心读</p>
<h2 id="人生经历篇"><a href="#人生经历篇" class="headerlink" title="人生经历篇"></a>人生经历篇</h2><h3 id="上学"><a href="#上学" class="headerlink" title="上学"></a>上学</h3><p>小时候谈不上贫穷，但比较拮据，小时候经常要穿妈妈同事或者是亲戚家小孩的衣服。很多消费习惯和前期的家庭环境有很大关系，跟现在拥有的财富没太大关联。比如我妈到现在都舍不得打车，她会觉得时间又不值钱，太浪费了。这个对我一直有很大影响，包括影响我思考做商业，我脑子里一直都记着我爸妈这样的普通家庭，他们是怎么思考的，他们是怎么生活的。</p>
<p>我的小学很一般，但考上了杭州最好的中学之一，杭州外国语学校。相比于其他中学，接受西方文化影响更早，程度也更深。杭外毕业后被保送到浙大混合班，也就是浙大竺可桢学院的前身。</p>
<p>我在上学时就意识到几个事。<strong>一是寒门出贵子是小概率事件，大部分富二代，尤其是官二代非常优秀。二是田忌赛马，在整体资源劣势的情况下可以创造出局部优势，进而有机会获得整个战役的胜利。基于此，平凡人可以成就平凡事。第三是钱是工具，不是目的。</strong></p>
<p>我在上学时有一个<strong>较大的遗憾，就是自己目标导向太明确，在追求第一、努力做个好学生上浪费了过多时间，损失了逆反、捣蛋的青春时光，后来才慢慢悟到“60分万岁是个好哲学”。</strong></p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>我第一个实习的公司是微软，但毕业时没有留在微软。一是觉得自己留在微软能看到自己十年后的样子。另外，“人生导师”介绍我去当时还不成熟的Google。所以我就在Google做程序员和产品经理，后来还成为Google第一批回国员工参与Google中国的初创阶段。</p>
<p>我对Google有一些个人的观察。</p>
<p>一是Google非常重意识形态，当意识形态发生冲突时，反应超出一般商业公司。</p>
<p>二是Google鼓励基层创新，但核心权力高度集中，有集中办大事的制度优势。</p>
<p>三是Google的“不作恶”深入到了基因，把使命、价值观放在了利润之前，而利润只是随着做正确的事带来的副产品。</p>
<p>四是Google的大部分收购很成功，这些收购案例大多是收购了拥有很好团队的小公司，这些小公司融入到Google的文化逐渐变大。不过也有很多事是Google无力改变的，比如Google没有逃脱层层职业经理人的管理模式，Google在社交上的尝试也不成功。</p>
<h3 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h3><p>2002年我去美国读研究生认识了段永平，毕业后在Google工作时又离他家很近，所以开始帮他做一些投资。</p>
<h3 id="创业"><a href="#创业" class="headerlink" title="创业"></a>创业</h3><p>我最早创业做的是电商代运营和游戏公司，对于商业来说，只有赚钱才是道德的，应该按照商业的逻辑去做一个本分的商人。</p>
<p>我为什么要再次创业？一是我还喜欢当前的事和团队，我很喜欢深度的和一帮自己喜欢的小伙伴披荆斩棘的创造一些东西。第二是自己还有一些野心，还有一些能力和能量没有释放，隐约觉得当前的机会能让自己做出一个影响面更大、成就感更强的事。</p>
<h2 id="创业理念篇"><a href="#创业理念篇" class="headerlink" title="创业理念篇"></a>创业理念篇</h2><h3 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h3><h4 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h4><p>消费升级不是让上海人去过巴黎人的生活，而是让安徽安庆的人有厨纸用，有好水果吃。</p>
<p>只有北京五环内的人才会说移动互联网第三波人口带来的是下沉人群，拼多多关注的是中国最广大的老百姓。移动互联网未必是用户的下沉，而是用户拉平了，它让最广大的中国老百姓拥有了和一线城市一样信息获取的能力和交易能力，这是PC时代做不到的。</p>
<p>拼多多吸引的是追求高性价比的人群，他会买一个爱马仕的包，也会用9.9元买一箱芒果，这跟消费能力没关系。实惠这件事，是一个普适性的需求。比如我妈已经算是一个有钱的妈妈，但她出去买菜、买纸巾，还是会在乎一两块钱的差异，但她同时也买高配的iPhone。传统公司采用一二三线来划分人，拼多多满足的是一个人的很多面。</p>
<p>低价只是拼多多阶段性获取用户的方式，拼多多对性价比的理解是“始终在消费者的期待之外”，拼多多的核心不是便宜，而是满足用户占便宜的感觉。</p>
<p>拼多多试图做消费和娱乐的融合，拼多多的使命就是多实惠多乐趣，让消费者买到更多更实惠的东西，然后在这个过程中更快乐。</p>
<p>拼多多的核心竞争力就是五环内的人群理解不了。</p>
<h4 id="运营情况"><a href="#运营情况" class="headerlink" title="运营情况"></a>运营情况</h4><p>现阶段拼多多对整个商品和服务的品质管控都很初级，拼多多正在通过升级供应链和打击假货来提高商品质量。</p>
<p>部分员工对公司的理解依然是流量至上，这些员工在流量思维环境里受了多年教育，拼多多成立不久，和员工的统一思想还没做得很好，得从上往下贯彻。现在的情况是我在这一头，整个社会和媒体在流量的那一头，员工可能在中间。</p>
<p>拼多多对运营员工的考核是留存、复购第一，GMV第二。（gmv即Gross Merchandise Volume，主要是指网站的成交金额，而这里的成交金额包括：付款金额和未付款。）</p>
<h4 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h4><p>拼多多不会做采销，也不会做物流和配送，对供应链升级是拼多多长期的战略重点。拼多多的最终模式是使得上游能做批量定制化生产。</p>
<p>全品类扩张依然是传统的流量逻辑，品牌升级也是一个五环内人群俯视的视角。拼多多不一定要品牌升级、要全品类，拼多多要做的事情永远是匹配，让合适的人在合适的场景下买到合适的东西。</p>
<p>拼多多目前没想做服务电商，因为实物电商已经足够大。服务电商是流量思维，即流量灌进来，用不同的服务去消耗这个流量。拼多多的出现就是因为不用旧思维，在以人为先的思维下，先想这个人需要什么。</p>
<h3 id="与竞争对手"><a href="#与竞争对手" class="headerlink" title="与竞争对手"></a>与竞争对手</h3><p>拼多多与淘宝的模式有本质的不同。淘宝是流量逻辑，主体是搜索，用户要自己去找商品，所以需要海量SKU来满足长尾需求。拼多多代表的是匹配，推荐商品给消费者，SKU有限，但要满足结构性丰富。淘宝一直倡导C2B但做不起来，就是因为淘宝的千人千面相当于个性化搜索，但搜索本身是长尾的，很难做反向定制。而拼多多是把海量流量集中到有限商品里，有了规模之后再反向定制，极大降低成本。这也就是沃尔玛和Costco的差别，拼多多的终级定位就是针对不同的人群做不同的Costco。</p>
<p>拼多多和淘宝是错位竞争，争夺的是同一批用户的不同场景，错位才会成长的更快。拼多多并不想做第二个阿里，拼多多的存在本身就是一种模式，你可以说我low，说我低级，但你无法忽视我。</p>
<p>京东、唯品会和蘑菇街都试验过类似拼多多的模式，但对它们来说，拼团只是一个创造GMV增长工具，拼多多是人的逻辑，通过拼团了解人，通过人推荐物，后期会过渡到机器推荐物。拼多多在APP里几乎没有搜索，也不设购物车，可以想象把今日头条下的信息流换成商品流就是拼多多。</p>
<h3 id="与腾讯的关系"><a href="#与腾讯的关系" class="headerlink" title="与腾讯的关系"></a>与腾讯的关系</h3><p>我认为腾讯并没有扶持拼多多，因为拼多多也被封了很多次。京东和蘑菇街可以在微信的入口做微选，但是拼多多没法做。2018年前拼多多和腾讯签署了一份互不挖猎协议，拼多多要挖腾讯的人，只有腾讯同意才可以。腾讯更像是一个普通的财务投资人，不会有特殊的好与不好，我不认为拼多多是腾讯系。</p>
<p>当出现谣言说拼多多诈骗，并在微信群广泛传播时，我寻求微信的帮助被拒绝，微信说如果是阿里来找就能处理。我认为微信帮拼多多，群众会说因为腾讯是拼多多的股东，微信帮阿里辟谣就叫格局高。</p>
<p>腾讯的儿子太多，即便拼多多死了腾讯依然不会死。腾讯投资拼多多的逻辑不是为了和阿里强竞争，更多的是商人逻辑，因为投资拼多多有回报，竞争只是商业ROI计算的副产品。</p>
<p>阿里和腾讯对线下零售的占比都很低，当抛开流量思维，聚焦场景时空间依然很大。</p>
<p>腾讯做电商失败的原因是它们认为电商是流量*转换率=GMV，流量逻辑在今天无法成功。</p>
<h3 id="投资和创业"><a href="#投资和创业" class="headerlink" title="投资和创业"></a>投资和创业</h3><p>巴菲特说买股票就是买part of the company，要有长期持有的心态去寻找好的生意和合伙人。这和创业很像，一方面要关注生意的模式，选择正确的生意模式，要花大量时间去研究这个生意模式的细节。另一方面要挑好的“合伙人”，在投资时要把创始人和CEO当成自己未来的合伙人，看自己是不是愿意和他们长期做事。</p>
<p>投资除了关注好生意，好团队，还需要在乎是否是好价钱，这和创业也很相似，查理芒格让巴菲特意识到该用一个合理的价钱去买好公司，而不是花时间去捡烟蒂（价格便宜，有些残余价值的、但往往不那么好的公司）。同样，一个好的公司应该花力气去解决/克服那些正确又难的问题，而不是四处捡一大堆芝麻。</p>
<p>投资另一个和价钱相关的点是看这个deal in loss是否整体可以承受，从创业的角度看就是投入一个事业的时候要看会不会把自己搞死，活着是创业的第一要务。同时又要用另一个角度来评估，即能不能赢，有没有足够的力量去赢。</p>
<p>和投资特别要关注商业模型一样，创业本身对行业及生意模式的选择也往往决定了很大一部分结果，也就是要花大量时间去研究什么是正确的事，然后再想如何把事做正确。在正确的方向上逐步前进远比在不正确的方向狂奔要好。创业很多时候和投资一样，选择比努力重要。在正确的道路上前行哪怕慢一点，但像投资中复利的连续回报也是很厉害的。</p>
<p>巴菲特在谈到投资标的时候，经常会提到生意的护城河。如果把创业过程中的各种决策都当做是投资决策，那我们得分辨我们用时间和钱换来的东西哪些是资产，哪些是费用。那些随着时间流逝，对加深生意护城河有利的往往是“资产”，那些时间越久对自己越不利的可以看成是费用。在资产的购置上，错误的浪费其实是不太会的，最多只是买贵了一些。而在费用的浪费上则非常可恶，往往还有负作用。</p>
<h2 id="思维方式篇"><a href="#思维方式篇" class="headerlink" title="思维方式篇"></a>思维方式篇</h2><h3 id="认知能力"><a href="#认知能力" class="headerlink" title="认知能力"></a>认知能力</h3><p>对于未知领域，我通常会采取比较原始的办法，就是自己去体验和感受，用常识来判断。大部分知识是没用的，遇到问题再解决问题。我不会去规划未来五年、十年，我会想一个很远的目标和很近的目标。</p>
<p>绝大多数人在绝大多数方面都比我强，我只在很少的方面比很少的人强。比如隔绝外部压力，回归本源理性思考的能力，有时候有点逆向思考的能力。以前做二级市场发现自己好像天生不太容易在很多人恐惧的时候恐惧，而容易在大众热情的时候悲观。</p>
<h3 id="对电影院现象的思考"><a href="#对电影院现象的思考" class="headerlink" title="对电影院现象的思考"></a>对电影院现象的思考</h3><p>劣币驱逐良币侧面描述的是自私不团结的个体无法对抗管理者的强制力的现象。另一个角度来说，也描述了通过利用个体自私的力量来进行财富重新分配降低公共服务成本的一种现象。电影院现象和劣币驱逐良币类似，但其实它描述的是一个没有组织，又缺乏外部强制力的自私个体的群体，可能出现的一种集体自我伤害的现象。如果电影院前排人站起来，后排的人也会站起来，结果就破坏了大家本可以坐着看的秩序。也就是说，“劣币驱逐良币”是一股力量战胜另一股力量推动劣币的普及，而电影院现象是一个群体自我伤害的现象，谁都没有真正获益，更加值得研究和应对。</p>
<p>电影院先站起来的那部分人，就像是掉进汤里的一粒屎，很快整锅汤就只能倒掉，这是指出的是一个比例问题。汤其实有自我净化能力，如果比例低没问题，但这个比例只要上升到一个临界点，原有的净化能力就崩溃了。坏一锅汤的一粒屎的大小的临界点是很低的，也许是百分之一和百分之五的区别。百分之一能净化，百分之五就只能全部扔掉了。很多时候，质变就是在这1%到5%之间。在商业上，Amazon在图书份额远低过50%就实质决定了图书的定价进而颠覆了图书零售业。</p>
<p>为什么有的东西贵了反而好卖？比如空调这种产品既需要有人安装，又需要有人推荐。有可能类似小米的互联网直销，把价格打到最低点还不如格力给安装者、渠道以足够利润。虽然看起来渠道的做法抬高了商品的价钱，但在实践中，渠道和服务成本也许是维护某种公共认识最节省、良性的做法。这种渠道和服务成本是必须的，它把维护某种秩序的代价体现在明处，而忽略了这种代价的体系可能会走向“劣币驱逐良币”。</p>
<h3 id="对供给侧需求侧的思考"><a href="#对供给侧需求侧的思考" class="headerlink" title="对供给侧需求侧的思考"></a>对供给侧需求侧的思考</h3><p>要从根本上变革供给侧，得先变革需求侧。</p>
<p>第一类供给侧的变革是满足了一直存在却未被完全满足的需求，比如有人想飞，就诞生了飞机满足飞的需求。</p>
<p>第二类供给侧的变革源于新的应用场景的出现。比如在世界大战这种突发场景下，衣服以及很多其他生活用品被成批量、大规模、标准化的需要，推动了供给侧生产组织、管理和交付流通上的极大变革。</p>
<p>第三种供给侧的变革源发于信息收集成本大幅变化，比如Uber的出现大幅降低了收集路线、位置以及打车需求的归集成本。</p>
<p>第三类变革存在着大量的可能性拿时间和空间的统一来换取整体效率更高，成本更低。抽象来说，存在一个通过推动需求流通侧更多的采用计划，以此来推动供给侧打破滞后的大规模生产实现中小规模批量的“定制”的半市场经济的可能，即用需求流通侧的半“计划经济”来推动实现供给侧的半“市场经济”。</p>
<p>线上电子商业解决了把义乌小商品市场搬到网上的问题，流通侧的信息高度透明化，加速了各商贩之间的竞争，但对传统制造业的工厂改变不多，工厂生产还是要一些计划，主体的工厂主要还是依赖于线下商超的批量订单，按几个月甚至半年一年的周期在排计划。线上的商贩竞争越激烈，越市场化，和线下生产计划的脱节和对比也越厉害，国际需求的批量外贸订单的计划和线上零售卖的订单之间的脱节也越厉害。这种情况下，主体的工厂主要还是依赖于沃尔玛、家乐福，线上纯流通侧的极度市场化也不改变生产侧计划的滞后性和高度计划性。</p>
<p>存不存在一种模型能改变生产侧的滞后性和高度的刚性计划性？假设我们能让前端消费者多一点耐心及和其他人协调的愿望，放弃一部分所见即所得、现在马上要的冲动，那么我们就有机会利用人和人推荐、人和人之间关系、兴趣的相似点，做人以群分的归并，把每个人人性化的需求归集成有一定时间富裕度的计划性需求。这种需求的归集程度也许没有像沃尔玛这种半年期的批量订单那么大，但也够让工厂一条产线经济的运转。如果能这样做，流通侧线上高度市场化和生产侧刚性计划的矛盾也就能缓解。更多计划性的需求和更多市场的供给侧相融合，前后端信息会更全面的打通，消除需求和生产的错配，帮助我们摆脱对传统类沃尔玛商超的依赖，实现从滞后的计划走向与需求同步的半市场化。</p>
<h3 id="对财富转移的思考"><a href="#对财富转移的思考" class="headerlink" title="对财富转移的思考"></a>对财富转移的思考</h3><p>保险这种产品进一步促进了财富从没钱人向有钱人的转移，进一步放大了资本的力量。如此下去，如果市场是高度有效不受干扰的，法律是保障资本及其复利的合法性的，那么很可能会使得富的人越富，穷的人越穷。</p>
<p>巴菲特之所以能让人敬佩。主要在于他除了能把资本的游戏玩到极致，更加清楚钱不是目的。他一方面享受着资本游戏的快乐，另一方面把绝大多数钱捐给了比尔盖茨基金会，完成财富应有的再分配。同时，他还倡议其他富人也把钱捐出来，倡议国家提高富人的税收，从机制上进行更大力度的财富再分配。</p>
<p>存不存在一些机制让穷人也能卖“保险”给富人，从而实现更精细化的反馈，周期更短的钱从富人向穷人回流的循环呢？比如说有一千人在夏天的时候就想到在冬天的时候要买一件某种样子的羽绒衣，将联名订单给生产厂商，并愿意按去年的价格出10%的订金。这种情况下，工厂很有可能是愿意给他们30%的折扣的。因为工厂从联名订单里获得了一个工厂原来不具有的一种需求的确定性。这种确定性可以转变为利用生产计划低谷进行生产的便利，也可以转化为采购原材料时候的笃定。工厂甚至可以把这种确定性进一步售卖给上游和配套厂商使得成本进一步降低。</p>
<p>每个人（无论是穷人还是富人）对自己的意愿，对于自己在未来某个点的需求和规划比其他人要清楚得多，这种个人规划和意愿，以及个体对自身某个行为的确定性的把握，对供给方往往是有价值的，它可以降低组织生产的不确定性，可以帮助实现资源以及资本的更有效配置。因此我猜想资本家和富人是愿意向普通人、穷人反购这种成本的。这种反向保险不再是穷人积累信用和钱向富人借钱付利息或者是花钱给富人买生活的确定性，而是反过来，富人、资本家出钱给普通人、穷人买他的生产资本配置的确定性。</p>
<h3 id="从何处获取力量"><a href="#从何处获取力量" class="headerlink" title="从何处获取力量"></a>从何处获取力量</h3><p>段永平在商业和人生给我的启示是，他说快就是慢，慢就是快。用平常心来做事情会更好，平常人其实很难有平常心。段永平是一个不断学习不断进步的人。他还教给我一个商业常识，就是价格一定会波动，但只要你的价值提升，最终价格会和价值接近。这个常识让你安心于增加企业的内生价值，不要过度在意资本市场的价格波动。此外，段永平教我要胸无大志，做好当前就好。</p>
<p>阿里巴巴创始人之一孙彤宇对我的帮助是，他对平台的理解不一样，比如他认为平台更应该考虑不用阶段的生态演进，而品牌是单个细分人群标新立异的价值主张。</p>
<p>2006年，段永平带上我去参加巴菲特的午餐。我发现巴菲特讲的东西其实特别简单，连我母亲都能听懂。这顿饭最大的意义可能让我意识到简单和常识的力量。对一件事做判断时，你需要了解背景和事实，了解之后需要的不是睿智，而是面对事实时是否还有勇气用理性和常识来判断。常识显而易见、容易理解，但我们因为成长、学习形成的偏见和个人利益的诉求蒙蔽了我们。</p>
<p>读完罗素的《幸福之路》，我总结了几点，</p>
<p>一是要有勇气去面对尝试，用常识做理性的判断，用理性的意念指导自己的行动。</p>
<p>二是要对成就一个无限完美的自己的兴趣，转移为对外部可观事物的兴趣。</p>
<p>三是对不可改变，不可能征服的事要学会放弃。</p>
<p>佛学、量子力学和数理逻辑的不完备定理告诉我们两件事，</p>
<p>一是世界是不可知的，至少是不可精确度量的，是测不准的，是不确定的。</p>
<p>二是用有限的规则去描述规范世界是不可能的，事情是不完美的，不完备的。</p>
<p>除了拼多多，我最希望在未来能转型成真正意义上的科研人员，像富兰克林在40岁以后就不参与商业了，参与科研发明了避雷针，我觉得非营利性的全心全意的科研工作对人类的贡献会更大。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/148c824d-4eb8-48d3-9825-51625347b0f0.png" alt=""></p>
]]></content>
      <categories>
        <category>大佬经历</category>
      </categories>
      <tags>
        <tag>大佬经历</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON中sort()和sorted()的用法</title>
    <url>/2020/06/07/PYTHON%E4%B8%ADsort-%E5%92%8Csorted-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON中sort-和sorted-的用法"><a href="#PYTHON中sort-和sorted-的用法" class="headerlink" title="PYTHON中sort()和sorted()的用法"></a>PYTHON中sort()和sorted()的用法</h1><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><p>列表有自己的<code>sort</code>方法，其对列表进行原址排序，既然是原址排序，那显然元组不可能拥有这种方法，因为元组是不可修改的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">x.sort()</span><br><span class="line"><span class="keyword">print</span> x <span class="comment"># [1, 2, 4, 6, 7, 9]</span></span><br></pre></td></tr></table></figure>
<p>如果需要一个排序好的副本，同时保持原有列表不变，怎么实现呢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x =[<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">y = x[ : ]</span><br><span class="line">y.sort()</span><br><span class="line"><span class="keyword">print</span> y <span class="comment">#[1, 2, 4, 6, 7, 9]</span></span><br><span class="line"><span class="keyword">print</span> x <span class="comment">#[4, 6, 2, 1, 7, 9]</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>y = x[:]</code>通过分片操作将列表<code>x</code>的元素全部拷贝给<code>y</code>，如果简单的把<code>x</code>赋值给<code>y</code>：<code>y=x</code>，<code>y</code>和<code>x</code>还是指向同一个列表，并没有产生新的副本</p>
<p>另一种获取已排序的列表副本的方法是使用sorted函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x =[<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">y = sorted(x)</span><br><span class="line"><span class="keyword">print</span> y <span class="comment">#[1, 2, 4, 6, 7, 9]</span></span><br><span class="line"><span class="keyword">print</span> x <span class="comment">#[4, 6, 2, 1, 7, 9]</span></span><br></pre></td></tr></table></figure>
<p><code>sorted</code>返回一个有序的副本，并且类型总是列表，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> sorted(<span class="string">'Python'</span>) <span class="comment">#['P', 'h', 'n', 'o', 't', 'y']</span></span><br></pre></td></tr></table></figure>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p><code>sort</code>方法还有两个可选参数：<code>key</code>和<code>reverse</code></p>
<p><code>key</code>在使用时必须提供一个排序过程总调用的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;mmm&#39;, &#39;mm&#39;, &#39;mm&#39;, &#39;m&#39; ]</span><br><span class="line">x.sort(key &#x3D; len)</span><br><span class="line">print x # [&#39;m&#39;, &#39;mm&#39;, &#39;mm&#39;, &#39;mmm&#39;]</span><br></pre></td></tr></table></figure>
<p><code>reverse</code>实现降序排序，需要提供一个布尔值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span> ,<span class="number">0</span> , <span class="number">1</span>]</span><br><span class="line">y.sort(reverse = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">print</span> y <span class="comment">#[8, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [(<span class="number">123</span>,<span class="string">'b'</span>,<span class="number">8</span>),(<span class="number">122</span>,<span class="string">'c'</span>,<span class="number">3</span>),(<span class="number">128</span>,<span class="string">'a'</span>,<span class="number">5</span>)]</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组的第1个元素排序,没有任何参数时，默认是由小到大排序</span></span><br><span class="line">a.sort()</span><br><span class="line">print(<span class="string">'\n以元组的第1个元素排序'</span>)</span><br><span class="line">print(a)</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">f'由大到小：<span class="subst">&#123;a&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组的第2个元素排序</span></span><br><span class="line">print(<span class="string">'\n以元组的第2个元素排序'</span>)</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> i:i[<span class="number">1</span>])</span><br><span class="line">print(a)</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> i:i[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">f'由大到小：<span class="subst">&#123;a&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组的第3个元素排序</span></span><br><span class="line">print(<span class="string">'\n以元组的第3个元素排序'</span>)</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> i:i[<span class="number">2</span>])</span><br><span class="line">print(a)</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> i:i[<span class="number">2</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">f'由大到小：<span class="subst">&#123;a&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hd768bd7dd9b74f66abfafe1c877ce715C.jpg" alt=""></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO+BUTTERFLY搭建骚气且实用的个人网站</title>
    <url>/2020/05/27/HEXO-BUTTERFLY%E6%90%AD%E5%BB%BA%E9%AA%9A%E6%B0%94%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>YOU CAN DRINK ALL YOU LIKE, BUT IN THE MORNING YOU GET HEADACHE WITH THE SAME PROBLEMS.</p>
</blockquote>
<hr>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>最近狂刷<code>codeforces</code>，但是逐渐发现自身一个问题，那就是刷过的题虽然在当天感觉很明白，但是隔一天，隔两天，就发现自己再遇到此题时又是一翻鏖战，这就是说明自己做过的题吸收的效率不够高，于是我就打算做一道题总结一道题。那么问题来了，在哪里总结呢？</p>
<p>首先排除的是微信公众号，众所周知，微信公众号只能是自己分享东西的平台，而在这上面总结知识点就会引出很多问题，其一，每篇文章都要排版，其二，我的粉丝未必合此文章的胃口，其三，每天只能发布一篇文章，大大限制了自己的总结内容与时间分配。</p>
<p>那么诸如<code>csdn</code>、博客园、掘金、知乎这种东西呢？也有很多不方便的地方，比如文章左右侧的广告，实在影响人的心情，此外还有审核等等的制约，思前想后，我决定自己开辟一个个人网站。</p>
<p>当然不能从无到有手动开辟，自己能力有限，而且我的目的也是总结，总不能让自己以后把大把的时间浪费到维护网站上面去。于是我听从了大佬的建议，采用<code>hexo+github</code>的方式，<code>hexo</code>开辟网站，托管到<code>github</code>上面去。</p>
<p>花里胡哨的页面也是最吸引我的原因之一，我采用了<code>butterfly</code>的主题，绝对美炸天！</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程当然是心酸+心酸+心酸，心态险些被搞没。至于搭建网站的教程，实话实说，看了n多篇技术总结，都号称史上最全，到最后还是觉得看官方文档最省事。</p>
<p>当然自己也找到了一些好的文章，在此列出来希望对大家有帮助：</p>
<p><code>hexo</code>安装文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/a1a4ebf0e5fc" target="_blank" rel="noopener">Hexo+Butterfly+Github+Coding搭建个人博客</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="noopener">hexo官方文档</a></li>
</ul>
<p><code>butterfly</code>主题系列文章：</p>
<ol>
<li><a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(一)快速开始</a></li>
<li><a href="https://jerryc.me/posts/dc584b87/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(二)主题页面</a></li>
<li><a href="https://jerryc.me/posts/4aa8abbe/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(三)主题配置</a></li>
<li><a href="https://jerryc.me/posts/98d20436/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(四)主题问答、打赏名单</a></li>
<li><a href="https://jerryc.me/posts/198a4240/" target="_blank" rel="noopener">hexo-theme-butterfly 安装文档(五)更新日誌</a></li>
</ol>
<h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><p>没日没夜的折腾了两天，总能从其中学到什么：其一，当然是收获了又骚又实用的好网站；其二，学会了<code>git</code>+<code>github</code>的基本使用，常见的<code>git</code>命令也记得很熟；其三，收获了一种精神——永不放弃，哪有什么一帆风顺，加油，骚年！</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>自己的网站弄的也不是很成熟，还有很多功能没有上线，比如日历、赞赏等，自己没有买域名，只是托管到<code>github</code>上。</p>
<h2 id="欢迎"><a href="#欢迎" class="headerlink" title="欢迎"></a>欢迎</h2><p><a href="https://haotianliu11.github.io/" target="_blank" rel="noopener">我的个人网站</a></p>
<hr>
<p><img src="https://imgkr.cn-bj.ufileos.com/148c824d-4eb8-48d3-9825-51625347b0f0.png" alt=""></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>PYTHON基础语法总结</title>
    <url>/2020/06/01/PYTHON%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PYTHON视频讲解-MOSH-总结"><a href="#PYTHON视频讲解-MOSH-总结" class="headerlink" title="PYTHON视频讲解(MOSH)总结"></a>PYTHON视频讲解(MOSH)总结</h1><h2 id="和C-C-的区别"><a href="#和C-C-的区别" class="headerlink" title="和C/C++的区别"></a>和C/C++的区别</h2><ol>
<li><p><code>python</code>的<code>print</code>是一个函数，其中代表换行的参数默认换行，所以每次执行一次<code>print</code>都会自动换行</p>
</li>
<li><p><code>python</code>的<code>bool</code>值是<code>False</code>和<code>True</code>，首字母大写，而<code>C/C++</code>的<code>bool</code>类型值是<code>false</code>和<code>true</code>，首字母小写  </p>
</li>
<li><p><code>python</code>的输出函数是<code>print</code>，而<code>C</code>的输出语句是<code>printf</code></p>
</li>
<li><p><code>python</code>的输入语句是<code>input()</code>，这个函数把括号内的东西输出，并接受输入的值，所以可以有如下写法<code>name = input(&quot;what&#39;s your name&quot;)</code></p>
</li>
<li><p><code>input</code>把接收的值转化为字符串</p>
</li>
<li><p><code>10/3 = 3.333</code>，这与<code>C/C++</code>不同<br><code>10//3 = 3</code>，这与<code>C/C++</code>相同<br><code>3**2 = 9</code>，<code>C/C++</code>中没有此用法</p>
</li>
<li><p><code>C++</code>中的类与<code>python</code>中的类有一点区别<br>假设都定义了<code>School</code>这个类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++:</span><br><span class="line">School one;</span><br><span class="line"></span><br><span class="line">python:</span><br><span class="line">one &#x3D; School()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ol>
<li><p><code>type</code>(变量) 打印变量的类型  </p>
</li>
<li><p>三个引号<code>&#39;&#39;&#39; &#39;&#39;&#39;</code>，三引号中间的变量可以换行，此外还有双引号和单引号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">email = <span class="string">'''</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">This is Fu JANG 's blog.</span></span><br><span class="line"><span class="string">Welcome to u.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(email)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Hello!</span><br><span class="line">This <span class="keyword">is</span> Fu JANG <span class="string">'s blog.</span></span><br><span class="line"><span class="string">Welcome to u.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">进程已结束,退出代码0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于第二点的代码（三引号）<code>email[0]</code>就是<code>H</code>，<code>email[-1]</code>就是<code>换行符</code>，<code>email[-2]</code>就是<code>.</code>，而对于以下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">email = <span class="string">'Hello'</span></span><br><span class="line">print(email[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">o</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[0:3]</code>左闭右开<br><code>[0:]</code> 0到末尾<br><code>[:3]</code>与第一个等效<br><code>[:]</code> 全部</p>
</li>
<li><p><code>f&#39;{变量名}’</code>  占位符，程序会用对应变量的值去填充大括号  </p>
</li>
<li><p><code>len()</code>  返回字符串的长度</p>
</li>
<li><p><code>.upper()</code>把字符串中字母全部转 为大写，但不改变原字符串<br><code>.lower()</code>把字符串中字母全部转为小写，但不改变原字符串<br><code>.title()</code>把字符串中单词首字母字母全部转为大写，但不改变原字符串<br> <code>.find(&#39;&#39;)</code>找到这个字符在字符串中的第一个索引<br> 若<code>&#39;&#39;</code>中为一串字符，则返回第一个字符的索引<br> 若<code>&#39;&#39;</code>中的字符在字符串中不存在，则返回<code>-1</code><br> <code>.replace(&#39;原&#39;, &#39;新&#39;)</code> 若字符串中没有原字符，则不替换</p>
</li>
<li><p><code>&#39; &#39; in 变量</code> 返回一个布尔值，代表该字符是否在此变量中  </p>
</li>
<li><p><code>round()</code>四舍五入<br><code>abs()</code>取绝对值</p>
</li>
<li><p>引用模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">print(math.ceil(<span class="number">2.9</span>)) 封</span><br><span class="line">print(math.floor(<span class="number">2.9</span>)) 底</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if</code>语句：<br><code>if:</code><br><code>elif:</code><br><code>else:</code>  </p>
</li>
<li><p>逻辑运算符：<br><code>and or not</code>   </p>
</li>
<li><p><code>while</code>循环，当条件不符合时，执行<code>else</code>，<code>break</code>的程序不执行<code>else</code><br><code>while:</code><br><code>else:</code>  </p>
</li>
<li><p><code>range(10)</code> <code>0</code>到<code>9</code><br><code>range(5,10)</code> <code>5</code>到<code>9</code><br><code>range(5,10,2)</code> <code>5,7,9</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码：</span><br><span class="line">for item in range(10):</span><br><span class="line">	print(item)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表：方括号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	[1,2,3],</span><br><span class="line">	[4,5,6],</span><br><span class="line">	[7,8,9]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表定义的方法<br><code>.append()</code> 在最后面插入<br> <code>.insert(0,10)</code> 在索引为0的位置加10<br> <code>.remove(5)</code> 删除第一个5<br> <code>.clear()</code> 清空列表<br> <code>.pop()</code> 删最后<br> <code>.index(5)</code> 传第一个5的索引<br> <code>.count(5)</code> 传5的个数<br> <code>.sort()</code> 不返回值，从小到大排序<br> <code>.reverse()</code> 从大到小排序<br> <code>.copy()</code> 复制</p>
</li>
<li><p><code>(,,)</code> 元组 不可变<br><code>.count()</code> 计数<br><code>.index()</code> 传索引  </p>
</li>
<li><p>压缩属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; (1,2,3)</span><br><span class="line">x, y, z &#x3D; m</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序：</span><br><span class="line">customer = &#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"FuJANG"</span>,</span><br><span class="line">    <span class="string">"sex"</span> : <span class="string">"man"</span>,</span><br><span class="line">    <span class="string">"address"</span> : <span class="string">"China"</span>,</span><br><span class="line">    <span class="string">"age"</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">"is_handsome"</span> : <span class="literal">True</span></span><br><span class="line">&#125;</span><br><span class="line">print(customer[<span class="string">"name"</span>])</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">FuJANG</span><br><span class="line"></span><br><span class="line">进程已结束,退出代码<span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字典定义的方法<br><code>.get(&quot; &quot;)</code> 若键不存在则返回<code>None</code><br><code>.get(&quot;key&quot;, &quot;value&quot;)</code> 提供一个默认的值，并不修改字典，当在字典中对应的<code>key</code>存在时，默认值无效<br>可用此形式更改、添加字典<code>[&quot; &quot;] = &quot; &quot;</code></p>
</li>
<li><p>表示形式<br>列表<code>[ , , ]</code><br>元组<code>( , , )</code><br>字典<code>{  , , }</code>  </p>
</li>
<li><p><code>abc = &quot;字符串”</code><br><code>for ch in abc:</code>遍历字符串中的所有字符<br><code>abc.split(&quot;空格&quot;)</code> 根据空格分割字符串中的单词并储存在一个列表中</p>
</li>
</ol>
<h2 id="函数与模块"><a href="#函数与模块" class="headerlink" title="函数与模块"></a>函数与模块</h2><ol>
<li><p>定义一个函数<br> 每个函数后最好加上两个空行（标准格式），先定义函数后才可引用，<code>()</code>中可以加参数，如<code>(name)</code>,调用时需要传一个值如<code>(&quot;Mosh&quot;)</code>，关键字参数一般放在最后<br> 没有<code>return</code>的函数默认返回<code>None</code><br> 当<code>return x, y</code>时，<code>python</code>把<code>x, y</code>解释为一个元组<code>(x, y)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">()</span>:</span></span><br><span class="line">	内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>try...expect</code>来处理异常错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>：</span><br><span class="line">	×××</span><br><span class="line">expect 错误类型:</span><br><span class="line">	×××</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>class</code>定义一个类，首字母大写，不用下划线<br>  <code>def</code>定义一个函数，首字母小写，用下划线链接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> ×××<span class="params">(self, ×××)</span>:</span></span><br><span class="line">		×××</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> ×××</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">用类声明对象</span></span><br><span class="line">point1 = Point()</span><br><span class="line">调用定义的方法</span><br><span class="line">point1.×××()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以在程序的任何位置设置属性，属性没有必要一定在类里定义</span><br><span class="line">point1.属性名 = <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>python</code>中的构造函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">		self.x = x</span><br><span class="line">		self.y = y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">point1 = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承：当一个类中没有任何东西时，为了规范格式，通常加一个<code>pass</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normal</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></span><br><span class="line">		×××</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Normal)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Normal)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"×××"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hello</span><br><span class="line">hello.×××()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> ×××</span><br><span class="line">×××()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">as</span> he</span><br><span class="line">he.×××()</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立一个包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">① New → Directory → __init__.py</span><br><span class="line">② New → Python Package</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> 包.文件</span><br><span class="line">包.文件.函数()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 包.文件 <span class="keyword">import</span> 函数</span><br><span class="line">函数()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 包 <span class="keyword">import</span> 文件</span><br><span class="line">文件.函数()</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置模块的调用举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># randint 为闭区间</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.random() 随机跳出一个<span class="number">0</span>和<span class="number">1</span>间的数字</span><br><span class="line">random.randint(<span class="number">10</span>, <span class="number">20</span>) <span class="number">10</span>到<span class="number">20</span>间的一个整数值</span><br><span class="line">random.choice(numbers) 假如numbers是一个列表，则随机跳出列表中的一个元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置模块与下载模块<br><code>python</code>中有内置模块，当找不到想使用的模块时，可以去<code>pypi.org</code>寻找相应的模块下载命令，然后在终端上用命令下载相应的模块</p>
</li>
</ol>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON语法</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣python题解(1-100题)</title>
    <url>/2020/06/03/%E5%8A%9B%E6%89%A3python%E9%A2%98%E8%A7%A3-1-100%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1.两数之和</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[nums[i]], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[target - nums[i]] = i</span><br></pre></td></tr></table></figure>
<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2.两数相加</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = cur =ListNode(<span class="number">0</span>)</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                carry += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                carry += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur.next = ListNode(carry%<span class="number">10</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            carry //=<span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3.无重复字符的最长子串</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        p1 = p2 = m = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p2 &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[p2] <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[s[p2]] = <span class="literal">True</span></span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">                m = max(len(d), m)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">del</span> d[s[p1]]</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
<h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4.寻找两个正序数组的中位数</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        totalList = nums1 + nums2</span><br><span class="line">        totalList.sort()</span><br><span class="line">        <span class="keyword">if</span> len(totalList) % <span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">            i = totalList[len(totalList)//<span class="number">2</span>]</span><br><span class="line">            j = totalList[len(totalList)//<span class="number">2</span> - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> (i+j)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> totalList[len(totalList)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        p = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            p1 = self.get_palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            p2 = self.get_palindrome(s, i, i)</span><br><span class="line">            p = max([p, p1, p2], key=<span class="keyword">lambda</span> x: len(x))</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_palindrome</span><span class="params">(self, s: str, l: int, r: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br></pre></td></tr></table></figure>
<h1 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6.Z字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6.Z字形变换</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, S: str, R: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> R == <span class="number">1</span> <span class="keyword">or</span> R &gt; len(S):  <span class="comment"># corner case</span></span><br><span class="line">            <span class="keyword">return</span> S</span><br><span class="line">        res, i, step = [<span class="string">''</span> <span class="keyword">for</span> r <span class="keyword">in</span> range(R)], <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># a string for each line</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> S:</span><br><span class="line">            res[i] += s</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:  <span class="comment"># first row</span></span><br><span class="line">                step = <span class="number">1</span>  <span class="comment"># down</span></span><br><span class="line">            <span class="keyword">if</span> i == R - <span class="number">1</span>:  <span class="comment"># last row</span></span><br><span class="line">                step = <span class="number">-1</span>  <span class="comment"># up</span></span><br><span class="line">            i += step</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure>
<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7.整数反转</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        result = int(str(x)[::<span class="number">-1</span>]) <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -int(str(x)[<span class="number">1</span>:][::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">-2</span>**<span class="number">31</span> &lt;= result &lt;= (<span class="number">2</span>**<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8.字符串转换整数"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8.字符串转换整数</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            ret = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> i.isdigit(): <span class="keyword">return</span> ret</span><br><span class="line">                ret = ret *<span class="number">10</span> + int(i)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        s = str.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'+'</span>: <span class="keyword">return</span> min(<span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>,helper(s[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'-'</span>: <span class="keyword">return</span> max(<span class="number">-2</span>**<span class="number">31</span>,-helper(s[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>].isdigit(): <span class="keyword">return</span> min(<span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>,helper(s))</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9.回文数</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        orig = x</span><br><span class="line">        back_x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            back_x = back_x * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> orig == back_x</span><br></pre></td></tr></table></figure>
<h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.正则表达式匹配</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        s, p = <span class="string">' '</span>+ s, <span class="string">' '</span>+ p</span><br><span class="line">        lenS, lenP = len(s), len(p)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(lenP) <span class="keyword">for</span> i <span class="keyword">in</span> range(lenS)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, lenP):</span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, lenS):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, lenP):</span><br><span class="line">                <span class="keyword">if</span> p[j] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">"*"</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] <span class="keyword">or</span> int(dp[i<span class="number">-1</span>][j] <span class="keyword">and</span> p[j<span class="number">-1</span>] <span class="keyword">in</span> &#123;s[i], <span class="string">'.'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bool(dp[<span class="number">-1</span>][<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11.盛最多水的容器</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        second = len(height) - <span class="number">1</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> first &lt; second:</span><br><span class="line">            area = max((second - first) * min(height[first], height[second]), area)</span><br><span class="line">            <span class="keyword">if</span> height[first] &lt; height[second]:</span><br><span class="line">                first+=<span class="number">1</span>        </span><br><span class="line">            <span class="keyword">else</span>:     </span><br><span class="line">                second-=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure>
<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12.整数转罗马数字</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="string">"I"</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">"IV"</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="string">"V"</span>,</span><br><span class="line">            <span class="number">9</span>: <span class="string">"IX"</span>,</span><br><span class="line">            <span class="number">10</span>: <span class="string">"X"</span>,</span><br><span class="line">            <span class="number">40</span>: <span class="string">"XL"</span>,</span><br><span class="line">            <span class="number">50</span>: <span class="string">"L"</span>,</span><br><span class="line">            <span class="number">90</span>: <span class="string">"XC"</span>,</span><br><span class="line">            <span class="number">100</span>: <span class="string">"C"</span>,</span><br><span class="line">            <span class="number">400</span>: <span class="string">"CD"</span>,</span><br><span class="line">            <span class="number">500</span>: <span class="string">"D"</span>,</span><br><span class="line">            <span class="number">900</span>: <span class="string">"CM"</span>,</span><br><span class="line">            <span class="number">1000</span>: <span class="string">"M"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        arr = [<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">while</span> num &gt;= a:</span><br><span class="line">                num = num - a</span><br><span class="line">                result = result + mapping[a]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13.罗马数字转整数</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span>    </span><br><span class="line">        res, prev = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dict = &#123;<span class="string">'I'</span>:<span class="number">1</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'L'</span>:<span class="number">50</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[::<span class="number">-1</span>]:          </span><br><span class="line">            <span class="keyword">if</span> dict[i] &gt;= prev:</span><br><span class="line">                res += dict[i]     </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res -= dict[i]    </span><br><span class="line">            prev = dict[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14.最长公共前缀</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        l = list(zip(*strs))</span><br><span class="line">        prefix = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">if</span> len(set(i))==<span class="number">1</span>:</span><br><span class="line">                prefix += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure>
<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15.三数之和</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        result = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            l = i + <span class="number">1</span></span><br><span class="line">            r = len(nums) - <span class="number">1</span></span><br><span class="line">            target = <span class="number">0</span> - nums[i]</span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="keyword">if</span> nums[l] + nums[r]== target:</span><br><span class="line">                    result.add((nums[i], nums[l], nums[r]))</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> list(result)</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H26cf739c186b48a7a158b9096c5b651dZ.jpg" alt=""></p>
]]></content>
      <categories>
        <category>LEETCODE</category>
      </categories>
      <tags>
        <tag>力扣/python</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础总结(1)</title>
    <url>/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络基础总结-1"><a href="#计算机网络基础总结-1" class="headerlink" title="计算机网络基础总结(1)"></a>计算机网络基础总结(1)</h1><ol>
<li>局域网：覆盖范围小、自己花钱买设备、带宽固定、自己维护、100米、10M 100M 1000M<br>广域网：距离远、花钱租带宽<br>Internet：由ISP组成、有自己的机房、对网民提供访问Internet连接</li>
<li>ISP：Internet服务提供商（Internet service provide）</li>
<li>DNS：把网站域名解析成IP地址</li>
<li>子网掩码：告诉计算机哪里是网络部分，哪里是主机部分</li>
<li>路由器的作用是在不同网段转发数据</li>
<li>计算机的网卡有mac地址（物理地址），全球唯一，mac地址在计算机出场时已经被固定在网卡中：48位二进制（12位十六进制）</li>
<li><p>计算机访问过程：  </p>
<p>先把要访问的域名发送给DNS服务器，DNS服务器把域名解析成IP地址返回  </p>
<p>数据包由数据、原IP地址、目标IP地址组成  </p>
<p>数据帧由数据、原IP地址、目标IP地址、此时的mac地址、下一个目的地的mac地址组成  </p>
<p>计算机发送数据帧后，数据帧在运输的过程中两个mac地址不断变化，因此不断重新封装，但是数据包没变   </p>
<p>数据帧在运输过程中不断经过路由器，路由器看数据包中的IP地址，决定下一步走哪个mac地址</p>
<p>目标服务器收到请求后，往计算机回传数据，会把数据切割成小块，并给每一块编号，然后取一部分放到目标服务器的缓存当中，再然后在缓存中取出一块，加上此服务器IP地址、目标计算机IP地址、此时的mac地址、下一个目的地的mac开始发送，发送后，此数据块不会被缓存区删除，因为发送的过程中可能会丢失，当目标计算机收到此数据块放到计算机中的缓存区后，发送请求接受下一个数据块的消息到此服务器时，此数据块才会在缓存区被删除  </p>
<p>当计算机的缓存满了时，会读取，然后再存缓存 </p>
<p>第一张图说明：<br> <img src="https://ae01.alicdn.com/kf/Hdb3d351ef0844379b41ec593f99d16506.jpg" alt="">  </p>
<p> 第二张图说明：<br> <img src="https://ae01.alicdn.com/kf/Hdb637a9eee4a485f886ec3430de942ddU.jpg" alt=""></p>
</li>
<li><p>OSI参考模型（国际标准把计算机通信进行的定义）</p>
<ol>
<li>应用层：所有能产生网络流量的程序</li>
<li>表示层：在传输之前是否进行加密或压缩处理、传的是二进制还是ASCII码</li>
<li>会话层：电脑和某服务器建立起的联系，比如电影前进后退进、查木马都是会话层的体现 netstat -n 命令可在终端查看此电脑建立的会话  </li>
<li>传输层：可靠传输（比如某服务器传输数据到计算机、把数据分块传输，如果发送了某一块之后没收到请求下一块的信息，就会接着发送这个数据块，防止数据块丢失）、流量控制（比如服务器发送数据太快了，则计算机发消息告诉服务器调整发送速度）、不可靠传输（比如DNS解析域名，一个数据包就能说明问题与得到答案，不需要建立会话）</li>
<li>网络层：负责选择最佳路径、规划IP地址</li>
<li>数据链路层：帧的开始和结束、透明传输（将数据中与开头或结尾表示相同的部分进行转义）、差错校验（检错错误，数据中多加一部分数据进行校验，但不纠错，只检查，错误的就扔掉，纠错是在传输层进行）  </li>
<li>物理层：接口标准、电器标准、如何在物理链路上传输更快的速度</li>
</ol>
</li>
<li><p>每一层都是一个较为独立的模块，每一个模块变化都不会影响其他的模块；但每一层都有关系：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层-&gt;人（-&gt;代表xx为xx提供服务） </p>
</li>
<li><p>网络出现故障，应该从最底层物理层往上一层一层进行检查  </p>
<ol>
<li>物理层故障：查看连接状态、查看发送和接收的数据包</li>
<li>数据链路层故障：mac地址冲突、ADSL欠费、网速没办法协商一致、计算机连接到错误的VLAN(虚拟局域网)</li>
<li>网络层故障：配置了错误的IP地址、子网掩码、配置错误的网关、路由器没有配置到达目标网络的路由、数据有没有通过各个网关到达指定位置  </li>
<li>应用层故障：应用程序配置错误</li>
</ol>
</li>
<li><p>打开终端输入命令ping一个网址，若数据有来有回，则证明网通了</p>
</li>
<li>OSI参考模型和网络安全<ol>
<li>物理层安全</li>
<li>数据链路层安全：ADSL账号密码、VLAN、交换机端口绑定mac地址</li>
<li>网络层安全：在路由器上时使用ACL控制数据包流量、防火墙</li>
<li>应用层安全：开发的应用程序没漏洞</li>
</ol>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/H66237f88bb294f1db97200f8cd552ddbd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
